{
    "docs": [
        {
            "location": "/MPB/", 
            "text": "MPB\n\n\n\n\nThe \nMIT Photonic-Bands\n (\nMPB\n) package is a \nfree\n program for computing the band structures, or dispersion relations, and electromagnetic modes of periodic dielectric structures, on both serial and parallel computers. MPB computes definite-frequency eigenstates, or harmonic modes, of \nMaxwell's equations\n in periodic dielectric structures for arbitrary wavevectors, using fully-vectorial and three-dimensional methods. It is applicable to many problems in optics, such as waveguides and resonator systems, and \nphotonic crystals\n. For example, it can solve for the modes of waveguides with arbitrary cross-sections.\n\n\nSee also our complementary \nMeep\n package for time-domain simulations, reflection/transmission spectra, etc.\n\n\nFeatures\n\n\n\n\nFree software under the GNU General Public License. See the \nLicense and Copyright\n.\n\n\nFully-vectorial, three-dimensional calculation. Iterative eigensolver techniques are employed to make large, three-dimensional calculations possible. Can also handle 2D and 1D problems.\n\n\nDirect, frequency-domain eigensolver as opposed to indirect methods, e.g. time-domain. For one thing, this means that you get both eigenvalues (frequencies) and eigenstates (electromagnetic modes) at the same time. See a \ncomparison of time-domain and frequency-domain techniques\n.\n\n\nTargeted eigensolver. Normally, iterative eigensolvers provide you with the states (optical bands/modes) with the lowest few frequencies. Our software can alternatively compute the modes whose frequencies are closest to a specified target frequency. This greatly reduces the number of bands that must be computed in guided or resonant mode calculations.\n\n\nFlexible, scriptable user interface based on the \nGuile\n extension \n scripting language.\n\n\nSupport for arbitrary, anisotropic dielectric structures including gyrotropic/magneto-optic materials and non-orthogonal unit cells.\n\n\nField output in \nHDF5\n format for input into many popular graphing and visualization tools.\n\n\nPortable to most Unix-like operating systems. See the \ninstallation guide\n.\n\n\nSupport for parallel machines with MPI.\n\n\n\n\nTo give you some feel for how long these calculations take, let us consider one typical data point. For the 3d band-structure of a \ndiamond lattice of dielectric spheres in air\n, computing the lowest 10 bands on a 16\u00d716\u00d716 grid at 31 k-points, MPB took 8 seconds on a 2.8 GHz AMD Opteron under Linux with the \nATLAS\n optimized BLAS library. Thus, at each k-point, MPB was minimizing a function with 81920 degrees of freedom in 0.26 seconds on average.\n\n\nMPB Download\n\n\nYou can \ndownload\n the full source code in ANSI C for MPB under the \nGPL\n. The \ninstallation guide\n describes how to install it; mainly, this consists of downloading and installing various prerequisites if you do not have them already.\n\n\nThe current version is \n1.5\n. See the \nrelease notes\n for what is new in each version.\n\n\nYou can also download the latest development sources from \nMPB on Github\n.\n\n\nDocumentation\n\n\nThis manual is readable online and is also part of the code repository. The \ntutorials\n demonstrate what it is like to use the program. You may be also interested in the \nlibctl manual\n, which describes a Guile/Scheme-based scripting library that we build our interface on top of, and also additional information on \nGuile and Scheme\n.\n\n\nWe have published a paper on the computational methods underlying MPB:\n\n\nSteven G. Johnson and J. D. Joannopoulos, \nBlock-iterative frequency-domain methods for Maxwell's equations in a planewave basis\n, \nOptics Express\n \n8\n, no. 3, 173-190 (2001).\n\n\nSee also our \nreferencing suggestions\n for how to cite MPB in your work.\n\n\nMailing Lists\n\n\nThe MPB mailing lists and their archives are another source of information about MPB.\n\n\nSubscribe to the read-only \nmpb-announce mailing list\n to receive notifications of updates and releases. Subscribe to the unmoderated \nmpb-discuss mailing list\n for discussions about using MPB. Archives are available \nhere\n. You can also read and post to the list via the \ngmane.comp.science.photonic-bands\n newsgroup from \nGmane\n.\n\n\nBug Reports and Feature Requests\n\n\nFor bug reports and feature requests, please \nfile an MPB Github issue\n.\n\n\nAcknowledgements\n\n\nMany people and groups have contributed to the development of this software, both directly and indirectly. Please see the \nacknowledgements section\n of the manual for those to whom we feel especially grateful.\n\n\nContacts and Feedback\n\n\nIf you have questions or problems regarding MPB, you are encouraged to query the \nmailing list\n.\n\n\nFor professional consulting as well as free access to MPB in the public cloud via Amazon Web Services (AWS), see \nSimpetus\n.", 
            "title": "About MPB"
        }, 
        {
            "location": "/MPB/#features", 
            "text": "Free software under the GNU General Public License. See the  License and Copyright .  Fully-vectorial, three-dimensional calculation. Iterative eigensolver techniques are employed to make large, three-dimensional calculations possible. Can also handle 2D and 1D problems.  Direct, frequency-domain eigensolver as opposed to indirect methods, e.g. time-domain. For one thing, this means that you get both eigenvalues (frequencies) and eigenstates (electromagnetic modes) at the same time. See a  comparison of time-domain and frequency-domain techniques .  Targeted eigensolver. Normally, iterative eigensolvers provide you with the states (optical bands/modes) with the lowest few frequencies. Our software can alternatively compute the modes whose frequencies are closest to a specified target frequency. This greatly reduces the number of bands that must be computed in guided or resonant mode calculations.  Flexible, scriptable user interface based on the  Guile  extension   scripting language.  Support for arbitrary, anisotropic dielectric structures including gyrotropic/magneto-optic materials and non-orthogonal unit cells.  Field output in  HDF5  format for input into many popular graphing and visualization tools.  Portable to most Unix-like operating systems. See the  installation guide .  Support for parallel machines with MPI.   To give you some feel for how long these calculations take, let us consider one typical data point. For the 3d band-structure of a  diamond lattice of dielectric spheres in air , computing the lowest 10 bands on a 16\u00d716\u00d716 grid at 31 k-points, MPB took 8 seconds on a 2.8 GHz AMD Opteron under Linux with the  ATLAS  optimized BLAS library. Thus, at each k-point, MPB was minimizing a function with 81920 degrees of freedom in 0.26 seconds on average.", 
            "title": "Features"
        }, 
        {
            "location": "/MPB/#mpb-download", 
            "text": "You can  download  the full source code in ANSI C for MPB under the  GPL . The  installation guide  describes how to install it; mainly, this consists of downloading and installing various prerequisites if you do not have them already.  The current version is  1.5 . See the  release notes  for what is new in each version.  You can also download the latest development sources from  MPB on Github .", 
            "title": "MPB Download"
        }, 
        {
            "location": "/MPB/#documentation", 
            "text": "This manual is readable online and is also part of the code repository. The  tutorials  demonstrate what it is like to use the program. You may be also interested in the  libctl manual , which describes a Guile/Scheme-based scripting library that we build our interface on top of, and also additional information on  Guile and Scheme .  We have published a paper on the computational methods underlying MPB:  Steven G. Johnson and J. D. Joannopoulos,  Block-iterative frequency-domain methods for Maxwell's equations in a planewave basis ,  Optics Express   8 , no. 3, 173-190 (2001).  See also our  referencing suggestions  for how to cite MPB in your work.", 
            "title": "Documentation"
        }, 
        {
            "location": "/MPB/#mailing-lists", 
            "text": "The MPB mailing lists and their archives are another source of information about MPB.  Subscribe to the read-only  mpb-announce mailing list  to receive notifications of updates and releases. Subscribe to the unmoderated  mpb-discuss mailing list  for discussions about using MPB. Archives are available  here . You can also read and post to the list via the  gmane.comp.science.photonic-bands  newsgroup from  Gmane .", 
            "title": "Mailing Lists"
        }, 
        {
            "location": "/MPB/#bug-reports-and-feature-requests", 
            "text": "For bug reports and feature requests, please  file an MPB Github issue .", 
            "title": "Bug Reports and Feature Requests"
        }, 
        {
            "location": "/MPB/#acknowledgements", 
            "text": "Many people and groups have contributed to the development of this software, both directly and indirectly. Please see the  acknowledgements section  of the manual for those to whom we feel especially grateful.", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/MPB/#contacts-and-feedback", 
            "text": "If you have questions or problems regarding MPB, you are encouraged to query the  mailing list .  For professional consulting as well as free access to MPB in the public cloud via Amazon Web Services (AWS), see  Simpetus .", 
            "title": "Contacts and Feedback"
        }, 
        {
            "location": "/Download/", 
            "text": "Download\n\n\n\n\nThe latest development sources are available on \nGitHub\n.\n\n\nThe latest release of MPB is \nversion 1.5\n which can be downloaded from:\n\n\n\n\nhttp://ab-initio.mit.edu/mpb/mpb-1.5.tar.gz\n\n\n\n\nOlder releases may be found at \nhttp://ab-initio.mit.edu/mpb/old\n\n\nMPB is free software under the \nGNU GPL\n.\n\n\nRefer to the \nRelease Notes\n to see what's new in this version, and be sure to read the \ninstallation guide\n for how to compile and install it.\n\n\nPlease subscribe to the \nmpb-announce\n mailing list to receive notifications when new versions are released:\n\n\n\n\nmpb-announce mailing list\n\n\n\n\nMPB on Amazon Web Services (AWS)\n\n\nThe latest version of Meep preinstalled on \nUbuntu\n can be accessed for free on Amazon Web Services (AWS) Elastic Compute Cloud (EC2) as an \nAmazon Machine Image (AMI)\n. Instructions for accessing this AMI are provided by \nSimpetus\n.\n\n\nPrecompiled MPB Packages for Debian and Ubuntu\n\n\nPrecompiled packages of MPB are available for \nDebian\n and \nUbuntu\n as \nmpb\n. The Debian package is available in the \ntesting\n repository. We highly recommend using Debian or Ubuntu, as in Debian or Ubuntu the Meep software and all of its dependencies can be installed using just one line:\n\n\nsudo apt-get install mpb h5utils\n\n\n\n\nYou can also install the \nparallel version of MPB\n which is based on \nMPICH\n using:\n\n\nsudo apt-get install mpb-mpi\n\n\n\n\nPython User Interface\n\n\nA Python user interface for Meep is currently under development by \nSimpetus\n.", 
            "title": "Download"
        }, 
        {
            "location": "/Download/#mpb-on-amazon-web-services-aws", 
            "text": "The latest version of Meep preinstalled on  Ubuntu  can be accessed for free on Amazon Web Services (AWS) Elastic Compute Cloud (EC2) as an  Amazon Machine Image (AMI) . Instructions for accessing this AMI are provided by  Simpetus .", 
            "title": "MPB on Amazon Web Services (AWS)"
        }, 
        {
            "location": "/Download/#precompiled-mpb-packages-for-debian-and-ubuntu", 
            "text": "Precompiled packages of MPB are available for  Debian  and  Ubuntu  as  mpb . The Debian package is available in the  testing  repository. We highly recommend using Debian or Ubuntu, as in Debian or Ubuntu the Meep software and all of its dependencies can be installed using just one line:  sudo apt-get install mpb h5utils  You can also install the  parallel version of MPB  which is based on  MPICH  using:  sudo apt-get install mpb-mpi", 
            "title": "Precompiled MPB Packages for Debian and Ubuntu"
        }, 
        {
            "location": "/Download/#python-user-interface", 
            "text": "A Python user interface for Meep is currently under development by  Simpetus .", 
            "title": "Python User Interface"
        }, 
        {
            "location": "/Release_Notes/", 
            "text": "Release Notes\n\n\n\n\nHere, we describe what has changed between releases of MPB. You can also refer to the \nNEWS\n file in the MPB package, or the \nChangeLog\n file for a more detailed listing.\n\n\nMPB 1.5\n\n\nApril 2, 2014\n\n\n\n\nMPB now also installs a library, for use from within \nMeep\n 1.2 or later.\n\n\nSupport Guile 2.x.\n\n\nSupport FFTW version 3.x in addition to FFTW 2.x. Version 3.3 or later is required for MPI parallelism.\n\n\nSupport for OpenMP parallelism.\n\n\nUse more accurate subpixel averaging algorithm for interfaces between anisotropic materials. See \nKottke et al, PRE 77, 036611, 2008\n.\n\n\nUse more accurate geometry routines in recent libctl versions which improves and speeds subpixel averaging.\n\n\nSupport using a different \nk\n origin in \nfind-k\n.\n\n\nAdded \nepsilon-func\n wrapper for \nmaterial-func\n (similar to Meep).\n\n\nAdded \ncompute-1-group-velocity\n to compute group velocity of a single band.\n\n\nAdded \nkinterpolate-uniform\n function, to interpolate with roughly uniform spacing in reciprocal space.\n\n\nAdded \noptimize-grid-size!\n function to round the grid size to a size that can be handled more efficiently. Only affects resolution, not lattice vectors.\n\n\nAllow user to set \nfilename-prefix\n to false to disable its use.\n\n\nAdded \nmpb-data -P \nangle\n option to change the phase angle of the output.\n\n\nAdded \ncompute-field-divergence\n and routines to get and output the bound charge density: \nget-charge-density\n and \noutput-charge-density\n.\n\n\nresolution\n is now an arbitrary real number, not just an integer, although of course MPB eventually computes an integer grid size.\n\n\nSupport HDF5 1.8.\n\n\nFix recurring \nnon positive-definite matrix in potrf\n errors that were arising due to roundoff errors preventing matrix inversion.\n\n\nFix \noutput-at-kpoint\n to avoid sensitivity to roundoff errors.\n\n\nBug fix in parallel HDF5 support: HDF5 compiled for parallel I/O (MPI) now works.\n\n\nBug fix in \nfield-map!\n, thanks to Karen Lee for the bug report.\n\n\nBug fix for \nfirst-brillouin-zone-k\n, thanks to Mischa Megens.\n\n\nBug fix: \nget-field\n and \ncompute-field-integral\n now use fields with the same phase as the outputted fields. Thanks to Jim West for the bug report.\n\n\nMiscellaneous bug fixes.\n\n\n\n\nMPB 1.4.2\n\n\nMarch 3, 2003\n\n\n\n\nInteractive prompt is now \nmpb\n not \nguile\n.\n\n\nOutput \nfreqs:\n line lists headings as \nk1,\n \nk2,\n \nk3\n instead of \nkx,\n \nky,\n \nkz\n since they are in reciprocal-lattice, not Cartesian, coordinates. Thanks to Theis Peter Hanson for the suggestion.\n\n\nBug fix in \nfind-k\n for non-orthogonal lattices; thanks to Suxia (Susan) Yang for tracking down this bug.\n\n\nFixed SunOS problem where k vectors along \nno-size\n dimensions failed; thanks to Benjamin Cowan for the bug report.\n\n\nFixed \nfind-k\n to work for \nband-min\n \n 1; thanks to M. Povinelli for the bug report.\n\n\nFixed \nfind-k\n to work for thunk band functions which take no arguments and are called only once instead of per-band.\n\n\n\n\nMPB 1.4.1\n\n\nSeptember 16, 2002\n\n\n\n\nFixed \nNaN\n in field normalization when basis determinant was negative. Thanks to Rumen Iliew for the bug report.\n\n\nFixed compatibility problems with versions of Guile prior to 1.4. Thanks to Cazimir G. Bostan for bug reports.\n\n\nDon't resize lattice basis for \ngrid-size\n=1 unless \nno-size\n was explicitly specified; thanks to Tairan Wang for the suggestion.\n\n\n\n\nMPB 1.4\n\n\nSeptember 12, 2002\n\n\n\n\nNew \nfind-k\n routine to find k as a function of frequency, instead of vice-versa.\n\n\nThe Great Field Renormalization: all fields are now normalized to have unit \nintegral\n of their energy density instead of unit sum over the grid points, which is much more useful e.g., for perturbation theory. See \nfield normalization\n in manual.\n\n\nYou can now save fields in Scheme variables to perform computations combining different fields. Example routines, e.g., to output the Poynting vector, are included.\n\n\nFunctions to export and import the raw eigenvectors (planewave amplitudes), as well as to compute dot products of eigenvectors from different k-points (e.g., for detecting band crossings).\n\n\nallow-negative-epsilon\n function to enable negative-dielectric support.\n\n\nAdded \nexamples/dos.scm\n to compute density of states via simple Gaussian histogram, suggested by Xavier Gonze and Doug Allan.\n\n\nBug fix: allow real offdiagonal epsilon elements without requiring \n--with-hermitian-eps\n. Thanks to Doug Allan for the bug report.\n\n\nEliminated floating-point error on Alpha for homogeneous structure. Thanks to F. Lopez-Tejeira for the bug report.\n\n\nAdded man page for \nmpb-split\n.\n\n\nMinor installation fixes.\n\n\n\n\nMPB 1.3\n\n\nMarch 10, 2002\n\n\n\n\nYou can now specify the grid size via the \nresolution\n input variable, instead of via \ngrid-size\n. In this case, you make e.g., a 2d simulation by creating a lattice with size \nno-size\n in one dimension. The old syntax is still supported, but the new style is encouraged. All examples have been updated to the new style.\n\n\nNew functions to retrieve fields, dielectric functions, etcetera at any point, interpolated from the grid if necessary; see the \nget-*-point\n functions in the \nmanual\n.\n\n\nNew \ncompute-field-integral\n function, analogous to \ncompute-energy-integral\n; thanks to Marin Soljacic for the suggestion.\n\n\nSupport Scheme complex numbers where appropriate (e.g., in \nepsilon-offdiag\n or in the new field integration functions).\n\n\nGot rid of \nNaN\n when computing the undefined group velocity for zero-frequency states at the Gamma point; arbitrarily return zero here instead. Thanks to Dmitry N. Chigrin for reporting floating-point exceptions on Alphas.\n\n\nFixed compilation failure for Fortran compilers that use all upper case; thanks to Steve Lantz of Cornell.\n\n\nAdded \"Fun with Fortran\" section to \nInstallation\n describing common Fortran pitfalls; thanks to Steve Lantz for the suggestion.\n\n\nImproved BLAS/LAPACK detection; new \n--with-blas\n and \n--with-lapack\n options to specify these libraries manually.\n\n\nShortened \n--with-hermitian-epsilon\n configure option to \n--with-hermitian-eps\n.\n\n\nThe data-analysis tutorial is now consistent with h5topng 1.7.\n\n\nUse new API from libctl 2.0.\n\n\n\n\nMPB 1.2.2\n\n\nDecember 7, 2001\n\n\n\n\nFixed bug that caused erroneous/failed convergence when \nEVEN-Y\n/\nODD-Y\n constraints were used in three dimensions. Thanks to Rumen Iliew for the bug report.\n\n\nAdded convenience functions \nrun-yeven\n, \nrun-yodd\n, \nrun-yeven-zeven\n, ...\n\n\n\n\nMPB 1.2.1\n\n\nNovember 20, 2001\n\n\n\n\nFixed serious crashing bug in 1.2; thanks to Karl Koch for the bug report.\n\n\n\n\nMPB 1.2\n\n\nNovember 15, 2001\n\n\n\n\nAdded new y-parity computation and constraints. See the new \nrun-parity\n function, which allows you to simultaneously specify the parity through the y=0 and z=0 planes, for symmetric structures. See also the \ndisplay-yparities\n function.\n\n\nz parity is no longer computed by default; see the new \ndisplay-yparities\n and \ndisplay-zparities\n functions to pass to \n(run)\n.\n\n\nReturn more-accurate average epsilon, fill factor, and scalar epsilon values (eigenfrequencies are not affected). Thanks to Mischa Megens for bugging me.\n\n\nNow outputs D and H in consistent units (previously, D and E were multiplied by a factor of -frequency). Thanks to Michelle Povinelli for worrying.\n\n\nepsilon.h5\n file now includes extra datasets for all components of the effective dielectric tensor. This feature is not yet supported if you \nconfigure\n \n--with-inv-symmetry\n \n--with-hermitian-epsilon\n.\n\n\nrun-polarization\n is replaced by \nrun-parity\n, and \nrun-even\n/\nrun-odd\n are deprecated in favor of \nrun-zeven\n/\nrun-zodd\n. \nrun-te\n/\nrun-tm\n are now equivalent to \nrun-zeven\n/\nrun-zodd\n when invoked for 3d systems.\n\n\nNoted new \nbasis-size\n property of \ngeometry-lattice\n, from libctl 1.5. This makes it easier to use conventional units in the fcc lattice.\n\n\nGroup-velocity computation no longer silently invalidates fields that have been loaded with \nget-dfield\n, etcetera. Thanks to Marin Soljacic for the bug report.\n\n\nThe configure script now checks that \nguile\n is in the \n$PATH\n. Thanks to Bing Li and Giridhar Malalahalli for their bug reports.\n\n\nRotated the W and K points of the diamond-lattice example so that they are oriented similarly to those in the \nPhotonic Crystals\n book by Joannopoulos \net al.\n (eigenfrequencies are not affected). Thanks to Robert Sheldon for pointing out that this was confusing.\n\n\nAdded \nhoney-rods.ctl\n example file: a 2d honeycomb lattice of rods.\n\n\nAdded \nline-defect.ctl\n example file: a line-defect waveguide in a 2d triangular lattice of dielectric rods, formed by a missing row of rods.\n\n\n\n\nMPB 1.1.1\n\n\nJuly 4, 2001\n\n\n\n\nFixed bug in H-field output that caused subtly incorrect H-field files only for 3d problems when NOT using \nmpbi\n.\n\n\nFixed bug that caused \nmpbi\n to output incorrect results for 1d problems (e.g. outputted dielectric functions with zeros).\n\n\nChanged default eigensolver tolerance from 1e-4 to 1e-7.\n\n\nAdded \nretrieve-gap\n convenience function to return the gap between two specified bands.\n\n\nFixed typo that prevented compilation of MPI (parallel) version.\n\n\nC compiler flags \n-O3\n are no longer used by default, since they don't work with some compilers; most of the performance depends upon the BLAS and FFTW anyway. Users wishing greater optimization can set the \nCFLAGS\n environment variable. Thanks to Giridhar Malalahalli for the bug report.\n\n\n\n\nMPB 1.1\n\n\nMay 6, 2001\n\n\n\n\nAdded \ncompute-energy-integral\n function to make it easier to compute arbitrary field-energy integrals for perturbation theory; thanks to Marin Soljacic for the suggestion.\n\n\nFixed bug in \noutput-field\n routines for the case of a nonzero k\nz\n component, that caused the fields to be multiplied by an exp(ikx) phase with a k in the wrong direction. Thanks to Jesper Riishede for the bug report.\n\n\n\n\nMPB 1.0\n\n\nFebruary 23, 2001\n\n\n\n\nAt long last, support for distributed-memory parallel machines with MPI. The computation time and memory usage can often improve nearly linearly with the number of processors. Thanks to Clarendon Photonics for funding this work.\n\n\nAlso added \nmpb-split\n script to parallelize in a simpler way, without MPI, on e.g. SMP machines, by dividing up the list of k-points among a number of serial mpb processes.\n\n\nFixed bug in \nmpbi\n where artifacts could be introduced in 3d field and dielectric-function output files. This only affected the output files, not the frequency eigenvalues, etcetera. Thanks to Michelle Povinelli for the bug report.\n\n\nAdded new \nmaterial-function\n material type, so that you can now specify that the dielectric tensor be an arbitrary function of position. Thanks to Peter Bermel for needing this.\n\n\nIf MPB is configured with the flag \n--with-hermitian-epsilon\n, then complex-hermitian dielectric tensors corresponding to magnetic materials, which break time-reversal symmetry are supported. Thanks to Shanhui Fan for pestering me about this.\n\n\nEliminated \noutput-copies\n input variable; if you want to visualize multiple unit cells, you should use \nmpb-data\n.\n\n\nAdded new \nnothing\n material that punches a hole through other objects to the background. This is distinct from \ndefault-material\n when \nepsilon-input-file\n is used, or for \ncompute-energy-in-objects\n.\n\n\nFixed inability of MPB 0.13 to run under an old version (1.2) of Guile.\n\n\nNow gives an error if k-point or dielectric tensor is incompatible with \nrun-te\n/\nrun-tm\n, or if the dielectric tensor is not positive-definite.\n\n\nDefault to vendor \ncc\n instead of \ngcc\n, so that C and Fortran compilers are in sync. We default to the vendor \nf77\n because it was probably used to compile LAPACK/BLAS, and Fortran libraries are picky.\n\n\nThe manual now cites our recent publication on the methods behind MPB.\n\n\nBug fix in \ncompute-energy-in-object-list\n for non-orthogonal lattices.\n\n\nBug fix in \ncombine-band-functions\n and other functions of band functions, which did not handle functions of no arguments (\"thunks\") correctly (crashing with an error message). Thanks to Michelle Povinelli for the bug report.\n\n\nFixed a floating-point sensitivity bug in \nmpb-data\n that could cause a crash on the Alpha; thanks to Dominique Caron for the bug report and debugging information.\n\n\n\n\nMPB 0.13\n\n\nJanuary 7, 2001\n\n\n\n\nCan now take advantage of \ninversion symmetry\n in the geometry, gaining at least a factor of two in speed and a factor of two in memory. To use this, you \nconfigure MPB\n with \n--with-inv-symmetry\n; the resulting executable is installed as \nmpbi\n and only supports inversion symmetry, so you will usually want to install the ordinary MPB as well.\n\n\nAdded new \neigensolver-block-size\n input variable, so that MPB can optionally solve for only a few bands at a time instead of all at once, reducing memory requirements and often increasing speed.\n\n\nImproved handling of the singular (zero-frequency) solutions at the Gamma (k=0) point. This k point should no longer converge slowly or cause additional problems in the targeted eigensolver.\n\n\nManual updates: please see expanded table of contents; we now use more conventional units in \ndiamond\n/fcc example.\n\n\nYou can now pass a \"thunk\" (function of no arguments) to \nrun\n, and it will be evaluated once per k-point instead of once per band per k-point as for ordinary band functions.\n\n\ncompute-field-energy\n function now also returns the fraction of the energy in the various field components. Thanks to Karl Koch for the suggestion.\n\n\nThe \nfilename-prefix\n variable is now read each time an output function is called, instead of once per \n(run)\n, so it can be changed frequently if desired. Thanks to Karl Koch for the suggestion.\n\n\nAdded \nfirst-brillouin-zone\n function to transform an arbitrary k-point into an equivalent point in the first Brillouin zone. Thanks to Payam Rabiei for the suggestion.\n\n\nIn \nmpb-data\n, the center of the output cell is now always identical to the origin of the coordinate system. Thanks to Michelle Povinelli for pointing out this deficiency.\n\n\nUsed improved spherical-quadrature formula in computing the effective dielectric tensor in 3d; this should increase accuracy somewhat at lower grid resolutions. Thanks to Doug Allan for helpful discussions.\n\n\n\n\nMPB 0.12\n\n\nJuly 9, 2000\n\n\n\n\nAdded \nfix-*field-phase\n functions to allow a deterministic phase in the output fields, thanks to a suggestion by Doug Allan.\n\n\nAdded group-velocity calculation functions (\ndisplay-group-velocities\n, etcetera).\n\n\nAdded \n-e x,y,z\n option to \nmpb-data\n so that you can now specify an orientation of the output cell (e.g., to make the first axis the 111 direction of an fcc crystal).\n\n\nAdded \n(index\n \nn)\n substitute for \nepsilon\n property of dielectrics, equivalent to \n(epsilon\n \n(*\n \nn\n \nn))\n.\n\n\nDocumented new libgeom features: \ncone\n geometric object, coordinate conversion functions (\nreciprocal-\nlattice\n, \nlattice-\ncartesian\n, etc.), and vector/matrix rotation.\n\n\ncompute-field-energy\n now returns the total, unnormalized energy in the corresponding field; combined with \ncompute-energy-in-objects\n, this makes it easy to do some perturbation theory and related calculations.\n\n\nEigensolver improvements. Periodic reorthogonalization and renormalization to combat some numerical problems. New line-minimization code, included with permission from \nMINPACK-2\n by \nJorge J. Mor\u00e9\n.\n\n\nFixed breaking of 90-degree rotational symmetry-breaking by the mesh in 2d; thanks to Jim West and Doug Allan of Corning for the bug report. In general, some symmetry-breaking by the discretization seems hard to avoid, however.\n\n\nFixed bug in field output routines that could cause crashes for grid sizes not a multiple of 4.\n\n\nBug fix in dielectric function construction for 2d systems: we now use the xy plane at z=0 as documented, instead of z=-0.5.\n\n\n\n\nMPB 0.11\n\n\nFebruary 12, 2000\n\n\n\n\nconfigure\n script can now detect and link \nATLAS\n 3.0 accelerated BLAS.\n\n\nAdded \nband-range-data\n output variable.\n\n\nRunning \nmpb-data\n multiple times on the same file now replaces the results of the previous run, instead of appending \n-new2\n, \n-new3\n, etcetera.\n\n\nFixed bug in \nrun-even\n/\nrun-odd\n that could seriously slow or even prevent eigensolver convergence. Thanks to Payam Rabiei for the bug report.\n\n\nFixed compilation \n--without-hdf5\n, or when HDF5 is not found. Thanks to Rajesh Rengarajan for the bug report.\n\n\n\n\nMPB 0.10\n\n\nJanuary 28, 2000\n\n\n\n\nAdded \nmpb-data\n utility for post-processing data (e.g., for unskewing non-orthogonal lattices). See the new data-analysis tutorial or \nman mpb-data\n for more information.\n\n\nAdded new data-analysis tutorial to the manual, describing how to analyze and visualize the results of two sample calculations.\n\n\nAdded support for a new material type, \ndielectric-anisotropic\n, so that you can specify arbitrary real/symmetric dielectric tensors.\n\n\nAdded new \noutput-at-kpoint\n function to make it easier to output fields only at a single k-point in a band-structure calculation.\n\n\nWhen outputting fields, output all field components (x, y, z, and real and imaginary parts) to a single HDF5 file. Also include info on the lattice and k-point vectors to facilitate post-processing.\n\n\nAdded new subsection to the installation manual describing some generic installation path issues on Unix that were confusing people.\n\n\nUse \nCPPFLAGS\n environment variable instead of the less-standard \nINCLUDES\n to pass \n-I\n flags to the configure script for header files in non-standard locations.\n\n\nAdded \ndiamond.ctl\n example file for a 3d diamond (fcc) lattice of spheres.\n\n\nAdded brief mpb \nman\n page.\n\n\nFixed z-parity output and \nrun-even\n/\nodd\n functions for 2d grids.\n\n\nFixed bug in \noutput-dpwr-in-objects\n. Thanks to Mihai Ibanescu for the bug report.\n\n\nCompilation fixes. We need to set \nSHELL\n in the \nMakefile\n for \nmake\n on some systems. Also added rule to insure \nctl-io.h\n is created before \nmain.c\n is compiled. Thanks to Christoph Becher for the bug reports.\n\n\n\n\nMPB 0.9.1\n\n\nJanuary 7, 2000\n\n\n\n\nFixed eigensolver bug where special handling of Gamma (k=0) point could screw up convergence for subsequent k-points, causing incorrect results.\n\n\nFixed behavior of \nfilename-prefix\n input variable; thanks to Karl Koch for the bug report\n\n\n\n\nMPB 0.9\n\n\nJanuary 2, 2000\n\n\n\n\nAdded \nrun-even\n and \nrun-odd\n functions, so you can now compute only even/odd states with respect to a z=0 mirror plane in systems with sufficient symmetry. See also the new \nz-parity\n output variable.\n\n\nAdded \nepsilon-input-file\n variable, so that you can now read an arbitrary dielectric function from a file.\n\n\nField file names now include the polarization (e.g. \n.tm\n).\n\n\nSome optimizations in the eigensolver.\n\n\nSome documentation improvements; thanks to Edmond Chow for his comments.\n\n\nconfigure\n should work even when there is no Fortran compiler on your system assuming your BLAS, etc., libraries work without Fortran libs. Thanks to Antti Renko for the bug report.\n\n\nFixed problems detecting BLAS and LAPACK shared libraries in \nconfigure\n. Thanks to Karri Varris for the bug report.\n\n\nFixed trailing spaces in \nsed\n command, which were breaking \nmake install\n on some systems. Thanks to Ron Chase for the bug report.\n\n\n\n\nMPB 0.8.1\n\n\nNovember 22, 1999\n\n\n\n\nAdded \noutput-hfield-x\n, \noutput-dfield-y\n, etcetera, functions for outputting only specific field components.\n\n\nSped up HDF5 field output routines.\n\n\nAdded \noutput-copies\n variable to set the number of periods output by the band output functions.\n\n\n\n\nMPB 0.8\n\n\nNovember 19, 1999\n\n\n\n\nInitial public release.", 
            "title": "Release Notes"
        }, 
        {
            "location": "/Release_Notes/#mpb-15", 
            "text": "April 2, 2014   MPB now also installs a library, for use from within  Meep  1.2 or later.  Support Guile 2.x.  Support FFTW version 3.x in addition to FFTW 2.x. Version 3.3 or later is required for MPI parallelism.  Support for OpenMP parallelism.  Use more accurate subpixel averaging algorithm for interfaces between anisotropic materials. See  Kottke et al, PRE 77, 036611, 2008 .  Use more accurate geometry routines in recent libctl versions which improves and speeds subpixel averaging.  Support using a different  k  origin in  find-k .  Added  epsilon-func  wrapper for  material-func  (similar to Meep).  Added  compute-1-group-velocity  to compute group velocity of a single band.  Added  kinterpolate-uniform  function, to interpolate with roughly uniform spacing in reciprocal space.  Added  optimize-grid-size!  function to round the grid size to a size that can be handled more efficiently. Only affects resolution, not lattice vectors.  Allow user to set  filename-prefix  to false to disable its use.  Added  mpb-data -P  angle  option to change the phase angle of the output.  Added  compute-field-divergence  and routines to get and output the bound charge density:  get-charge-density  and  output-charge-density .  resolution  is now an arbitrary real number, not just an integer, although of course MPB eventually computes an integer grid size.  Support HDF5 1.8.  Fix recurring  non positive-definite matrix in potrf  errors that were arising due to roundoff errors preventing matrix inversion.  Fix  output-at-kpoint  to avoid sensitivity to roundoff errors.  Bug fix in parallel HDF5 support: HDF5 compiled for parallel I/O (MPI) now works.  Bug fix in  field-map! , thanks to Karen Lee for the bug report.  Bug fix for  first-brillouin-zone-k , thanks to Mischa Megens.  Bug fix:  get-field  and  compute-field-integral  now use fields with the same phase as the outputted fields. Thanks to Jim West for the bug report.  Miscellaneous bug fixes.", 
            "title": "MPB 1.5"
        }, 
        {
            "location": "/Release_Notes/#mpb-142", 
            "text": "March 3, 2003   Interactive prompt is now  mpb  not  guile .  Output  freqs:  line lists headings as  k1,   k2,   k3  instead of  kx,   ky,   kz  since they are in reciprocal-lattice, not Cartesian, coordinates. Thanks to Theis Peter Hanson for the suggestion.  Bug fix in  find-k  for non-orthogonal lattices; thanks to Suxia (Susan) Yang for tracking down this bug.  Fixed SunOS problem where k vectors along  no-size  dimensions failed; thanks to Benjamin Cowan for the bug report.  Fixed  find-k  to work for  band-min    1; thanks to M. Povinelli for the bug report.  Fixed  find-k  to work for thunk band functions which take no arguments and are called only once instead of per-band.", 
            "title": "MPB 1.4.2"
        }, 
        {
            "location": "/Release_Notes/#mpb-141", 
            "text": "September 16, 2002   Fixed  NaN  in field normalization when basis determinant was negative. Thanks to Rumen Iliew for the bug report.  Fixed compatibility problems with versions of Guile prior to 1.4. Thanks to Cazimir G. Bostan for bug reports.  Don't resize lattice basis for  grid-size =1 unless  no-size  was explicitly specified; thanks to Tairan Wang for the suggestion.", 
            "title": "MPB 1.4.1"
        }, 
        {
            "location": "/Release_Notes/#mpb-14", 
            "text": "September 12, 2002   New  find-k  routine to find k as a function of frequency, instead of vice-versa.  The Great Field Renormalization: all fields are now normalized to have unit  integral  of their energy density instead of unit sum over the grid points, which is much more useful e.g., for perturbation theory. See  field normalization  in manual.  You can now save fields in Scheme variables to perform computations combining different fields. Example routines, e.g., to output the Poynting vector, are included.  Functions to export and import the raw eigenvectors (planewave amplitudes), as well as to compute dot products of eigenvectors from different k-points (e.g., for detecting band crossings).  allow-negative-epsilon  function to enable negative-dielectric support.  Added  examples/dos.scm  to compute density of states via simple Gaussian histogram, suggested by Xavier Gonze and Doug Allan.  Bug fix: allow real offdiagonal epsilon elements without requiring  --with-hermitian-eps . Thanks to Doug Allan for the bug report.  Eliminated floating-point error on Alpha for homogeneous structure. Thanks to F. Lopez-Tejeira for the bug report.  Added man page for  mpb-split .  Minor installation fixes.", 
            "title": "MPB 1.4"
        }, 
        {
            "location": "/Release_Notes/#mpb-13", 
            "text": "March 10, 2002   You can now specify the grid size via the  resolution  input variable, instead of via  grid-size . In this case, you make e.g., a 2d simulation by creating a lattice with size  no-size  in one dimension. The old syntax is still supported, but the new style is encouraged. All examples have been updated to the new style.  New functions to retrieve fields, dielectric functions, etcetera at any point, interpolated from the grid if necessary; see the  get-*-point  functions in the  manual .  New  compute-field-integral  function, analogous to  compute-energy-integral ; thanks to Marin Soljacic for the suggestion.  Support Scheme complex numbers where appropriate (e.g., in  epsilon-offdiag  or in the new field integration functions).  Got rid of  NaN  when computing the undefined group velocity for zero-frequency states at the Gamma point; arbitrarily return zero here instead. Thanks to Dmitry N. Chigrin for reporting floating-point exceptions on Alphas.  Fixed compilation failure for Fortran compilers that use all upper case; thanks to Steve Lantz of Cornell.  Added \"Fun with Fortran\" section to  Installation  describing common Fortran pitfalls; thanks to Steve Lantz for the suggestion.  Improved BLAS/LAPACK detection; new  --with-blas  and  --with-lapack  options to specify these libraries manually.  Shortened  --with-hermitian-epsilon  configure option to  --with-hermitian-eps .  The data-analysis tutorial is now consistent with h5topng 1.7.  Use new API from libctl 2.0.", 
            "title": "MPB 1.3"
        }, 
        {
            "location": "/Release_Notes/#mpb-122", 
            "text": "December 7, 2001   Fixed bug that caused erroneous/failed convergence when  EVEN-Y / ODD-Y  constraints were used in three dimensions. Thanks to Rumen Iliew for the bug report.  Added convenience functions  run-yeven ,  run-yodd ,  run-yeven-zeven , ...", 
            "title": "MPB 1.2.2"
        }, 
        {
            "location": "/Release_Notes/#mpb-121", 
            "text": "November 20, 2001   Fixed serious crashing bug in 1.2; thanks to Karl Koch for the bug report.", 
            "title": "MPB 1.2.1"
        }, 
        {
            "location": "/Release_Notes/#mpb-12", 
            "text": "November 15, 2001   Added new y-parity computation and constraints. See the new  run-parity  function, which allows you to simultaneously specify the parity through the y=0 and z=0 planes, for symmetric structures. See also the  display-yparities  function.  z parity is no longer computed by default; see the new  display-yparities  and  display-zparities  functions to pass to  (run) .  Return more-accurate average epsilon, fill factor, and scalar epsilon values (eigenfrequencies are not affected). Thanks to Mischa Megens for bugging me.  Now outputs D and H in consistent units (previously, D and E were multiplied by a factor of -frequency). Thanks to Michelle Povinelli for worrying.  epsilon.h5  file now includes extra datasets for all components of the effective dielectric tensor. This feature is not yet supported if you  configure   --with-inv-symmetry   --with-hermitian-epsilon .  run-polarization  is replaced by  run-parity , and  run-even / run-odd  are deprecated in favor of  run-zeven / run-zodd .  run-te / run-tm  are now equivalent to  run-zeven / run-zodd  when invoked for 3d systems.  Noted new  basis-size  property of  geometry-lattice , from libctl 1.5. This makes it easier to use conventional units in the fcc lattice.  Group-velocity computation no longer silently invalidates fields that have been loaded with  get-dfield , etcetera. Thanks to Marin Soljacic for the bug report.  The configure script now checks that  guile  is in the  $PATH . Thanks to Bing Li and Giridhar Malalahalli for their bug reports.  Rotated the W and K points of the diamond-lattice example so that they are oriented similarly to those in the  Photonic Crystals  book by Joannopoulos  et al.  (eigenfrequencies are not affected). Thanks to Robert Sheldon for pointing out that this was confusing.  Added  honey-rods.ctl  example file: a 2d honeycomb lattice of rods.  Added  line-defect.ctl  example file: a line-defect waveguide in a 2d triangular lattice of dielectric rods, formed by a missing row of rods.", 
            "title": "MPB 1.2"
        }, 
        {
            "location": "/Release_Notes/#mpb-111", 
            "text": "July 4, 2001   Fixed bug in H-field output that caused subtly incorrect H-field files only for 3d problems when NOT using  mpbi .  Fixed bug that caused  mpbi  to output incorrect results for 1d problems (e.g. outputted dielectric functions with zeros).  Changed default eigensolver tolerance from 1e-4 to 1e-7.  Added  retrieve-gap  convenience function to return the gap between two specified bands.  Fixed typo that prevented compilation of MPI (parallel) version.  C compiler flags  -O3  are no longer used by default, since they don't work with some compilers; most of the performance depends upon the BLAS and FFTW anyway. Users wishing greater optimization can set the  CFLAGS  environment variable. Thanks to Giridhar Malalahalli for the bug report.", 
            "title": "MPB 1.1.1"
        }, 
        {
            "location": "/Release_Notes/#mpb-11", 
            "text": "May 6, 2001   Added  compute-energy-integral  function to make it easier to compute arbitrary field-energy integrals for perturbation theory; thanks to Marin Soljacic for the suggestion.  Fixed bug in  output-field  routines for the case of a nonzero k z  component, that caused the fields to be multiplied by an exp(ikx) phase with a k in the wrong direction. Thanks to Jesper Riishede for the bug report.", 
            "title": "MPB 1.1"
        }, 
        {
            "location": "/Release_Notes/#mpb-10", 
            "text": "February 23, 2001   At long last, support for distributed-memory parallel machines with MPI. The computation time and memory usage can often improve nearly linearly with the number of processors. Thanks to Clarendon Photonics for funding this work.  Also added  mpb-split  script to parallelize in a simpler way, without MPI, on e.g. SMP machines, by dividing up the list of k-points among a number of serial mpb processes.  Fixed bug in  mpbi  where artifacts could be introduced in 3d field and dielectric-function output files. This only affected the output files, not the frequency eigenvalues, etcetera. Thanks to Michelle Povinelli for the bug report.  Added new  material-function  material type, so that you can now specify that the dielectric tensor be an arbitrary function of position. Thanks to Peter Bermel for needing this.  If MPB is configured with the flag  --with-hermitian-epsilon , then complex-hermitian dielectric tensors corresponding to magnetic materials, which break time-reversal symmetry are supported. Thanks to Shanhui Fan for pestering me about this.  Eliminated  output-copies  input variable; if you want to visualize multiple unit cells, you should use  mpb-data .  Added new  nothing  material that punches a hole through other objects to the background. This is distinct from  default-material  when  epsilon-input-file  is used, or for  compute-energy-in-objects .  Fixed inability of MPB 0.13 to run under an old version (1.2) of Guile.  Now gives an error if k-point or dielectric tensor is incompatible with  run-te / run-tm , or if the dielectric tensor is not positive-definite.  Default to vendor  cc  instead of  gcc , so that C and Fortran compilers are in sync. We default to the vendor  f77  because it was probably used to compile LAPACK/BLAS, and Fortran libraries are picky.  The manual now cites our recent publication on the methods behind MPB.  Bug fix in  compute-energy-in-object-list  for non-orthogonal lattices.  Bug fix in  combine-band-functions  and other functions of band functions, which did not handle functions of no arguments (\"thunks\") correctly (crashing with an error message). Thanks to Michelle Povinelli for the bug report.  Fixed a floating-point sensitivity bug in  mpb-data  that could cause a crash on the Alpha; thanks to Dominique Caron for the bug report and debugging information.", 
            "title": "MPB 1.0"
        }, 
        {
            "location": "/Release_Notes/#mpb-013", 
            "text": "January 7, 2001   Can now take advantage of  inversion symmetry  in the geometry, gaining at least a factor of two in speed and a factor of two in memory. To use this, you  configure MPB  with  --with-inv-symmetry ; the resulting executable is installed as  mpbi  and only supports inversion symmetry, so you will usually want to install the ordinary MPB as well.  Added new  eigensolver-block-size  input variable, so that MPB can optionally solve for only a few bands at a time instead of all at once, reducing memory requirements and often increasing speed.  Improved handling of the singular (zero-frequency) solutions at the Gamma (k=0) point. This k point should no longer converge slowly or cause additional problems in the targeted eigensolver.  Manual updates: please see expanded table of contents; we now use more conventional units in  diamond /fcc example.  You can now pass a \"thunk\" (function of no arguments) to  run , and it will be evaluated once per k-point instead of once per band per k-point as for ordinary band functions.  compute-field-energy  function now also returns the fraction of the energy in the various field components. Thanks to Karl Koch for the suggestion.  The  filename-prefix  variable is now read each time an output function is called, instead of once per  (run) , so it can be changed frequently if desired. Thanks to Karl Koch for the suggestion.  Added  first-brillouin-zone  function to transform an arbitrary k-point into an equivalent point in the first Brillouin zone. Thanks to Payam Rabiei for the suggestion.  In  mpb-data , the center of the output cell is now always identical to the origin of the coordinate system. Thanks to Michelle Povinelli for pointing out this deficiency.  Used improved spherical-quadrature formula in computing the effective dielectric tensor in 3d; this should increase accuracy somewhat at lower grid resolutions. Thanks to Doug Allan for helpful discussions.", 
            "title": "MPB 0.13"
        }, 
        {
            "location": "/Release_Notes/#mpb-012", 
            "text": "July 9, 2000   Added  fix-*field-phase  functions to allow a deterministic phase in the output fields, thanks to a suggestion by Doug Allan.  Added group-velocity calculation functions ( display-group-velocities , etcetera).  Added  -e x,y,z  option to  mpb-data  so that you can now specify an orientation of the output cell (e.g., to make the first axis the 111 direction of an fcc crystal).  Added  (index   n)  substitute for  epsilon  property of dielectrics, equivalent to  (epsilon   (*   n   n)) .  Documented new libgeom features:  cone  geometric object, coordinate conversion functions ( reciprocal- lattice ,  lattice- cartesian , etc.), and vector/matrix rotation.  compute-field-energy  now returns the total, unnormalized energy in the corresponding field; combined with  compute-energy-in-objects , this makes it easy to do some perturbation theory and related calculations.  Eigensolver improvements. Periodic reorthogonalization and renormalization to combat some numerical problems. New line-minimization code, included with permission from  MINPACK-2  by  Jorge J. Mor\u00e9 .  Fixed breaking of 90-degree rotational symmetry-breaking by the mesh in 2d; thanks to Jim West and Doug Allan of Corning for the bug report. In general, some symmetry-breaking by the discretization seems hard to avoid, however.  Fixed bug in field output routines that could cause crashes for grid sizes not a multiple of 4.  Bug fix in dielectric function construction for 2d systems: we now use the xy plane at z=0 as documented, instead of z=-0.5.", 
            "title": "MPB 0.12"
        }, 
        {
            "location": "/Release_Notes/#mpb-011", 
            "text": "February 12, 2000   configure  script can now detect and link  ATLAS  3.0 accelerated BLAS.  Added  band-range-data  output variable.  Running  mpb-data  multiple times on the same file now replaces the results of the previous run, instead of appending  -new2 ,  -new3 , etcetera.  Fixed bug in  run-even / run-odd  that could seriously slow or even prevent eigensolver convergence. Thanks to Payam Rabiei for the bug report.  Fixed compilation  --without-hdf5 , or when HDF5 is not found. Thanks to Rajesh Rengarajan for the bug report.", 
            "title": "MPB 0.11"
        }, 
        {
            "location": "/Release_Notes/#mpb-010", 
            "text": "January 28, 2000   Added  mpb-data  utility for post-processing data (e.g., for unskewing non-orthogonal lattices). See the new data-analysis tutorial or  man mpb-data  for more information.  Added new data-analysis tutorial to the manual, describing how to analyze and visualize the results of two sample calculations.  Added support for a new material type,  dielectric-anisotropic , so that you can specify arbitrary real/symmetric dielectric tensors.  Added new  output-at-kpoint  function to make it easier to output fields only at a single k-point in a band-structure calculation.  When outputting fields, output all field components (x, y, z, and real and imaginary parts) to a single HDF5 file. Also include info on the lattice and k-point vectors to facilitate post-processing.  Added new subsection to the installation manual describing some generic installation path issues on Unix that were confusing people.  Use  CPPFLAGS  environment variable instead of the less-standard  INCLUDES  to pass  -I  flags to the configure script for header files in non-standard locations.  Added  diamond.ctl  example file for a 3d diamond (fcc) lattice of spheres.  Added brief mpb  man  page.  Fixed z-parity output and  run-even / odd  functions for 2d grids.  Fixed bug in  output-dpwr-in-objects . Thanks to Mihai Ibanescu for the bug report.  Compilation fixes. We need to set  SHELL  in the  Makefile  for  make  on some systems. Also added rule to insure  ctl-io.h  is created before  main.c  is compiled. Thanks to Christoph Becher for the bug reports.", 
            "title": "MPB 0.10"
        }, 
        {
            "location": "/Release_Notes/#mpb-091", 
            "text": "January 7, 2000   Fixed eigensolver bug where special handling of Gamma (k=0) point could screw up convergence for subsequent k-points, causing incorrect results.  Fixed behavior of  filename-prefix  input variable; thanks to Karl Koch for the bug report", 
            "title": "MPB 0.9.1"
        }, 
        {
            "location": "/Release_Notes/#mpb-09", 
            "text": "January 2, 2000   Added  run-even  and  run-odd  functions, so you can now compute only even/odd states with respect to a z=0 mirror plane in systems with sufficient symmetry. See also the new  z-parity  output variable.  Added  epsilon-input-file  variable, so that you can now read an arbitrary dielectric function from a file.  Field file names now include the polarization (e.g.  .tm ).  Some optimizations in the eigensolver.  Some documentation improvements; thanks to Edmond Chow for his comments.  configure  should work even when there is no Fortran compiler on your system assuming your BLAS, etc., libraries work without Fortran libs. Thanks to Antti Renko for the bug report.  Fixed problems detecting BLAS and LAPACK shared libraries in  configure . Thanks to Karri Varris for the bug report.  Fixed trailing spaces in  sed  command, which were breaking  make install  on some systems. Thanks to Ron Chase for the bug report.", 
            "title": "MPB 0.9"
        }, 
        {
            "location": "/Release_Notes/#mpb-081", 
            "text": "November 22, 1999   Added  output-hfield-x ,  output-dfield-y , etcetera, functions for outputting only specific field components.  Sped up HDF5 field output routines.  Added  output-copies  variable to set the number of periods output by the band output functions.", 
            "title": "MPB 0.8.1"
        }, 
        {
            "location": "/Release_Notes/#mpb-08", 
            "text": "November 19, 1999   Initial public release.", 
            "title": "MPB 0.8"
        }, 
        {
            "location": "/Introduction/", 
            "text": "Introduction\n\n\n\n\nMIT Photonic Bands\n is a software package to compute definite-frequency eigenstates of Maxwell's equations in periodic dielectric structures. Its primary intended application is the study of \nphotonic crystals\n: periodic dielectric structures exhibiting a band gap in their optical modes, prohibiting propagation of light in that frequency range. However, it could also be easily applied to compute other optical dispersion relations and eigenstates (e.g., for strips waveguides and optical fibers).\n\n\nThis manual assumes that the reader is familiar with concepts from solid-state physics such as eigenstates, band structures, and Bloch's theorem. We also do not attempt to instruct the reader on photonic crystals or other optical applications for which this code might be useful. For an excellent introduction to all of these topics in the context of photonic crystals, see the book \nPhotonic Crystals: Molding the Flow of Light\n, by J. D. Joannopoulos, S. G. Johnson, R. D. Meade, and J. N. Winn (Princeton, 2008).\n\n\nSome of the main design goals we were thinking about when we developed this package were the following. See also the \nfeature list\n at the MPB home page.\n\n\n\n\nFully vectorial, three-dimensional calculations for arbitrary Bloch wavevectors. The only approximation is the spatial discretization, or equivalently the planewave cutoff.\n\n\nFlexible interface. Readable, extensible, scriptable. See also the \nlibctl design goals\n.\n\n\nParallel. Can run on a single-processor machine, but also supports parallel machines with MPI.\n\n\n\"Targeted\" eigensolver: find modes nearest to a specified frequency, not just the lowest-frequency bands. Used for defect calculations.\n\n\nLeverage existing software (LAPACK, BLAS, FFTW, HDF, MPI, GUILE).\n\n\nModularity. The eigensolver, Maxwell's equations, user interface, and so on, should be oblivious to each other as much as possible. This way, they can be debugged separately, combined in various ways, replaced, used in other programs; all the usual benefits of modular design.\n\n\nTake advantage of inversion symmetry in the dielectric function, but don't require it. This means that we have to handle both real and complex fields.\n\n\n\n\nFrequency-Domain vs. Time-Domain\n\n\nThere are two common computational electromagnetic approaches to studying dielectric structures: frequency-domain and time-domain. We feel that each has its own place in a researcher's toolbox, and each has unique advantages and disadvantages. For a more detailed discussion, see \nour online textbook\n, appendix D. \nMPB is frequency-domain\n. That is, it does a direct computation of the eigenstates and eigenvalues of Maxwell's equations using a planewave basis. Each field computed has a definite frequency. In contrast, time-domain techniques as in our \nMeep\n software iterate Maxwell's equations in time; the computed fields have a definite time at each time step but not a definite frequency \nper se\n. It seems worthwhile to say a few words about each method, and to explain why we want a frequency-domain code.\n\n\nTime-domain methods are well-suited to computing things that involve evolution of the fields, such as transmission and resonance decay-time calculations. They can also be used to calculate band structures and for finding resonant modes, by looking for peaks in the Fourier transform of the system response to some input. The main advantage of this is that you get all the spectral peaks at once from a single calculation. There are several disadvantages to this technique, however. First, it is hard to be confident that you have found all of the states\u2014you may have coupled weakly to some state by accident, or two states may be close in frequency and appear as a single peak. This is especially problematic in higher-order resonant-cavity and waveguide calculations. Second, in the Fourier transform, the frequency resolution is inversely related to the simulation time. To get 10 times the resolution you must run your simulation 10 times as long although matters are improved by using more sophisticated signal-processing methods such as \nHarminv\n. Third, the time-step size must be proportional to the spatial-grid size for numerical stability. Thus, if you double the spatial resolution, you must double the number of time steps (the length of your simulation), even if you are looking at states with the same frequency as before. Fourth, you only get the frequencies of the states. To get the eigenstates themselves so that you can see what the modes look like and do calculations with them, you must run the simulation again, once for each state that you want, and for a time inversely proportional to the frequency-spacing between adjacent states (i.e. a long time for closely-spaced states).\n\n\nIn contrast, frequency-domain methods like those in MPB are in many ways better-suited to calculating band structures and eigenstates. Here, we consider the case of an \niterative\n eigensolver like the one in MPB, which iteratively improves approximate eigenstates. Dense solvers, which factorize the matrix directly, are impractical for large problems because of the huge size of the matrix, and because they compute many more eigenvectors than are desired. In iterative methods, the operator is only applied to individual vectors and is never itself computed explicitly. First, you don't have to worry about missing states\u2014even closely-spaced modes will appear as two eigenvalues in the result. Second, the error in the frequency in an iterative eigensolver typically decays exponentially with the number of iterations, so the number of iterations is logarithmic in the desired tolerance. Third, the number of iterations typically remains almost constant even as you increase the resolution. The work for each iteration increases, of course, but that happens in time-domain too. Fourth, you get both the frequencies and the eigenstates at the same time, so you can look at the modes immediately, even closely-spaced ones.\n\n\nA traditional disadvantage of frequency-domain methods was that you had to compute all of the lowest eigenstates, up to the desired one, even if you didn't care about the lower ones. This was especially problematic in defect calculations, in which a large supercell is used, because in that case the lower bands are \"folded\" many times in the Brillouin zone. Thus, you often had to compute a large number of bands in order to get to the one you wanted incurring large costs both in time and in storage. These disadvantages disappear to some degree in MPB, however, with the advent of its \"targeted\" eigensolver\u2014with it, you can solve directly for the localized defect states (i.e the states in the band gap) without computing the lower bands. However, the targeted eigensolver method used in MPB still has poor convergence, so time-domain methods such as \nMeep\n still have an advantage here.\n\n\nHistory\n\n\nIn order to shed some light on the past development and design decisions of MPB, I thought I'd write a few paragraphs about its history. Read on to enjoy my narcissistic ramblings.\n\n\nMany different people have written codes to compute the modes of periodic dielectric materials although we don't know of any others that have been freely released. I have had experience with several programs written within our research group, and this experience has guided the design of MPB.\n\n\nThe first program of this sort that I came in contact with, and the code that was used in our group until the development of this package, was initially written around 1990 (in Fortran 77) by R. D. Meade. As this software grew organically over time, several problems became apparent. First, the input format was inflexible (difficult to add new features without breaking old simulations), sensitive to whitespace and other formatting, and required repeated entry of information that was often the same from file to file. Often, pre- and post-processing steps were required using additional scripts and tools. Second, the many parts of the program had become intertwined, lacking modularity or a clear flow of control; this made it difficult to follow or modify substantially. Parallelizing it, or removing constraints that it imposed like inversion symmetry, or even replacing the input format seemed impractical. Besides, even reading code with variables named \ngxgzco\n (in common block \ncabgv\n) (honest!) is a mind-altering experience.\n\n\nAfter an initial experience in the Spring of 1996 at writing a code based on a wavelet, rather than a planewave, basis which turned out not to be practical, I set out to write a replacement for our Fortran eigensolver. My main aims at this time (Fall 1996) were a more flexible and powerful input format and a code that would be amenable to parallelization. I succeeded in achieving a working code with similar convergence to the old code (after \nsome pain\n), but I discovered several things. I had lots of fun learning to use \nlex\n and \nyacc\n (Yet Another Compiler-Compiler) to make a flexible, C-like input format with variables and other advanced features. Having input files that were almost, but not quite, like a programming language made me realize, however, that what I really wanted \nwas\n a programming language--no matter how many features I added, I always wanted one more \"simple\" thing. As far as parallelization, I quickly realized that I had a problem: I needed a parallel FFT, and the only ones that were available were proprietary (non-portable), used incompatible data distribution formats, and were often designed to be called only from special languages like HPF. That, plus my dissatisfaction with the available free FFTs, led me to embark on a side project (with my friend Matteo Frigo, then of MIT's Laboratory for Computer Science) to develop a new, free FFT library, \nFFTW\n, that included portable parallel routines. Also, I decided that attempting to support too many models of parallel programming (threads, MPI, Cray \nshmem\n) in one program resulted in a mess; it was better to stick with MPI (supporting running only a single process too, of course). Another mistake I discovered was that I allowed the eigensolver to get too intertwined with the specific problem of Maxwell's equations--the eigensolver knew about the data structures for the fields, etcetera, making it difficult to plug in replacement eigensolvers, test things in isolation, or to implement features like the \"targeted\" eigensolver of MPB which diagonalizes a different operator. The whole program was too mired in complexity. Finally, in the interim I had learned about block eigensolver algorithms. Not only can such algorithms leverage prepackaged, highly-optimized routines like BLAS and LAPACK, but they also promised to be inherently more suited for parallelization since they remove the serial process of solving for the bands one by one. All of these things convinced me that I needed to rewrite the code again from scratch.\n\n\nSo, I started work on the new package (in Spring 1998), this time determined to develop and debug each component (matrix operations, eigensolver, maxwell operator, user input) in isolation. At the same time, I was thinking about how I would implement the user control language, wanting to develop a general tool that could be applied to other problems and software in our research. It seemed clear that, in order to get other people to use it in their programs, as well as to avoid a lot of the manual labor that went into my previous effort, I wanted to automatically generate the user/program interface from an abstract specification. As for the control language, I briefly considered implementing my own, but was happily led to GNU Guile instead, which gave me a powerful language with little effort. So armed, I set out to write libctl which generates the Guile interface from an abstract Scheme specification, partially as an experiment to see how hard it would be and what the result would look like. After a weekend of work, it was obvious that I had a powerful tool; I spent couple of weeks adding some finishing touches, writing documentation, and so on, and proudly showed it off to my groupmates in the hope that they could use it for their programs. Without a real example of a program using libctl, however, it was hard to convince them to plug a scripting language into their existing, working codes. So, I went back to puttering at my eigensolvers.\n\n\nOf course, all this time I was allegedly doing real research, and long periods would go by with little progress on MPB. The original, Fortran code was still working, and in time one learned to bear its quirks and limitations with stoicism, although we cringed every time we had to show it to anyone else. By the summer of 1999, I had a working block eigensolver supporting several iteration-scheme variants, a Maxwell operator to plug into the eigensolver including a \"targeted\" operator, whose convergence I was unhappy with, and a test program to do convergence experiments on bands of a Bragg mirror. I hadn't attached any general user interface, field output, or other necessary components. At this point, Dr. Doug Allan of Corning (a former student of Prof. Joannopoulos), heard about the new code--in particular, the targeted eigensolver--and began clamoring to try it out. Not put off by my excuses, he asked for a copy of my current code, regardless of its status, to play with. Not wanting to refuse, but aghast at the prospect of someone seeing my masterpiece only half-painted, I told him to give me a week...in which time I added the interface and discovered that I had a useful tool. Over the next week, I added many features, fixed bugs, and wrote documentation, drawing near to a release at last...", 
            "title": "Introduction"
        }, 
        {
            "location": "/Introduction/#frequency-domain-vs-time-domain", 
            "text": "There are two common computational electromagnetic approaches to studying dielectric structures: frequency-domain and time-domain. We feel that each has its own place in a researcher's toolbox, and each has unique advantages and disadvantages. For a more detailed discussion, see  our online textbook , appendix D.  MPB is frequency-domain . That is, it does a direct computation of the eigenstates and eigenvalues of Maxwell's equations using a planewave basis. Each field computed has a definite frequency. In contrast, time-domain techniques as in our  Meep  software iterate Maxwell's equations in time; the computed fields have a definite time at each time step but not a definite frequency  per se . It seems worthwhile to say a few words about each method, and to explain why we want a frequency-domain code.  Time-domain methods are well-suited to computing things that involve evolution of the fields, such as transmission and resonance decay-time calculations. They can also be used to calculate band structures and for finding resonant modes, by looking for peaks in the Fourier transform of the system response to some input. The main advantage of this is that you get all the spectral peaks at once from a single calculation. There are several disadvantages to this technique, however. First, it is hard to be confident that you have found all of the states\u2014you may have coupled weakly to some state by accident, or two states may be close in frequency and appear as a single peak. This is especially problematic in higher-order resonant-cavity and waveguide calculations. Second, in the Fourier transform, the frequency resolution is inversely related to the simulation time. To get 10 times the resolution you must run your simulation 10 times as long although matters are improved by using more sophisticated signal-processing methods such as  Harminv . Third, the time-step size must be proportional to the spatial-grid size for numerical stability. Thus, if you double the spatial resolution, you must double the number of time steps (the length of your simulation), even if you are looking at states with the same frequency as before. Fourth, you only get the frequencies of the states. To get the eigenstates themselves so that you can see what the modes look like and do calculations with them, you must run the simulation again, once for each state that you want, and for a time inversely proportional to the frequency-spacing between adjacent states (i.e. a long time for closely-spaced states).  In contrast, frequency-domain methods like those in MPB are in many ways better-suited to calculating band structures and eigenstates. Here, we consider the case of an  iterative  eigensolver like the one in MPB, which iteratively improves approximate eigenstates. Dense solvers, which factorize the matrix directly, are impractical for large problems because of the huge size of the matrix, and because they compute many more eigenvectors than are desired. In iterative methods, the operator is only applied to individual vectors and is never itself computed explicitly. First, you don't have to worry about missing states\u2014even closely-spaced modes will appear as two eigenvalues in the result. Second, the error in the frequency in an iterative eigensolver typically decays exponentially with the number of iterations, so the number of iterations is logarithmic in the desired tolerance. Third, the number of iterations typically remains almost constant even as you increase the resolution. The work for each iteration increases, of course, but that happens in time-domain too. Fourth, you get both the frequencies and the eigenstates at the same time, so you can look at the modes immediately, even closely-spaced ones.  A traditional disadvantage of frequency-domain methods was that you had to compute all of the lowest eigenstates, up to the desired one, even if you didn't care about the lower ones. This was especially problematic in defect calculations, in which a large supercell is used, because in that case the lower bands are \"folded\" many times in the Brillouin zone. Thus, you often had to compute a large number of bands in order to get to the one you wanted incurring large costs both in time and in storage. These disadvantages disappear to some degree in MPB, however, with the advent of its \"targeted\" eigensolver\u2014with it, you can solve directly for the localized defect states (i.e the states in the band gap) without computing the lower bands. However, the targeted eigensolver method used in MPB still has poor convergence, so time-domain methods such as  Meep  still have an advantage here.", 
            "title": "Frequency-Domain vs. Time-Domain"
        }, 
        {
            "location": "/Introduction/#history", 
            "text": "In order to shed some light on the past development and design decisions of MPB, I thought I'd write a few paragraphs about its history. Read on to enjoy my narcissistic ramblings.  Many different people have written codes to compute the modes of periodic dielectric materials although we don't know of any others that have been freely released. I have had experience with several programs written within our research group, and this experience has guided the design of MPB.  The first program of this sort that I came in contact with, and the code that was used in our group until the development of this package, was initially written around 1990 (in Fortran 77) by R. D. Meade. As this software grew organically over time, several problems became apparent. First, the input format was inflexible (difficult to add new features without breaking old simulations), sensitive to whitespace and other formatting, and required repeated entry of information that was often the same from file to file. Often, pre- and post-processing steps were required using additional scripts and tools. Second, the many parts of the program had become intertwined, lacking modularity or a clear flow of control; this made it difficult to follow or modify substantially. Parallelizing it, or removing constraints that it imposed like inversion symmetry, or even replacing the input format seemed impractical. Besides, even reading code with variables named  gxgzco  (in common block  cabgv ) (honest!) is a mind-altering experience.  After an initial experience in the Spring of 1996 at writing a code based on a wavelet, rather than a planewave, basis which turned out not to be practical, I set out to write a replacement for our Fortran eigensolver. My main aims at this time (Fall 1996) were a more flexible and powerful input format and a code that would be amenable to parallelization. I succeeded in achieving a working code with similar convergence to the old code (after  some pain ), but I discovered several things. I had lots of fun learning to use  lex  and  yacc  (Yet Another Compiler-Compiler) to make a flexible, C-like input format with variables and other advanced features. Having input files that were almost, but not quite, like a programming language made me realize, however, that what I really wanted  was  a programming language--no matter how many features I added, I always wanted one more \"simple\" thing. As far as parallelization, I quickly realized that I had a problem: I needed a parallel FFT, and the only ones that were available were proprietary (non-portable), used incompatible data distribution formats, and were often designed to be called only from special languages like HPF. That, plus my dissatisfaction with the available free FFTs, led me to embark on a side project (with my friend Matteo Frigo, then of MIT's Laboratory for Computer Science) to develop a new, free FFT library,  FFTW , that included portable parallel routines. Also, I decided that attempting to support too many models of parallel programming (threads, MPI, Cray  shmem ) in one program resulted in a mess; it was better to stick with MPI (supporting running only a single process too, of course). Another mistake I discovered was that I allowed the eigensolver to get too intertwined with the specific problem of Maxwell's equations--the eigensolver knew about the data structures for the fields, etcetera, making it difficult to plug in replacement eigensolvers, test things in isolation, or to implement features like the \"targeted\" eigensolver of MPB which diagonalizes a different operator. The whole program was too mired in complexity. Finally, in the interim I had learned about block eigensolver algorithms. Not only can such algorithms leverage prepackaged, highly-optimized routines like BLAS and LAPACK, but they also promised to be inherently more suited for parallelization since they remove the serial process of solving for the bands one by one. All of these things convinced me that I needed to rewrite the code again from scratch.  So, I started work on the new package (in Spring 1998), this time determined to develop and debug each component (matrix operations, eigensolver, maxwell operator, user input) in isolation. At the same time, I was thinking about how I would implement the user control language, wanting to develop a general tool that could be applied to other problems and software in our research. It seemed clear that, in order to get other people to use it in their programs, as well as to avoid a lot of the manual labor that went into my previous effort, I wanted to automatically generate the user/program interface from an abstract specification. As for the control language, I briefly considered implementing my own, but was happily led to GNU Guile instead, which gave me a powerful language with little effort. So armed, I set out to write libctl which generates the Guile interface from an abstract Scheme specification, partially as an experiment to see how hard it would be and what the result would look like. After a weekend of work, it was obvious that I had a powerful tool; I spent couple of weeks adding some finishing touches, writing documentation, and so on, and proudly showed it off to my groupmates in the hope that they could use it for their programs. Without a real example of a program using libctl, however, it was hard to convince them to plug a scripting language into their existing, working codes. So, I went back to puttering at my eigensolvers.  Of course, all this time I was allegedly doing real research, and long periods would go by with little progress on MPB. The original, Fortran code was still working, and in time one learned to bear its quirks and limitations with stoicism, although we cringed every time we had to show it to anyone else. By the summer of 1999, I had a working block eigensolver supporting several iteration-scheme variants, a Maxwell operator to plug into the eigensolver including a \"targeted\" operator, whose convergence I was unhappy with, and a test program to do convergence experiments on bands of a Bragg mirror. I hadn't attached any general user interface, field output, or other necessary components. At this point, Dr. Doug Allan of Corning (a former student of Prof. Joannopoulos), heard about the new code--in particular, the targeted eigensolver--and began clamoring to try it out. Not put off by my excuses, he asked for a copy of my current code, regardless of its status, to play with. Not wanting to refuse, but aghast at the prospect of someone seeing my masterpiece only half-painted, I told him to give me a week...in which time I added the interface and discovered that I had a useful tool. Over the next week, I added many features, fixed bugs, and wrote documentation, drawing near to a release at last...", 
            "title": "History"
        }, 
        {
            "location": "/Installation/", 
            "text": "Installation\n\n\n\n\nTable of Contents\n\n\nInstallation\n\n\nInstallation on MacOS X\n\n\nUnix Installation Basics\n\n\nInstallation Paths\n\n\nPaths for Configuring\n\n\nPaths for Running (Shared Libraries)\n\n\n\n\n\n\nFun with Fortran\n\n\nPicking a Compiler\n\n\nLinux and BSD Binary Packages\n\n\n\n\n\n\nBLAS and LAPACK\n\n\nBLAS\n\n\nLAPACK\n\n\n\n\n\n\nMPI (parallel machines)\n\n\nHDF5 (recommended)\n\n\nFFTW\n\n\nReadline (optional)\n\n\nGuile\n\n\nAutoconf (optional)\n\n\nlibctl\n\n\nMPB\n\n\n\n\n\n\n\n\n\n\nImportant Note\n: Installing MPB from source can be challenging for novice users. As a simple workaround, the latest version of MPB preinstalled on Ubuntu can be accessed on Amazon Web Services (AWS) Elastic Compute Cloud (EC2) as a free \nAmazon Machine Image (AMI)\n. To access this AMI, follow these \ninstructions\n.\n\n\nIn this section, we outline the procedure for installing MPB. Mainly, this consists of downloading and installing various prerequisites. As much as possible, we have attempted to take advantage of existing packages such as BLAS, LAPACK, FFTW, and Guile, in order to make our code smaller, more robust, faster, and more flexible. Unfortunately, this may make the installation of MPB more complicated if you do not already have these packages.\n\n\nYou will also need an ANSI C compiler (gcc is fine) and installation will be easiest on a UNIX-like system (Linux is fine). In the following list, some of the packages are dependent upon packages listed earlier, so you should install them in more-or-less the order given.\n\n\nMany of these libraries may be available in precompiled binary form, especially for Linux systems. Be aware, however, that library binary packages often come in two parts, \nlibrary\n and \nlibrary-dev\n, and \nboth\n are required to compile programs using it.\n\n\nIt is important that you use the \nsame Fortran compiler\n to compile Fortran libraries (like LAPACK) and for configuring MPB. Different Fortran compilers often have incompatible linking schemes. The Fortran compiler for MPB can be set via the \nF77\n environment variable.\n\n\nInstallation on MacOS X\n\n\nSee \nMeep installation on OS X\n for the easiest way to do this.\n\n\nUnix Installation Basics\n\n\nInstallation Paths\n\n\nFirst, let's review some important information about installing software on Unix systems, especially in regards to installing software in non-standard locations. None of these issues are specific to MPB, but they've caused a lot of confusion among users.\n\n\nMost of the software below, including MPB, installs under \n/usr/local\n by default. That is, libraries go in \n/usr/local/lib\n, programs in \n/usr/local/bin\n, etc. If you don't have \nroot\n privileges on your machine, you may need to install somewhere else, e.g. under \n$HOME/install\n (the \ninstall/\n subdirectory of your home directory). Most of the programs below use a GNU-style \nconfigure\n script, which means that all you would do to install there would be:\n\n\n ./configure --prefix=$HOME/install\n\n\n\n\nwhen configuring the program. The directories \n$HOME/install/lib\n etc. are created automatically as needed.\n\n\nPaths for Configuring\n\n\nThere are two further complications. First, if you install in a non-standard location and \n/usr/local\n is considered non-standard by some proprietary compilers, you will need to tell the compilers where to find the libraries and header files that you installed. You do this by setting two environment variables:\n\n\n setenv LDFLAGS \n-L/usr/local/lib\n\n setenv CPPFLAGS \n-I/usr/local/include\n\n\n\n\n\nOf course, substitute whatever installation directory you used. Do this \nbefore\n you run the \nconfigure\n scripts, etcetera. You may need to include multiple \n-L\n and \n-I\n flags separated by spaces if your machine has stuff installed in several non-standard locations. Bourne shell users (e.g. \nbash\n or \nksh\n) should use the \nexport FOO=bar\n syntax instead of \ncsh\n's \nsetenv FOO bar\n, of course.\n\n\nYou might also need to update your \nPATH\n so that you can run the executables you installed although \n/usr/local/bin/\n is in the default \nPATH\n on many systems. e.g. if we installed in our home directory as described above, we would do:\n\n\n setenv PATH \n$HOME/install/bin:$PATH\n\n\n\n\n\nPaths for Running (Shared Libraries)\n\n\nSecond, many of the packages installed below (e.g. Guile) are installed as shared libraries. You need to make sure that your runtime linker knows where to find these shared libraries. The bad news is that every operating system does this in a slightly different way. The good news is that, when you run \nmake install\n for the packages involving shared libraries, the output includes the necessary instructions specific to your system, so pay close attention! It will say something like \nadd LIBDIR to the \nfoobar\n environment variable\n, where \nLIBDIR\n will be your library installation directory (e.g. \n/usr/local/lib\n) and \nfoobar\n is some environment variable specific to your system (e.g. \nLD_LIBRARY_PATH\n on some systems, including Linux). For example, you might do:\n\n\n setenv LD_LIBRARY_PATH \n/usr/local/lib:$LD_LIBRARY_PATH\n\n\n\n\n\nNote that we just add to the library path variable, and don't replace it in case it contains stuff already. If you use Linux and have \nroot\n privileges, you can instead simply run \n/sbin/ldconfig\n, first making sure that a line \n/usr/local/lib\n (or whatever) is in \n/etc/ld.so.conf\n.\n\n\nIf you don't want to type these commands every time you log in, you can put them in your \n~/.cshrc\n file or \n~/.profile\n, or \n~/.bash_profile\n, depending on your shell.\n\n\nFun with Fortran\n\n\nMPB, along with many of the libraries it calls, is written in C or C++, but it also calls libraries such as BLAS and LAPACK (see below) that are usually compiled from Fortran. This can cause some added difficulty because of the various linking schemes used by Fortran compilers. Our \nconfigure\n script attempts to detect the Fortran linking scheme automatically, but in order for this to work ''you must use the same Fortran compiler and options with MPB as were used to compile BLAS/LAPACK''.\n\n\nBy default, MPB looks for a vendor Fortran compiler first (\nf77\n, \nxlf\n, etcetera) and then looks for GNU \ng77\n. In order to manually specify a Fortran compiler \nfoobar\n you would configure it with \n./configure F77=foobar ...\n.\n\n\nIf, when you compiled BLAS/LAPACK, you used compiler options that alter the linking scheme (e.g. \ng77\n's \n-fcase-upper\n or \n-fno-underscoring\n), you will need to pass the same flags to MPB via \n./configure FFLAGS=...flags... ...\n.\n\n\nPicking a Compiler\n\n\nIt is often important to be consistent about which compiler you employ. This is especially true for C++ software. To specify a particular C compiler \nfoo\n, configure with \n./configure CC=foo\n; to specify a particular C++ compiler \nfoo++\n, configure with \n./configure CXX=foo++\n; to specify a particular Fortran compiler \nfoo90\n, configure with \n./configure F77=foo90\n.\n\n\nLinux and BSD Binary Packages\n\n\nIf you are installing on your personal Linux or BSD machine, then precompiled binary packages are likely to be available for many of these packages, and may even have been included with your system. On Debian systems, the packages are in \n.deb\n format and the built-in \napt-get\n program can fetch them from a central repository. On Red Hat, SuSE, and most other Linux-based systems, binary packages are in RPM format.  OpenBSD has its \"ports\" system, and so on.\n\n\nDo not compile something from source if an official binary package is available.\n  For one thing, you're just creating pain for yourself.  Worse, the binary package may already be installed, in which case installing a different version from source will just cause trouble.\n\n\nOne thing to watch out for is that libraries like LAPACK, Guile, HDF5, etcetera, will often come split up into two or more packages: e.g. a \nguile\n package and a \nguile-devel\n package. You need to install \nboth\n of these to compile software using the library.\n\n\nBLAS and LAPACK\n\n\nMPB requires the BLAS and LAPACK libraries for matrix computations.\n\n\nBLAS\n\n\nThe first thing you must have on your system is a BLAS implementation. \"BLAS\" stands for \"Basic Linear Algebra Subroutines,\" and is a standard interface for operations like matrix multiplication. It is designed as a building-block for other linear-algebra applications, and is used both directly by our code and in LAPACK (see below). By using it, we can take advantage of many highly-optimized implementations of these operations that have been written to the BLAS interface. Note that you will need implementations of BLAS levels 1-3.\n\n\nYou can find more BLAS information, as well as a basic implementation, on the \nBLAS Homepage\n. Once you get things working with the basic BLAS implementation, it might be a good idea to try and find a more optimized BLAS code for your hardware. Vendor-optimized BLAS implementations are available as part of the Intel MKL, HP CXML, IBM ESSL, SGI sgimath, and other libraries. An excellent, high-performance, free-software BLAS implementation is  \nOpenBLAS\n. Another is \nATLAS\n.\n\n\nNote that the generic BLAS does not come with a \nMakefile\n; compile it with something like: \n\n\n  wget http://www.netlib.org/blas/blas.tgz\n  gunzip blas.tgz\n  tar xf blas.tar\n  cd BLAS\n  f77 -c -O3 *.f   # compile all of the .f files to produce .o files\n  ar rv libblas.a *.o    #  combine the .o files into a library\n  su -c \ncp libblas.a /usr/local/lib\n   # switch to root and install\n\n\n\n\nReplace \n-O3\n with your favorite optimization options. On Linux, this could be \ng77 -O3 -fomit-frame-pointer -funroll-loops -malign-double\n. Note that MPB looks for the standard BLAS library with \n-lblas\n, so the library file should be called \nlibblas.a\n and reside in a standard directory like \n/usr/local/lib\n. See also below for the \n--with-blas=lib\n option to MPB's \nconfigure\n script, to manually specify a library location.\n\n\nLAPACK\n\n\nLAPACK, the Linear Algebra PACKage, is a standard collection of routines, built on BLAS, for more-complicated (dense) linear algebra operations like matrix inversion and diagonalization. You can download LAPACK from the \nLAPACK Home Page\n.\n\n\nNote that MPB looks for LAPACK by linking with \n-llapack\n. This means that the library must be called \nliblapack.a\n and be installed in a standard directory like \n/usr/local/lib\n. Alternatively, you can specify another directory via the \nLDFLAGS\n environment variable as described earlier. See also below for the \n--with-lapack=''lib''\n option to our \nconfigure\n script, to manually specify a library location.\n\n\nWe currently recommend installing OpenBLAS which includes LAPACK so you do not need to install it separately.\n\n\nMPI (parallel machines)\n\n\nOptionally, MPB is able to run on a distributed-memory parallel machine, and to do this we use the standard message-passing interface (MPI). You can learn about MPI from its \nhomepage\n. Most commercial supercomputers already have an MPI implementation installed. The recommended implementation is \nOpen MPI\n. MPI is \nnot required\n to compile the serial version of MPB.\n\n\nIn order for the MPI version to run successfully, we have a slightly nonstandard requirement: each process must be able to read from the disk. This way, Guile can boot for each process and they can all read your control file in parallel. Most commercial supercomputers satisfy this requirement.\n\n\nIf you use MPB with MPI, you should compile HDF5 with MPI support as well. See below.\n\n\nAlso, in order to get good performance, you'll need fast interconnect hardware such as Gigabit Ethernet, InfiniBand, or Myrinet. The speed bottleneck comes from the FFT, which requires most of the communications in MPB. FFTW's MPI transforms (\nsee below\n) come with benchmark programs that will give you a good idea of whether you can get speedups on your system. Of course, even with slow communications, you can still benefit from the memory savings per CPU for large problems.\n\n\nAs described below, when you configure MPB with MPI support (\n--with-mpi\n), it installs itself as \nmpb-mpi\n. See also the \nmanual\n for information on using MPB on parallel machines. Normally, you should \nalso\n install the serial version of MPB, if only to get the \nmpb-data\n utility, which is not installed with the MPI version.\n\n\nHDF5 (recommended)\n\n\nWe require a portable, standard binary format for outputting the electromagnetic fields and similar volumetric data, and for this we use HDF. If you don't have HDF5, you can still compile MPB, but you won't be able to output the fields or the dielectric function.\n\n\nHDF is a widely-used, free, portable library and file format for multi-dimensional scientific data, developed in the National Center for Supercomputing Applications (NCSA) at the University of Illinois. You can get HDF and learn about it on the \nHDF Home Page\n.\n\n\nWe require HDF5 which is supported by a number scientific of visualization tools including our own \nh5utils\n utilities.\n\n\nHDF5 includes parallel I/O support under MPI, which can be enabled by configuring it with \n--enable-parallel\n. You may also have to set the \nCC\n environment variable to \nmpicc\n. Unfortunately, the parallel HDF5 library then does not work with serial code, so you have may have to choose one or the other.\n\n\nWe have some hacks in MPB so that it can do parallel I/O even with the serial HDF5 library. These hacks work okay when you are using a small number of processors, but on large supercomputers we strongly recommend using the parallel HDF5.\n\n\nNote:\n If you have a version of HDF5 compiled with MPI parallel I/O support, then you need to use the MPI compilers to link to it, even when you are compiling the serial version of MPB.  Just use \n./configure CC=mpicc CXX=mpic++\n or whatever your MPI compilers are when configuring.\n\n\nFFTW\n\n\nFFTW is a self-optimizing, portable, high-performance FFT implementation, including both serial and parallel FFTs. You can download FFTW and find out more about it from the \nFFTW Home Page\n.\n\n\nIf you want to use MPB on a parallel machine with MPI, you will also need to install the MPI FFTW libraries. This just means including \n--enable-mpi\n in the FFTW \nconfigure\n flags.\n\n\nReadline (optional)\n\n\nReadline is a library to provide command-line history, tab-completion, emacs keybindings, and other shell-like niceties to command-line programs. This is an \noptional\n package, but one that can be used by Guile (see below) if it is installed. We recommend installing it. You can download Readline from its \nftp site\n. Readline is typically preinstalled on Linux systems.\n\n\nGuile\n\n\nGuile is required in order to use the Scheme interface, and is strongly recommended. If you don't install it, you can only use the C++ interface.\n\n\nGuile is an extension/scripting language implementation based on Scheme, and we use it to provide a rich, fully-programmable user interface with minimal effort. It's free, of course, and you can download it from the \nGuile Home Page\n. Guile is typically included with Linux systems.\n\n\n\n\nImportant:\n Most Linux distributions come with Guile already installed. You can check by seeing whether you can run \nguile --version\n from the command line. In that case, do \nnot\n install your own version of Guile from source \n having two versions of Guile on the same system will cause problems. However, by default most distributions install only the Guile libraries and not the programming headers \n to compile libctl and MPB, you should install the \nguile-devel\n or \nguile-dev\n package.\n\n\n\n\nAutoconf (optional)\n\n\nIf you want to be a developer of the MPB package as opposed to merely a user, you will also need the Autoconf program. Autoconf is a portability tool that generates \nconfigure\n scripts to automatically detect the capabilities of a system and configure a package accordingly. You can find out more at the \nAutoconf Home Page\n. \nautoconf\n is typically installed by default on Linux systems. In order to install Autoconf, you will also need the GNU \nm4\n program if you do not already have it. See the \nm4 Home Page\n.\n\n\nlibctl\n\n\nlibctl\n, which requires Guile, is required to use the Scheme interface, and is strongly r\necommended. If you don't install it, you can only use the C++ interface. libctl version \n3.2 or later\n is required.\n\n\nInstead of using Guile directly, we separated much of the user interface code into a package called libctl, in the hope that this might be\n more generally useful. libctl automatically handles the communication between the program and Guile, converting complicated data structur\n es and so on, to make it even easier to use Guile to control scientific applications. Download libctl from the \nlibctl page\n, unpack it, and run the usual \nconfigure\n, \nmake\n, \nmake install\n sequence. You'll also want to browse the \nlibctl manual\n, as this will give you a general overview of what the user interface will be like.\n\n\nIf you are not the system administrator of your machine, and/or want to install libctl somewhere else like your home directory, you can do so with the standard \n--prefix=dir\n option to \nconfigure\n. The default prefix is \n/usr/local\n. In this case, however, you'll need to specify the location of the libctl shared files for MPB, using the \n--with-libctl=dir/share/libctl\n option to our \nconfigure\n script.\n\n\nMPB\n\n\nIf you've made it all the way here, you're ready to install the MPB package and start cranking out eigenmodes. You can obtain the latest version from the \nDownload page\n. Once you've unpacked it, just run:\n\n\n./configure\nmake\n\n\n\n\nto configure and compile the package. See below to install. Hopefully, the \nconfigure\n script will correctly detect the BLAS, FFTW, etcetera libraries which have been installed, as well as the C compiler and so on, and the \nmake\n compilation will proceed without a hitch. If not, \nconfigure\n accepts several flags to help control its behavior. Some of these are standard, like \n--prefix=\ndir\n to specify an installation directory prefix, and some of them are specific to the MPB package. Use \n./configure --help\n for more info. The \nconfigure\n flags specific to MPB are:\n\n\n--with-inv-symmetry\n\n\n\nAssume \ninversion symmetry\n in the dielectric function, allowing us to use real fields in Fourier space instead of complex fields. This gives a factor of 2 benefit in speed and memory. In this case, the MPB program will be installed as \nmpbi\n instead of \nmpb\n, so that you can have versions both with and without inversion symmetry installed at the same time. To install \nboth\n \nmpb\n and \nmpbi\n, you should do:\n\n\n./configure\nmake\nsudo\u00a0make\u00a0install\nmake\u00a0distclean\n./configure\u00a0--with-inv-symmetry\nmake\nsudo\u00a0make\u00a0install\n\n\n\n\n--with-hermitian-eps\n\n\n\nSupport the use of \ncomplex-hermitian dielectric tensors\n corresponding to magnetic materials, which break inversion symmetry.\n\n\n--enable-single\n\n\n\nUse single precision (C \nfloat\n) instead of the default double precision (C \ndouble\n) for computations. Not recommended.\n\n\n--without-hdf5\n\n\n\nDon't use the HDF5 library for field and dielectric function output. In which case, no field output is possible.\n\n\n--with-mpi\n\n\n\nAttempt to compile a parallel version of MPB using MPI; the resulting program will be installed as \nmpb-mpi\n. Requires \nMPI\n and \nMPI FFTW\n libraries to be installed, as described above.\n\n\nDoes \nnot\n compile the serial MPB, or \nmpb-data\n; if you want those, you should \nmake distclean\n and compile/install them separately.\n\n\n--with-mpi\n\n\n\nCan be used along with \n--with-inv-symmetry\n, in which case the program is installed as \nmpbi-mpi\n.\n\n\n--with-openmp\n\n\n\nAttempt to compile a shared-memory parallel version of MPB using OpenMP. The resulting program will be installed as \nmpb\n and FFTs will use OpenMP parallelism. Requires OpenMP FFTW libraries to be installed.\n\n\n--with-libctl=dir\n\n\n\nIf libctl was installed in a nonstandard location (i.e. neither \n/usr\n nor \n/usr/local\n), you need to specify the location of the libctl directory, \ndir\n. This is either \nprefix/share/libctl\n, where \nprefix\n is the installation prefix of libctl, or the original libctl source code directory.\n\n\n--with-blas=lib\n\n\n\nThe \nconfigure\n script automatically attempts to detect accelerated BLAS libraries, like DXML (DEC/Alpha), SCSL and SGIMATH (SGI/MIPS), ESSL (IBM/PowerPC), ATLAS, and PHiPACK. You can, however, force a specific library name to try via \n--with-blas=lib\n.\n\n\n--with-lapack=lib\n\n\n\nCause the \nconfigure\n script to look for a LAPACK library called \nlib\n. The default is to use \n-llapack\n.\n\n\n--disable-checks\n\n\n\nDisable runtime checks. Not recommended. The disabled checks shouldn't take up a significant amount of time anyway.\n\n\n--enable-prof\n\n\n\nCompile for performance profiling.\n\n\n--enable-debug\n\n\n\nCompile for debugging, adding extra runtime checks and so on.\n\n\n--enable-debug-malloc\n\n\n\nUse special memory-allocation routines for extra debugging (to check for array overwrites, memory leaks, etcetera).\n\n\n--with-efence\n\n\n\nMore debugging: use the \nElectric Fence\n library, if available, for extra runtime array bounds-checking.\n\n\nYou can further control \nconfigure\n by setting various environment variables, such as:\n\n\n\n\nCC\n: the C compiler command\n\n\nCFLAGS\n: the C compiler flags (defaults to \n-O3\n).\n\n\nCPPFLAGS\n: \n-I\ndir\n flags to tell the C compiler additional places to look for header files.\n\n\nLDFLAGS\n: \n-L\ndir\n flags to tell the linker additional places to look for libraries.\n\n\nLIBS\n: additional libraries to link against.\n\n\n\n\nOnce compiled, the main program, as opposed to various test programs, resides in the \nmpb-ctl/\n subdirectory, and is called \nmpb\n. You can install this program under \n/usr/local\n or elsewhere, if you used the \n--prefix\n flag for \nconfigure\n, by running:\n\n\nsudo\u00a0make\u00a0install\n\n\n\n\nThe \"sudo\" command is to switch to \nroot\n for installation into system directories. You can just do \nmake install\n if you are installing into your home directory instead.\n\n\nIf you make a mistake (e.g. you forget to specify a needed \n-L\ndir\n flag) or in general want to start over from a clean slate, you can restore MPB to a pristine state by running:\n\n\nmake\u00a0distclean", 
            "title": "Installation"
        }, 
        {
            "location": "/Installation/#installation-on-macos-x", 
            "text": "See  Meep installation on OS X  for the easiest way to do this.", 
            "title": "Installation on MacOS X"
        }, 
        {
            "location": "/Installation/#unix-installation-basics", 
            "text": "", 
            "title": "Unix Installation Basics"
        }, 
        {
            "location": "/Installation/#installation-paths", 
            "text": "First, let's review some important information about installing software on Unix systems, especially in regards to installing software in non-standard locations. None of these issues are specific to MPB, but they've caused a lot of confusion among users.  Most of the software below, including MPB, installs under  /usr/local  by default. That is, libraries go in  /usr/local/lib , programs in  /usr/local/bin , etc. If you don't have  root  privileges on your machine, you may need to install somewhere else, e.g. under  $HOME/install  (the  install/  subdirectory of your home directory). Most of the programs below use a GNU-style  configure  script, which means that all you would do to install there would be:   ./configure --prefix=$HOME/install  when configuring the program. The directories  $HOME/install/lib  etc. are created automatically as needed.", 
            "title": "Installation Paths"
        }, 
        {
            "location": "/Installation/#paths-for-configuring", 
            "text": "There are two further complications. First, if you install in a non-standard location and  /usr/local  is considered non-standard by some proprietary compilers, you will need to tell the compilers where to find the libraries and header files that you installed. You do this by setting two environment variables:   setenv LDFLAGS  -L/usr/local/lib \n setenv CPPFLAGS  -I/usr/local/include   Of course, substitute whatever installation directory you used. Do this  before  you run the  configure  scripts, etcetera. You may need to include multiple  -L  and  -I  flags separated by spaces if your machine has stuff installed in several non-standard locations. Bourne shell users (e.g.  bash  or  ksh ) should use the  export FOO=bar  syntax instead of  csh 's  setenv FOO bar , of course.  You might also need to update your  PATH  so that you can run the executables you installed although  /usr/local/bin/  is in the default  PATH  on many systems. e.g. if we installed in our home directory as described above, we would do:   setenv PATH  $HOME/install/bin:$PATH", 
            "title": "Paths for Configuring"
        }, 
        {
            "location": "/Installation/#paths-for-running-shared-libraries", 
            "text": "Second, many of the packages installed below (e.g. Guile) are installed as shared libraries. You need to make sure that your runtime linker knows where to find these shared libraries. The bad news is that every operating system does this in a slightly different way. The good news is that, when you run  make install  for the packages involving shared libraries, the output includes the necessary instructions specific to your system, so pay close attention! It will say something like  add LIBDIR to the  foobar  environment variable , where  LIBDIR  will be your library installation directory (e.g.  /usr/local/lib ) and  foobar  is some environment variable specific to your system (e.g.  LD_LIBRARY_PATH  on some systems, including Linux). For example, you might do:   setenv LD_LIBRARY_PATH  /usr/local/lib:$LD_LIBRARY_PATH   Note that we just add to the library path variable, and don't replace it in case it contains stuff already. If you use Linux and have  root  privileges, you can instead simply run  /sbin/ldconfig , first making sure that a line  /usr/local/lib  (or whatever) is in  /etc/ld.so.conf .  If you don't want to type these commands every time you log in, you can put them in your  ~/.cshrc  file or  ~/.profile , or  ~/.bash_profile , depending on your shell.", 
            "title": "Paths for Running (Shared Libraries)"
        }, 
        {
            "location": "/Installation/#fun-with-fortran", 
            "text": "MPB, along with many of the libraries it calls, is written in C or C++, but it also calls libraries such as BLAS and LAPACK (see below) that are usually compiled from Fortran. This can cause some added difficulty because of the various linking schemes used by Fortran compilers. Our  configure  script attempts to detect the Fortran linking scheme automatically, but in order for this to work ''you must use the same Fortran compiler and options with MPB as were used to compile BLAS/LAPACK''.  By default, MPB looks for a vendor Fortran compiler first ( f77 ,  xlf , etcetera) and then looks for GNU  g77 . In order to manually specify a Fortran compiler  foobar  you would configure it with  ./configure F77=foobar ... .  If, when you compiled BLAS/LAPACK, you used compiler options that alter the linking scheme (e.g.  g77 's  -fcase-upper  or  -fno-underscoring ), you will need to pass the same flags to MPB via  ./configure FFLAGS=...flags... ... .", 
            "title": "Fun with Fortran"
        }, 
        {
            "location": "/Installation/#picking-a-compiler", 
            "text": "It is often important to be consistent about which compiler you employ. This is especially true for C++ software. To specify a particular C compiler  foo , configure with  ./configure CC=foo ; to specify a particular C++ compiler  foo++ , configure with  ./configure CXX=foo++ ; to specify a particular Fortran compiler  foo90 , configure with  ./configure F77=foo90 .", 
            "title": "Picking a Compiler"
        }, 
        {
            "location": "/Installation/#linux-and-bsd-binary-packages", 
            "text": "If you are installing on your personal Linux or BSD machine, then precompiled binary packages are likely to be available for many of these packages, and may even have been included with your system. On Debian systems, the packages are in  .deb  format and the built-in  apt-get  program can fetch them from a central repository. On Red Hat, SuSE, and most other Linux-based systems, binary packages are in RPM format.  OpenBSD has its \"ports\" system, and so on.  Do not compile something from source if an official binary package is available.   For one thing, you're just creating pain for yourself.  Worse, the binary package may already be installed, in which case installing a different version from source will just cause trouble.  One thing to watch out for is that libraries like LAPACK, Guile, HDF5, etcetera, will often come split up into two or more packages: e.g. a  guile  package and a  guile-devel  package. You need to install  both  of these to compile software using the library.", 
            "title": "Linux and BSD Binary Packages"
        }, 
        {
            "location": "/Installation/#blas-and-lapack", 
            "text": "MPB requires the BLAS and LAPACK libraries for matrix computations.", 
            "title": "BLAS and LAPACK"
        }, 
        {
            "location": "/Installation/#blas", 
            "text": "The first thing you must have on your system is a BLAS implementation. \"BLAS\" stands for \"Basic Linear Algebra Subroutines,\" and is a standard interface for operations like matrix multiplication. It is designed as a building-block for other linear-algebra applications, and is used both directly by our code and in LAPACK (see below). By using it, we can take advantage of many highly-optimized implementations of these operations that have been written to the BLAS interface. Note that you will need implementations of BLAS levels 1-3.  You can find more BLAS information, as well as a basic implementation, on the  BLAS Homepage . Once you get things working with the basic BLAS implementation, it might be a good idea to try and find a more optimized BLAS code for your hardware. Vendor-optimized BLAS implementations are available as part of the Intel MKL, HP CXML, IBM ESSL, SGI sgimath, and other libraries. An excellent, high-performance, free-software BLAS implementation is   OpenBLAS . Another is  ATLAS .  Note that the generic BLAS does not come with a  Makefile ; compile it with something like:     wget http://www.netlib.org/blas/blas.tgz\n  gunzip blas.tgz\n  tar xf blas.tar\n  cd BLAS\n  f77 -c -O3 *.f   # compile all of the .f files to produce .o files\n  ar rv libblas.a *.o    #  combine the .o files into a library\n  su -c  cp libblas.a /usr/local/lib    # switch to root and install  Replace  -O3  with your favorite optimization options. On Linux, this could be  g77 -O3 -fomit-frame-pointer -funroll-loops -malign-double . Note that MPB looks for the standard BLAS library with  -lblas , so the library file should be called  libblas.a  and reside in a standard directory like  /usr/local/lib . See also below for the  --with-blas=lib  option to MPB's  configure  script, to manually specify a library location.", 
            "title": "BLAS"
        }, 
        {
            "location": "/Installation/#lapack", 
            "text": "LAPACK, the Linear Algebra PACKage, is a standard collection of routines, built on BLAS, for more-complicated (dense) linear algebra operations like matrix inversion and diagonalization. You can download LAPACK from the  LAPACK Home Page .  Note that MPB looks for LAPACK by linking with  -llapack . This means that the library must be called  liblapack.a  and be installed in a standard directory like  /usr/local/lib . Alternatively, you can specify another directory via the  LDFLAGS  environment variable as described earlier. See also below for the  --with-lapack=''lib''  option to our  configure  script, to manually specify a library location.  We currently recommend installing OpenBLAS which includes LAPACK so you do not need to install it separately.", 
            "title": "LAPACK"
        }, 
        {
            "location": "/Installation/#mpi-parallel-machines", 
            "text": "Optionally, MPB is able to run on a distributed-memory parallel machine, and to do this we use the standard message-passing interface (MPI). You can learn about MPI from its  homepage . Most commercial supercomputers already have an MPI implementation installed. The recommended implementation is  Open MPI . MPI is  not required  to compile the serial version of MPB.  In order for the MPI version to run successfully, we have a slightly nonstandard requirement: each process must be able to read from the disk. This way, Guile can boot for each process and they can all read your control file in parallel. Most commercial supercomputers satisfy this requirement.  If you use MPB with MPI, you should compile HDF5 with MPI support as well. See below.  Also, in order to get good performance, you'll need fast interconnect hardware such as Gigabit Ethernet, InfiniBand, or Myrinet. The speed bottleneck comes from the FFT, which requires most of the communications in MPB. FFTW's MPI transforms ( see below ) come with benchmark programs that will give you a good idea of whether you can get speedups on your system. Of course, even with slow communications, you can still benefit from the memory savings per CPU for large problems.  As described below, when you configure MPB with MPI support ( --with-mpi ), it installs itself as  mpb-mpi . See also the  manual  for information on using MPB on parallel machines. Normally, you should  also  install the serial version of MPB, if only to get the  mpb-data  utility, which is not installed with the MPI version.", 
            "title": "MPI (parallel machines)"
        }, 
        {
            "location": "/Installation/#hdf5-recommended", 
            "text": "We require a portable, standard binary format for outputting the electromagnetic fields and similar volumetric data, and for this we use HDF. If you don't have HDF5, you can still compile MPB, but you won't be able to output the fields or the dielectric function.  HDF is a widely-used, free, portable library and file format for multi-dimensional scientific data, developed in the National Center for Supercomputing Applications (NCSA) at the University of Illinois. You can get HDF and learn about it on the  HDF Home Page .  We require HDF5 which is supported by a number scientific of visualization tools including our own  h5utils  utilities.  HDF5 includes parallel I/O support under MPI, which can be enabled by configuring it with  --enable-parallel . You may also have to set the  CC  environment variable to  mpicc . Unfortunately, the parallel HDF5 library then does not work with serial code, so you have may have to choose one or the other.  We have some hacks in MPB so that it can do parallel I/O even with the serial HDF5 library. These hacks work okay when you are using a small number of processors, but on large supercomputers we strongly recommend using the parallel HDF5.  Note:  If you have a version of HDF5 compiled with MPI parallel I/O support, then you need to use the MPI compilers to link to it, even when you are compiling the serial version of MPB.  Just use  ./configure CC=mpicc CXX=mpic++  or whatever your MPI compilers are when configuring.", 
            "title": "HDF5 (recommended)"
        }, 
        {
            "location": "/Installation/#fftw", 
            "text": "FFTW is a self-optimizing, portable, high-performance FFT implementation, including both serial and parallel FFTs. You can download FFTW and find out more about it from the  FFTW Home Page .  If you want to use MPB on a parallel machine with MPI, you will also need to install the MPI FFTW libraries. This just means including  --enable-mpi  in the FFTW  configure  flags.", 
            "title": "FFTW"
        }, 
        {
            "location": "/Installation/#readline-optional", 
            "text": "Readline is a library to provide command-line history, tab-completion, emacs keybindings, and other shell-like niceties to command-line programs. This is an  optional  package, but one that can be used by Guile (see below) if it is installed. We recommend installing it. You can download Readline from its  ftp site . Readline is typically preinstalled on Linux systems.", 
            "title": "Readline (optional)"
        }, 
        {
            "location": "/Installation/#guile", 
            "text": "Guile is required in order to use the Scheme interface, and is strongly recommended. If you don't install it, you can only use the C++ interface.  Guile is an extension/scripting language implementation based on Scheme, and we use it to provide a rich, fully-programmable user interface with minimal effort. It's free, of course, and you can download it from the  Guile Home Page . Guile is typically included with Linux systems.   Important:  Most Linux distributions come with Guile already installed. You can check by seeing whether you can run  guile --version  from the command line. In that case, do  not  install your own version of Guile from source   having two versions of Guile on the same system will cause problems. However, by default most distributions install only the Guile libraries and not the programming headers   to compile libctl and MPB, you should install the  guile-devel  or  guile-dev  package.", 
            "title": "Guile"
        }, 
        {
            "location": "/Installation/#autoconf-optional", 
            "text": "If you want to be a developer of the MPB package as opposed to merely a user, you will also need the Autoconf program. Autoconf is a portability tool that generates  configure  scripts to automatically detect the capabilities of a system and configure a package accordingly. You can find out more at the  Autoconf Home Page .  autoconf  is typically installed by default on Linux systems. In order to install Autoconf, you will also need the GNU  m4  program if you do not already have it. See the  m4 Home Page .", 
            "title": "Autoconf (optional)"
        }, 
        {
            "location": "/Installation/#libctl", 
            "text": "libctl , which requires Guile, is required to use the Scheme interface, and is strongly r\necommended. If you don't install it, you can only use the C++ interface. libctl version  3.2 or later  is required.  Instead of using Guile directly, we separated much of the user interface code into a package called libctl, in the hope that this might be\n more generally useful. libctl automatically handles the communication between the program and Guile, converting complicated data structur\n es and so on, to make it even easier to use Guile to control scientific applications. Download libctl from the  libctl page , unpack it, and run the usual  configure ,  make ,  make install  sequence. You'll also want to browse the  libctl manual , as this will give you a general overview of what the user interface will be like.  If you are not the system administrator of your machine, and/or want to install libctl somewhere else like your home directory, you can do so with the standard  --prefix=dir  option to  configure . The default prefix is  /usr/local . In this case, however, you'll need to specify the location of the libctl shared files for MPB, using the  --with-libctl=dir/share/libctl  option to our  configure  script.", 
            "title": "libctl"
        }, 
        {
            "location": "/Installation/#mpb", 
            "text": "If you've made it all the way here, you're ready to install the MPB package and start cranking out eigenmodes. You can obtain the latest version from the  Download page . Once you've unpacked it, just run:  ./configure\nmake  to configure and compile the package. See below to install. Hopefully, the  configure  script will correctly detect the BLAS, FFTW, etcetera libraries which have been installed, as well as the C compiler and so on, and the  make  compilation will proceed without a hitch. If not,  configure  accepts several flags to help control its behavior. Some of these are standard, like  --prefix= dir  to specify an installation directory prefix, and some of them are specific to the MPB package. Use  ./configure --help  for more info. The  configure  flags specific to MPB are:  --with-inv-symmetry  \nAssume  inversion symmetry  in the dielectric function, allowing us to use real fields in Fourier space instead of complex fields. This gives a factor of 2 benefit in speed and memory. In this case, the MPB program will be installed as  mpbi  instead of  mpb , so that you can have versions both with and without inversion symmetry installed at the same time. To install  both   mpb  and  mpbi , you should do:  ./configure\nmake\nsudo\u00a0make\u00a0install\nmake\u00a0distclean\n./configure\u00a0--with-inv-symmetry\nmake\nsudo\u00a0make\u00a0install  --with-hermitian-eps  \nSupport the use of  complex-hermitian dielectric tensors  corresponding to magnetic materials, which break inversion symmetry.  --enable-single  \nUse single precision (C  float ) instead of the default double precision (C  double ) for computations. Not recommended.  --without-hdf5  \nDon't use the HDF5 library for field and dielectric function output. In which case, no field output is possible.  --with-mpi  \nAttempt to compile a parallel version of MPB using MPI; the resulting program will be installed as  mpb-mpi . Requires  MPI  and  MPI FFTW  libraries to be installed, as described above.  Does  not  compile the serial MPB, or  mpb-data ; if you want those, you should  make distclean  and compile/install them separately.  --with-mpi  \nCan be used along with  --with-inv-symmetry , in which case the program is installed as  mpbi-mpi .  --with-openmp  \nAttempt to compile a shared-memory parallel version of MPB using OpenMP. The resulting program will be installed as  mpb  and FFTs will use OpenMP parallelism. Requires OpenMP FFTW libraries to be installed.  --with-libctl=dir  \nIf libctl was installed in a nonstandard location (i.e. neither  /usr  nor  /usr/local ), you need to specify the location of the libctl directory,  dir . This is either  prefix/share/libctl , where  prefix  is the installation prefix of libctl, or the original libctl source code directory.  --with-blas=lib  \nThe  configure  script automatically attempts to detect accelerated BLAS libraries, like DXML (DEC/Alpha), SCSL and SGIMATH (SGI/MIPS), ESSL (IBM/PowerPC), ATLAS, and PHiPACK. You can, however, force a specific library name to try via  --with-blas=lib .  --with-lapack=lib  \nCause the  configure  script to look for a LAPACK library called  lib . The default is to use  -llapack .  --disable-checks  \nDisable runtime checks. Not recommended. The disabled checks shouldn't take up a significant amount of time anyway.  --enable-prof  \nCompile for performance profiling.  --enable-debug  \nCompile for debugging, adding extra runtime checks and so on.  --enable-debug-malloc  \nUse special memory-allocation routines for extra debugging (to check for array overwrites, memory leaks, etcetera).  --with-efence  \nMore debugging: use the  Electric Fence  library, if available, for extra runtime array bounds-checking.  You can further control  configure  by setting various environment variables, such as:   CC : the C compiler command  CFLAGS : the C compiler flags (defaults to  -O3 ).  CPPFLAGS :  -I dir  flags to tell the C compiler additional places to look for header files.  LDFLAGS :  -L dir  flags to tell the linker additional places to look for libraries.  LIBS : additional libraries to link against.   Once compiled, the main program, as opposed to various test programs, resides in the  mpb-ctl/  subdirectory, and is called  mpb . You can install this program under  /usr/local  or elsewhere, if you used the  --prefix  flag for  configure , by running:  sudo\u00a0make\u00a0install  The \"sudo\" command is to switch to  root  for installation into system directories. You can just do  make install  if you are installing into your home directory instead.  If you make a mistake (e.g. you forget to specify a needed  -L dir  flag) or in general want to start over from a clean slate, you can restore MPB to a pristine state by running:  make\u00a0distclean", 
            "title": "MPB"
        }, 
        {
            "location": "/Scheme_Tutorial/", 
            "text": "Scheme Tutorial\n\n\nIn this section, we'll walk through the process of computing the band structure and outputting some fields for a two-dimensional photonic crystal using MPB. This should give you the basic idea of how it works and some of the things that are possible. Here, we tell you the truth, but not the whole truth. The \nUser Interface\n section gives a more complete, but less colloquial, description of the features supported by Photonic-Bands. See also the \ndata analysis tutorial\n for more examples, focused on analyzing and visualizing the results of MPB calculations.\n\n\nTable of Contents\n\n\nScheme Tutorial\n\n\nThe ctl File\n\n\nOur First Band Structure\n\n\nA Few Words on Units\n\n\nBands of a Triangular Lattice\n\n\nMaximizing the First TM Gap\n\n\nA Complete 2D Gap with an Anisotropic Dielectric\n\n\nFinding a Point-defect State\n\n\nTuning the Point-defect Mode\n\n\nEditors and ctl\n\n\n\n\n\n\nThe ctl File\n\n\nThe use of the MPB revolves around the control file, abbreviated \"ctl\" and typically called something like \nfoo.ctl\n (although you can use any filename extension you wish). The ctl file specifies the geometry you wish to study, the number of eigenvectors to compute, what to output, and everything else specific to your calculation. Rather than a flat, inflexible file format, however, the ctl file is actually written in a scripting language. This means that it can be everything from a simple sequence of commands setting the geometry, etcetera, to a full-fledged program with user input, loops, and anything else that you might need.\n\n\nDon't worry, though\u2014simple things are simple and even there you will appreciate the flexibility that a scripting language gives you. (e.g. you can input things in any order, without regard for whitespace, insert comments where you please, omit things when reasonable defaults are available...)\n\n\nThe ctl file is actually implemented on top of the libctl library, a set of utilities that are in turn built on top of the Scheme language. Thus, there are three sources of possible commands and syntax for a ctl file:\n\n\n\n\nScheme\n, a powerful and beautiful programming language developed at MIT, which has a particularly simple syntax: all statements are of the form \n(function arguments...)\n. We run Scheme under the GNU Guile interpreter which is designed to be plugged into programs as a scripting and extension language. You don't need to learn much Scheme for a basic ctl file, but it is always there if you need it. You can learn more about \nGuile and Scheme\n.\n\n\nlibctl, a library that we built on top of Guile to simplify communication between Scheme and scientific computation software. libctl sets the basic tone of the user interface and defines a number of useful functions. See the \nlibctl\n pages.\n\n\nMPB which defines all the interface features that are specific to photonic band structure calculations. This manual is primarily focused on documenting these features.\n\n\n\n\nIt would be an excellent idea at this point for you to go read the \nlibctl manual\n, particularly the \nBasic User Experience\n, which will give you an overview of what the user interface is like, provide a crash course in the Scheme features that are most useful here, and describe some useful general features. We're not going to repeat this material much, so learn it now!\n\n\nOkay, let's continue with our tutorial. MPB is normally invoked by running something like:\n\n\nunix%\u00a0mpb\u00a0foo.ctl\u00a0\n\u00a0foo.out\n\n\n\n\nwhich reads the ctl file \nfoo.ctl\n and executes it, saving the output to the file \nfoo.out\n. Some sample ctl files are provided in the \nmpb-ctl/examples/\n directory. However, as you already know (since you obediently read the libctl manual, right?), if you invoke \nmpb\n with no arguments, you are dropped into an \ninteractive\n mode in which you can type commands and see their results immediately. Why don't you do that right now, in your terminal window? Then, you can paste in the commands from the tutorial as you follow it and see what they do.\n\n\nOur First Band Structure\n\n\nAs our beginning example, we'll compute the band structure of a two-dimensional square lattice of dielectric rods in air. See \nour online textbook\n, ch. 5. In our control file, we'll first specify the parameters and geometry of the simulation, and then tell it to run and give us the output.\n\n\nAll of the parameters, each of which corresponds to a Scheme variable, have default setting, so we only need to specify the ones we need to change. For a complete listing of the parameter variables and their current values, along with some other info, type \n(help)\n at the \nguile\n prompt. One of the parameters, \nnum-bands\n, controls how many bands (eigenstates) are computed at each k point. If you type \nnum-bands\n at the prompt, it will return the current value, \n1\n--this is too small; let's set it to a larger value:\n\n\n(set!\u00a0num-bands\u00a08)\n\n\n\n\nThis is how we change the value of variables in Scheme. If you type \nnum-bands\n now, it will return \n8\n. The next thing we want to set although the order really doesn't matter, is the set of k points (Bloch wavevectors) we want to compute the bands at. This is controlled by the variable \nk-points\n, a list of 3-vectors which is initially empty. We'll set it to the corners of the irreducible Brillouin zone of a square lattice, Gamma, X, M, and Gamma again:\n\n\n(set!\u00a0k-points\u00a0(list\u00a0(vector3\u00a00\u00a00\u00a00)\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0Gamma\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00.5\u00a00\u00a00)\u00a0\u00a0\u00a0;\u00a0X\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00.5\u00a00.5\u00a00)\u00a0;\u00a0M\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00\u00a00)))\u00a0\u00a0\u00a0;\u00a0Gamma\n\n\n\n\nNotice how we construct a list, and how we make 3-vectors; notice also how we can break things into multiple lines if we want, and that a semicolon (';') marks the start of a comment. Typically, we'll want to also compute the bands at a lot of intermediate k points, so that we see the continuous band structure. Instead of manually specifying all of these intermediate points, however, we can just call one of the functions provided by libctl to interpolate them for us:\n\n\n(set!\u00a0k-points\u00a0(interpolate\u00a04\u00a0k-points))\n\n\n\n\nThis takes the \nk-points\n and linearly interpolates four new points between each pair of consecutive points. If we type \nk-points\n now at the prompt, it will show us all 16 points in the new list:\n\n\n(#(0\u00a00\u00a00)\u00a0#(0.1\u00a00.0\u00a00.0)\u00a0#(0.2\u00a00.0\u00a00.0)\u00a0#(0.3\u00a00.0\u00a00.0)\u00a0#(0.4\u00a00.0\u00a00.0)\u00a0#(0.5\u00a00\u00a00)\u00a0#(0.5\u00a00.1\u00a00.0)\u00a0#(0.5\u00a00.2\u00a00.0)\u00a0#(0.5\u00a00.3\u00a00.0)\u00a0#(0.5\u00a00.4\u00a00.0)\u00a0#(0.5\u00a00.5\u00a00)\u00a0#(0.4\u00a00.4\u00a00.0)\u00a0#(0.3\u00a00.3\u00a00.0)\u00a0#(0.2\u00a00.2\u00a00.0)\u00a0#(0.1\u00a00.1\u00a00.0)\u00a0#(0\u00a00\u00a00))\n\n\n\n\nAlternatively, you can use \n(set! k-points (kinterpolate-uniform 4 k-points))\n to interpolate points that are roughly uniformly spaced in \nk\n space (i.e. it will use a variable number of points between each pair of vectors to keep the spacing roughly equal).\n\n\nAs is \ndescribed below\n, all spatial vectors in the program are specified in the basis of the lattice directions normalized to \nbasis-size\n lengths. The default is unit-normalized. The k points are specified in the basis of the (unnormalized) reciprocal lattice vectors. In this case, we don't have to specify the lattice directions, because we are happy with the defaults--the lattice vectors default to the Cartesian unit axes (i.e. the most common case, a square/cubic lattice). The reciprocal lattice vectors in this case are also the unit axes. We'll see how to change the lattice vectors in later subsections.\n\n\nNow, we want to set the geometry of the system--we need to specify which objects are in the primitive cell of the lattice, centered on the origin. This is controlled by the variable \ngeometry\n, which is a list of geometric objects. As you know from reading the libctl documentation, objects, which are more complicated, structured data types, are created by statements of the form \n(make type (property1 value1) (property2 value2) ...)\n. There are various kinds (sub-classes) of geometric object: cylinders, spheres, blocks, ellipsoids, and perhaps others in the future. Right now, we want a square lattice of rods, so we put a single dielectric cylinder at the origin:\n\n\n(set!\u00a0geometry\u00a0(list\u00a0(make\u00a0cylinder\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(center\u00a00\u00a00\u00a00)\u00a0(radius\u00a00.2)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0(make\u00a0dielectric\u00a0(epsilon\u00a012))))))\n\n\n\n\nHere, we've set several properties of the cylinder: the \ncenter\n is the origin, its \nradius\n is 0.2, and its \nheight\n (the length along its axis) is \ninfinity\n. Another property, the \nmaterial\n, it itself an object--we made it a dielectric with the property that its \nepsilon\n is 12. There is another property of the cylinder that we can set, the direction of its axis, but we're happy with the default value of pointing in the z direction.\n\n\nAll of the geometric objects are ostensibly three-dimensional, but since we're doing a two-dimensional simulation the only thing that matters is their intersection with the xy plane (z=0). Speaking of which, let us set the dimensionality of the system. Normally, we do this when we define the size of the computational cell, controlled by the \ngeometry-lattice\n variable, an object of the \nlattice\n class: we can set some of the dimensions to have a size \nno-size\n, which reduces the dimensionality of the system.\n\n\n(set!\u00a0geometry-lattice\u00a0(make\u00a0lattice\u00a0(size\u00a01\u00a01\u00a0no-size)))\n\n\n\n\nHere, we define a 1x1 two-dimensional cell (defaulting to square). This cell is \ndiscretized\n according to the \nresolution\n variable, which defaults to \n10\n (pixels/lattice-unit). That's on the small side, and this is only a 2d calculation, so let's increase the resolution:\n\n\n(set!\u00a0resolution\u00a032)\n\n\n\n\nThis results in a 32x32 computational grid. For efficient calculation, it is best to make the grid sizes a power of two, or factorizable into powers of small primes (such as 2, 3, 5 and 7). As a rule of thumb, you should use a resolution of at least \n8\n in order to obtain reasonable accuracy.\n\n\nNow, we're done setting the parameters--there are other parameters, but we're happy with their default values for now. At this point, we're ready to go ahead and compute the band structure. The simplest way to do this is to type \n(run)\n. Since this is a two-dimensional calculation, however, we would like to split the bands up into TE- and TM-polarized modes, and we do this by invoking \n(run-te)\n and \n(run-tm)\n.\n\n\nThese produce a lot of output, showing you exactly what the code is doing as it runs. Most of this is self-explanatory, but we should point out one output in particular. Among the output, you should see lines like:\n\n\ntefreqs:,\u00a013,\u00a00.3,\u00a00.3,\u00a00,\u00a00.424264,\u00a00.372604,\u00a00.540287,\u00a00.644083,\u00a00.81406,\u00a00.828135,\u00a00.890673,\u00a01.01328,\u00a01.1124\n\n\n\n\nThese lines are designed to allow you to easily extract the band-structure information and import it into a spreadsheet for graphing. They comprise the k point index, the k components and magnitude, and the frequencies of the bands, in comma-delimited format. Each line is prefixed by \"tefreqs\" for TE bands, \"tmfreqs\" for TM bands, and \"freqs\" for ordinary bands produced by \n(run)\n. Using this prefix, you can extract the data you want from the output by passing it through a program like \ngrep\n. For example, if you had redirected the output to a file \nfoo.out\n as described earlier, you could extract the TM bands by running \ngrep tmfreqs foo.out\n at the terminal prompt. Note that the output includes a header line, like:\n\n\ntefreqs:,\u00a0k\u00a0index,\u00a0kx,\u00a0ky,\u00a0kz,\u00a0kmag/2pi,\u00a0band\u00a01,\u00a0band\u00a02,\u00a0band\u00a03,\u00a0band\u00a04,\u00a0band\u00a05,\u00a0band\u00a06,\u00a0band\u00a07,\u00a0band\u00a08\n\n\n\n\nexplaining each column of data. Another output of the \nrun\n is the list of band gaps detected in the computed bands. For example the \n(run-tm)\n output includes the following gap output:\n\n\nGap\u00a0from\u00a0band\u00a01\u00a0(0.282623311147724)\u00a0to\u00a0band\u00a02\u00a0(0.419334798706834),\u00a038.9514660888911%\nGap\u00a0from\u00a0band\u00a04\u00a0(0.715673834754345)\u00a0to\u00a0band\u00a05\u00a0(0.743682920649084),\u00a03.8385522650349%\n\n\n\n\nThis data is also stored in the variable \ngap-list\n, which is a list of \n(gap-percent gap-min gap-max)\n lists. It is important to realize, however, that this band-gap data may include \"false positives,\" from two possible sources:\n\n\n\n\nIf two bands cross, a false gap may result because the code computes the gap by assuming that bands never cross. Such false gaps are typically quite small (\n 1%). To be sure of what's going on, you should either look at the symmetry of the modes involved or compute k points very close to the crossing. Although even if the crossing occurs precisely at one of your k-points, there usually won't be an exact degeneracy for numerical reasons.\n\n\nOne typically computes band diagrams by considering k-points around the boundary of the irreducible Brillouin zone. It is possible, though rare, that the band edges may occur at points in the interior of the Brillouin zone. To be absolutely sure you have a band gap and of its size, you should compute the frequencies for points inside the Brillouin zone, too.\n\n\n\n\nYou've computed the band structure, and extracted the eigenfrequencies for each k point. But what if you want to see what the fields look like, or check that the dielectric function is what you expect? To do this, you need to output \nHDF5 files\n for these functions. HDF5 is a binary format for multi-dimensional scientific data, and can be read by many visualization programs. The output files have filenames with suffixes \".h5\".\n\n\nWhen you invoke one of the \nrun\n functions, the dielectric function in the unit cell is automatically written to the file \nepsilon.h5\n. To output the fields or other information, you need to pass one or more arguments to the \nrun\n function. For example:\n\n\n(run-tm\u00a0output-efield-z)\n(run-te\u00a0(output-at-kpoint\u00a0(vector3\u00a00.5\u00a00\u00a00)\u00a0output-hfield-z\u00a0output-dpwr))\n\n\n\n\nThis will output the electric (E) field z components for the TM bands at all k-points; and the magnetic (H) field z components and electric field energy densities (D power) for the TE bands at the X point only. The output filenames will be things like \ne.k12.b03.z.te.h5\n, which stands for the z component (\n.z\n) of the TE (\n.te\n) electric field (\ne\n) for the third band (\n.b03\n) of the twelfth k point (\n.k12\n). Each HDF5 file can contain multiple datasets. In this case, it will contain the real and imaginary parts of the field (in datasets \"z.r\" and \"z.i\"), and in general it may include other data too (e.g. \noutput-efield\n outputs all the components in one file). See also the \nData Analysis Tutorial\n.\n\n\nThere are several other output functions you can pass, described in the \nUser Interface\n, like \noutput-dfield\n, \noutput-hpwr\n, and \noutput-dpwr-in-objects\n. Actually, though, you can pass in arbitrary functions that can do much more than just output the fields--you can perform arbitrary analyses of the bands using functions that we will describe later.\n\n\nInstead of calling one of the \nrun\n functions, it is also possible to call lower-level functions of the code directly, to have a finer control of the computation. Such functions are described in the reference section.\n\n\nA Few Words on Units\n\n\nIn principle, you can use any units you want with MPB. Maxwell's equations possess an important property--they are \nscale-invariant\n. See \nour online textbook\n, ch. 2. If you multiply all of your sizes by 10, the solution scales are simply multiplied by 10 likewise while the frequencies are divided by 10. So, you can solve a problem once and apply that solution to all length-scales. For this reason, we usually pick some fundamental lengthscale \na\n of a structure, such as its lattice constant (unit of periodicity), and write all distances in terms of that. That is, we choose units so that \na\n is unity. Then, to apply to any physical system, one simply scales all distances by \na\n. This is what we have done in the preceding and following examples. This is the default behavior of MPB: the lattice constant is one, and all coordinates are scaled accordingly.\n\n\nAs has been mentioned already, nearly all 3-vectors in the program are specified in the \nbasis\n of the lattice vectors \nnormalized\n to lengths given by \nbasis-size\n, defaulting to the unit-normalized lattice vectors. That is, each component is multiplied by the corresponding basis vector and summed to compute the corresponding Cartesian vector. It is worth noting that a basis is not meaningful for scalar distances such as the cylinder radius. These are just the ordinary cartesian distances in your chosen units of \na\n.\n\n\nNote also that the \nk-points\n, as mentioned above, are an exception: they are in the basis of the reciprocal lattice vectors. See \nour online textbook\n, appendix B. If a given dimension has size \nno-size\n, its reciprocal lattice vector is taken to be 2\n/\na\n.\n\n\nWe provide \nconversion functions\n to transform vectors between the various bases.\n\n\nThe frequency eigenvalues returned by the program are in units of \nc/a\n, where \nc\n is the speed of light and \na\n is the unit of distance. Thus, the corresponding vacuum wavelength is \na\n over the frequency eigenvalue.\n\n\nBands of a Triangular Lattice\n\n\nAs a second example, we'll compute the TM band structure of a \ntriangular\n lattice of dielectric rods in air. To do this, we only need to change the lattice, controlled by the variable \ngeometry-lattice\n. We'll set it so that the first two basis vectors (the properties \nbasis1\n and \nbasis2\n) point 30 degrees above and below the x axis, instead of their default value of the x and y axes:\n\n\n(set!\u00a0geometry-lattice\u00a0(make\u00a0lattice\u00a0(size\u00a01\u00a01\u00a0no-size)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis1\u00a0(/\u00a0(sqrt\u00a03)\u00a02)\u00a00.5)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis2\u00a0(/\u00a0(sqrt\u00a03)\u00a02)\u00a0-0.5)))\n\n\n\n\nWe don't specify \nbasis3\n, keeping its default value of the z axis. Notice that Scheme supplies us with all the ordinary arithmetic operators and functions, but they use prefix (Polish) notation, in Scheme fashion. The \nbasis\n properties only specify the directions of the lattice basis vectors, and not their lengths--the lengths default to unity, which is fine here.\n\n\nThe irreducible Brillouin zone of a triangular lattice is different from that of a square lattice, so we'll need to modify the \nk-points\n list accordingly:\n\n\n(set!\u00a0k-points\u00a0(list\u00a0(vector3\u00a00\u00a00\u00a00)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0Gamma\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00.5\u00a00)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0M\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a0(/\u00a0-3)\u00a0(/\u00a03)\u00a00)\u00a0;\u00a0K\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00\u00a00)))\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0Gamma\n(set!\u00a0k-points\u00a0(interpolate\u00a04\u00a0k-points))\n\n\n\n\nNote that these vectors are in the basis of the new reciprocal lattice vectors, which are different from before. Notice also the Scheme shorthand \n(/\n \n3)\n, which is the same as \n(/\n \n1\n \n3)\n or 1/3.\n\n\nAll of the other parameters (\ngeometry\n, \nnum-bands\n, and \ngrid-size\n) can remain the same as in the previous subsection, so we can now call \n(run-tm)\n to compute the bands. As it turns out, this structure has an even larger TM gap than the square lattice:\n\n\nGap\u00a0from\u00a0band\u00a01\u00a0(0.275065617068082)\u00a0to\u00a0band\u00a02\u00a0(0.446289918847647),\u00a047.4729292989213%\n\n\n\n\nMaximizing the First TM Gap\n\n\nWe will now show you a more sophisticated example utilizing the programming capabilities of Scheme. We will write a script to choose the cylinder radius that maximizes the first TM gap of the triangular lattice of rods from above. All of the Scheme syntax here won't be explained, but this should give you a flavor of what is possible.\n\n\nFirst, we will write the function that want to maximize, a function that takes a dielectric constant and returns the size of the first TM gap. This function will change the geometry to reflect the new radius, run the calculation, and return the size of the first gap:\n\n\n(define\u00a0(first-tm-gap\u00a0r)\n\u00a0\u00a0(set!\u00a0geometry\u00a0(list\u00a0(make\u00a0cylinder\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(center\u00a00\u00a00\u00a00)\u00a0(radius\u00a0r)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0(make\u00a0dielectric\u00a0(epsilon\u00a012))))))\n\u00a0\u00a0(run-tm)\n\u00a0\u00a0(retrieve-gap\u00a01))\u00a0;\u00a0return\u00a0the\u00a0gap\u00a0from\u00a0TM\u00a0band\u00a01\u00a0to\u00a0TM\u00a0band\u00a02\n\n\n\n\nWe'll leave most of the other parameters the same as in the previous example, but we'll also change \nnum-bands\n to 2, since we only need to compute the first two bands:\n\n\n(set!\u00a0num-bands\u00a02)\n\n\n\n\nIn order to distinguish small differences in radius during the optimization, it might seem that we have to increase the grid resolution, slowing down the computation. Instead, we can simply increase the \nmesh\n resolution. This is the size of the mesh over which the dielectric constant is averaged at each grid point, and increasing the mesh size means that the average index better reflects small changes in the structure.\n\n\n(set!\u00a0mesh-size\u00a07)\u00a0;\u00a0increase\u00a0from\u00a0default\u00a0value\u00a0of\u00a03\n\n\n\n\nNow, we're ready to maximize our function \nfirst-tm-gap\n. We could write a loop to do this ourselves, but libctl provides a built-in function \n(maximize function tolerance arg-min arg-max)\n to do it for us using Brent's algorithm. So, we just tell it to find the maximum, searching in the range of radii from 0.1 to 0.5, with a tolerance of 0.1:\n\n\n(define\u00a0result\u00a0(maximize\u00a0first-tm-gap\u00a00.1\u00a00.1\u00a00.5))\n(print\u00a0\nradius\u00a0at\u00a0maximum:\u00a0\n\u00a0(max-arg\u00a0result)\u00a0\n\\n\n)\n(print\u00a0\ngap\u00a0size\u00a0at\u00a0maximum:\u00a0\n\u00a0(max-val\u00a0result)\u00a0\n\\n\n)\n\n\n\n\nprint\n is a function defined by libctl to apply the built-in \ndisplay\n function to zero or more arguments. After five iterations, the output is:\n\n\nradius\u00a0at\u00a0maximum:\u00a00.176393202250021\ngap\u00a0size\u00a0at\u00a0maximum:\u00a048.6252611051049\n\n\n\n\nThe tolerance of 0.1 that we specified means that the true maximum is within 0.1 * 0.176393202250021, or about 0.02, of the radius found here. It doesn't make much sense here to specify a lower tolerance, since the discretization of the grid means that the code can't accurately distinguish small differences in radius.\n\n\nBefore we continue, let's reset \nmesh-size\n to its default value:\n\n\n(set!\u00a0mesh-size\u00a03)\u00a0;\u00a0reset\u00a0to\u00a0default\u00a0value\u00a0of\u00a03\n\n\n\n\nA Complete 2D Gap with an Anisotropic Dielectric\n\n\nAs another example, one which does not require so much Scheme knowledge, let's construct a structure with a complete 2D gap (i.e., in both TE and TM polarizations), in a somewhat unusual way: using an \ndielectric\n structure. An anisotropic dielectric presents a different dielectric constant depending upon the direction of the electric field, and can be used in this case to make the TE and TM polarizations \"see\" different structures.\n\n\nWe already know that the triangular lattice of rods has a gap for TM light, but not for TE light. The dual structure, a triangular lattice of holes, has a gap for TE light but not for TM light at least for the small radii we will consider. Using an anisotropic dielectric, we can make both of these structures simultaneously, with each polarization seeing the structure that gives it a gap.\n\n\nAs before, our \ngeometry\n will consist of a single cylinder, this time with a radius of 0.3, but now it will have an epsilon of 12 (dielectric rod) for TM light and 1 (air hole) for TE light:\n\n\n(set!\u00a0geometry\u00a0(list\u00a0(make\u00a0cylinder\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(center\u00a00\u00a00\u00a00)\u00a0(radius\u00a00.3)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0(make\u00a0dielectric-anisotropic\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(epsilon-diag\u00a01\u00a01\u00a012))))))\n\n\n\n\nHere, \nepsilon-diag\n specifies the diagonal elements of the dielectric tensor. The off-diagonal elements specified by \nepsilon-offdiag\n default to zero and are only needed when the principal axes of the dielectric tensor are different from the Cartesian xyz axes.\n\n\nThe background defaults to air, but we need to make it a dielectric (epsilon of 12) for the TE light, so that the cylinder forms a hole. This is controlled via the \ndefault-material\n variable:\n\n\n(set!\u00a0default-material\u00a0(make\u00a0dielectric-anisotropic\u00a0(epsilon-diag\u00a012\u00a012\u00a01)))\n\n\n\n\nFinally, we'll increase the number of bands back to eight and run the computation:\n\n\n(set!\u00a0num-bands\u00a08)\n(run)\u00a0;\u00a0just\u00a0use\u00a0run,\u00a0instead\u00a0of\u00a0run-te\u00a0or\u00a0run-tm,\u00a0to\u00a0find\u00a0the\u00a0complete\u00a0gap\n\n\n\n\nThe result, as expected, is a complete band gap:\n\n\nGap\u00a0from\u00a0band\u00a02\u00a0(0.223977612336924)\u00a0to\u00a0band\u00a03\u00a0(0.274704473679751),\u00a020.3443687933601%\n\n\n\n\nIf we had computed the TM and TE bands separately, we would have found that the lower edge of the complete gap in this case comes from the TM gap, and the upper edge comes from the TE gap.\n\n\nFinding a Point-defect State\n\n\nHere, we consider the problem of finding a point-defect state in our square lattice of rods. This is a state that is localized in a small region by creating a point defect in the crystal \u2014 e.g., by removing a single rod. The resulting mode will have a frequency within, and be confined by, the gap. See \nour online textbook\n, ch. 5.\n\n\nTo compute this, we need a supercell of bulk crystal, within which to put the defect \u2014 we will use a 5x5 cell of rods. To do this, we must first increase the size of the lattice by five, and then add all of the rods. We create the lattice by:\n\n\n(set!\u00a0geometry-lattice\u00a0(make\u00a0lattice\u00a0(size\u00a05\u00a05\u00a0no-size)))\n\n\n\n\nHere, we have used the default orthogonal basis, but have changed the size of the cell. To populate the cell, we could specify all 25 rods manually, but that would be tedious. A better approach would be to write a loop but in fact this has already been done for you. MPB provides a function, \ngeometric-objects-lattice-duplicates\n, that duplicates a list of objects over the lattice:\n\n\n(set!\u00a0geometry\u00a0(list\u00a0(make\u00a0cylinder\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(center\u00a00\u00a00\u00a00)\u00a0(radius\u00a00.2)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0(make\u00a0dielectric\u00a0(epsilon\u00a012))))))\n(set!\u00a0geometry\u00a0(geometric-objects-lattice-duplicates\u00a0geometry))\n\n\n\n\nThere, now the \ngeometry\n list contains 25 rods \u2014 the original \ngeometry\n list, which contained one rod, duplicated over the 5x5 lattice.\n\n\nTo remove a rod, we'll just add another rod in the center of the cell with a dielectric constant of 1. When objects overlap, the later object in the list takes precedence, so we have to put the new rod at the end of \ngeometry\n:\n\n\n(set!\u00a0geometry\u00a0(append\u00a0geometry\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(list\u00a0(make\u00a0cylinder\u00a0(center\u00a00\u00a00\u00a00)\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(radius\u00a00.2)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0air)))))\n\n\n\n\nHere, we've used the Scheme \nappend\n function to combine two lists, and have also snuck in the predefined material type \nair\n which has an epsilon of 1.\n\n\nWe'll be frugal and use only 16 points per lattice unit, resulting in an 80x80 grid, instead of the 32 from before:\n\n\n(set!\u00a0resolution\u00a016)\n\n\n\n\nOnly a single k point is needed for a point-defect calculation which, for an infinite supercell, would be independent of k:\n\n\n(set!\u00a0k-points\u00a0(list\u00a0(vector3\u00a00.5\u00a00.5\u00a00)))\n\n\n\n\nUnfortunately, for a supercell the original bands are folded many times over, in this case, 25 times, so we need to compute many more bands to reach the same frequencies:\n\n\n(set!\u00a0num-bands\u00a050)\n\n\n\n\nAt this point, we can call \n(run-tm)\n to solve for the TM bands. It will take several seconds to compute. Recall that the gap for this structure was for the frequency range 0.2812 to 0.4174. The bands of the solution include exactly one state in this frequency range: band 25, with a frequency of 0.378166. This is exactly what we should expect--the lowest band was folded 25 times into the supercell Brillouin zone, but one of these states was pushed up into the gap by the defect.\n\n\nWe haven't yet output any of the fields, but we don't have to repeat the run to do so. The fields from the last k-point computation remain in memory and can continue to be accessed and analyzed. For example, to output the electric field z component of band 25, we just do:\n\n\n(output-efield-z\u00a025)\n\n\n\n\nThat's right, the output functions that we passed to \n(run)\n in the first example are just functions of the band index that are called on each band. We can do other computations too, like compute the fraction of the electric field energy near the defect cylinder within a radius 1.0 of the origin:\n\n\n(get-dfield\u00a025)\u00a0\u00a0;\u00a0compute\u00a0the\u00a0D\u00a0field\u00a0for\u00a0band\u00a025\n(compute-field-energy)\u00a0\u00a0;\u00a0compute\u00a0the\u00a0energy\u00a0density\u00a0from\u00a0D\n(print\n\u00a0\nenergy\u00a0in\u00a0cylinder:\u00a0\n\n\u00a0(compute-energy-in-objects\u00a0(make\u00a0cylinder\u00a0(center\u00a00\u00a00\u00a00)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(radius\u00a01.0)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0air)))\n\u00a0\n\\n\n)\n\n\n\n\nThe result is 0.624794702341156, or over 62% of the field energy in this localized region; the field decays exponentially into the bulk crystal. The full range of available functions is described in the \nUser Interface\n, but the typical sequence is to first load a field with a \nget-\n function and then to call other functions to perform computations and transformations on it.\n\n\nNote that the \ncompute-energy-in-objects\n returns the energy fraction, but does not itself print this value. This is fine when you are running interactively, in which case Guile always displays the result of the last expression, but when running as part of a script you need to explicitly print the result as we have done above with the \nprint\n function. The \"\\n\" string is newline character (like in C), to put subsequent output on a separate line.\n\n\nInstead of computing all those bands, we can instead take advantage of a special feature of MPB that allows you to compute the bands closest to a \"target\" frequency, rather than the bands with the lowest frequencies. One uses this feature by setting the \ntarget-freq\n variable to something other than zero (e.g. the mid-gap frequency). In order to get accurate results, it's currently also recommended that you decrease the \ntolerance\n variable, which controls when convergence is judged to have occurred, from its default value of \n1e-7\n:\n\n\n(set!\u00a0num-bands\u00a01)\u00a0\u00a0;\u00a0only\u00a0need\u00a0to\u00a0compute\u00a0a\u00a0single\u00a0band,\u00a0now!\n(set!\u00a0target-freq\u00a0(/\u00a0(+\u00a00.2812\u00a00.4174)\u00a02))\n(set!\u00a0tolerance\u00a01e-8)\n\n\n\n\nNow, we just call \n(run-tm)\n as before. Convergence requires more iterations this time, both because we've decreased the tolerance and because of the nature of the eigenproblem that is now being solved, but only by about 3-4 times in this case. Since we now have to compute only a single band, however, we arrive at an answer much more quickly than before. The result, of course, is again the defect band, with a frequency of 0.378166.\n\n\nTuning the Point-defect Mode\n\n\nAs another example utilizing the programming capability of Scheme, we will write a script to \"tune\" the defect mode to a particular frequency. Instead of forming a defect by simply removing a rod, we can decrease the radius or the dielectric constant of the defect rod, thereby changing the corresponding mode frequency. In this case, we'll vary the dielectric constant, and try to find a mode with a frequency of, say, 0.314159 (a random number).\n\n\nWe could write a loop to search for this epsilon, but instead we'll use a root-finding function provided by libctl, \n(find-root function tolerance arg-min arg-max)\n, that will solve the problem for us using a quadratically-convergent algorithm (Ridder's method). First, we need to define a function that takes an epsilon for the center rod and returns the mode frequency minus 0.314159; this is the function we'll be finding the root of:\n\n\n(define\u00a0old-geometry\u00a0geometry)\u00a0;\u00a0save\u00a0the\u00a05x5\u00a0grid\u00a0with\u00a0a\u00a0missing\u00a0rod\n(define\u00a0(rootfun\u00a0eps)\n\u00a0\u00a0;\u00a0add\u00a0the\u00a0cylinder\u00a0of\u00a0epsilon\u00a0=\u00a0eps\u00a0to\u00a0the\u00a0old\u00a0geometry:\n\u00a0\u00a0(set!\u00a0geometry\u00a0(append\u00a0old-geometry\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(list\u00a0(make\u00a0cylinder\u00a0(center\u00a00\u00a00\u00a00)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(radius\u00a00.2)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0(make\u00a0dielectric\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(epsilon\u00a0eps)))))))\n\u00a0\u00a0(run-tm)\u00a0\u00a0;\u00a0solve\u00a0for\u00a0the\u00a0mode\u00a0(using\u00a0the\u00a0targeted\u00a0solver)\n\u00a0\u00a0(print\u00a0\nepsilon\u00a0=\u00a0\n\u00a0eps\u00a0\n\u00a0gives\u00a0freq.\u00a0=\u00a0\n\u00a0(list-ref\u00a0freqs\u00a00)\u00a0\n\\n\n)\n\u00a0\u00a0(-\u00a0(list-ref\u00a0freqs\u00a00)\u00a00.314159))\u00a0\u00a0;\u00a0return\u00a01st\u00a0band\u00a0freq.\u00a0-\u00a00.314159\n\n\n\n\nNow, we can solve for epsilon, searching in the range 1 to 12, with a fractional tolerance of 0.01, by:\n\n\n(define\u00a0rooteps\u00a0(find-root\u00a0rootfun\u00a00.01\u00a01\u00a012))\n(print\u00a0\nroot\u00a0(value\u00a0of\u00a0epsilon)\u00a0is\u00a0at:\u00a0\n\u00a0rooteps\u00a0\n\\n\n)\n\n\n\n\nThe sequence of dielectric constants that it tries, along with the corresponding mode frequencies, is:\n\n\n\n\n\n\n\n\n\nepsilon\n\n\nfrequency\n\n\n\n\n\n\n\n\n\n\n1\n\n\n0.378165893321125\n\n\n\n\n\n\n12\n\n\n0.283987088221692\n\n\n\n\n\n\n6.5\n\n\n0.302998920718043\n\n\n\n\n\n\n5.14623274327171\n\n\n0.317371748739314\n\n\n\n\n\n\n5.82311637163586\n\n\n0.309702408341706\n\n\n\n\n\n\n5.41898003340128\n\n\n0.314169110036439\n\n\n\n\n\n\n5.62104820251857\n\n\n0.311893530112625\n\n\n\n\n\n\n\n\n\n\nThe final answer that it returns is an epsilon of 5.41986120170136. Interestingly enough, the algorithm doesn't actually evaluate the function at the final point. You have to do so yourself if you want to find out how close it is to the root. Ridder's method successively reduces the interval bracketing the root by alternating bisection and interpolation steps. At the end, it does one last interpolation to give you its best guess for the root location within the current interval. If we go ahead and evaluate the band frequency at this dielectric constant, calling \n(rootfun rooteps)\n, we find that it is 0.314159008193209, matching our desired frequency to nearly eight decimal places after seven function evaluations! Of course, the computation isn't really this accurate anyway, due to the finite discretization.\n\n\nA slight improvement can be made to the calculation above. Ordinarily, each time you call the \n(run-tm)\n function, the fields are initialized to random values. It would speed convergence somewhat to use the fields of the previous calculation as the starting point for the next calculation. We can do this by instead calling a lower-level function, \n(run-parity TM false)\n. The first parameter is the polarization to solve for, and the second tells it not to reset the fields if possible.\n\n\nEditors and ctl\n\n\nIt is useful to have \nemacs\n use its \nscheme-mode\n for editing ctl files, so that hitting tab indents nicely, and so on. \nemacs\n does this automatically for files ending with \".scm\"; to do it for files ending with \".ctl\" as well, add the following lines to your \n~/.emacs\n file:\n\n\n (push '(\n\\\\.ctl\\\\'\n . scheme-mode) auto-mode-alist)\n\n\n\n\nor if your \nemacs\n version is 24.3 or earlier and you have other \".ctl\" files which are not Scheme:\n\n\n (if (assoc \n\\\\.ctl\n auto-mode-alist)\n       nil\n         (add-to-list 'auto-mode-alist '(\n\\\\.ctl\\\\'\n . scheme-mode))))\n\n\n\n\nIncidentally, \nemacs\n scripts are written in \"elisp,\" a language closely related to Scheme.\n\n\nIf you don't use emacs (or derivatives such as Aquamacs), it would be good to find another editor that supports a Scheme mode.  For example, \njEdit\n is a free/open-source cross-platform editor with Scheme-syntax support.  Another option is \ngedit\n. One of our users has donated a \nhilighting mode for Meep/MPB\n that specially highlights the Meep/MPB keywords.", 
            "title": "Scheme Tutorial"
        }, 
        {
            "location": "/Scheme_Tutorial/#the-ctl-file", 
            "text": "The use of the MPB revolves around the control file, abbreviated \"ctl\" and typically called something like  foo.ctl  (although you can use any filename extension you wish). The ctl file specifies the geometry you wish to study, the number of eigenvectors to compute, what to output, and everything else specific to your calculation. Rather than a flat, inflexible file format, however, the ctl file is actually written in a scripting language. This means that it can be everything from a simple sequence of commands setting the geometry, etcetera, to a full-fledged program with user input, loops, and anything else that you might need.  Don't worry, though\u2014simple things are simple and even there you will appreciate the flexibility that a scripting language gives you. (e.g. you can input things in any order, without regard for whitespace, insert comments where you please, omit things when reasonable defaults are available...)  The ctl file is actually implemented on top of the libctl library, a set of utilities that are in turn built on top of the Scheme language. Thus, there are three sources of possible commands and syntax for a ctl file:   Scheme , a powerful and beautiful programming language developed at MIT, which has a particularly simple syntax: all statements are of the form  (function arguments...) . We run Scheme under the GNU Guile interpreter which is designed to be plugged into programs as a scripting and extension language. You don't need to learn much Scheme for a basic ctl file, but it is always there if you need it. You can learn more about  Guile and Scheme .  libctl, a library that we built on top of Guile to simplify communication between Scheme and scientific computation software. libctl sets the basic tone of the user interface and defines a number of useful functions. See the  libctl  pages.  MPB which defines all the interface features that are specific to photonic band structure calculations. This manual is primarily focused on documenting these features.   It would be an excellent idea at this point for you to go read the  libctl manual , particularly the  Basic User Experience , which will give you an overview of what the user interface is like, provide a crash course in the Scheme features that are most useful here, and describe some useful general features. We're not going to repeat this material much, so learn it now!  Okay, let's continue with our tutorial. MPB is normally invoked by running something like:  unix%\u00a0mpb\u00a0foo.ctl\u00a0 \u00a0foo.out  which reads the ctl file  foo.ctl  and executes it, saving the output to the file  foo.out . Some sample ctl files are provided in the  mpb-ctl/examples/  directory. However, as you already know (since you obediently read the libctl manual, right?), if you invoke  mpb  with no arguments, you are dropped into an  interactive  mode in which you can type commands and see their results immediately. Why don't you do that right now, in your terminal window? Then, you can paste in the commands from the tutorial as you follow it and see what they do.", 
            "title": "The ctl File"
        }, 
        {
            "location": "/Scheme_Tutorial/#our-first-band-structure", 
            "text": "As our beginning example, we'll compute the band structure of a two-dimensional square lattice of dielectric rods in air. See  our online textbook , ch. 5. In our control file, we'll first specify the parameters and geometry of the simulation, and then tell it to run and give us the output.  All of the parameters, each of which corresponds to a Scheme variable, have default setting, so we only need to specify the ones we need to change. For a complete listing of the parameter variables and their current values, along with some other info, type  (help)  at the  guile  prompt. One of the parameters,  num-bands , controls how many bands (eigenstates) are computed at each k point. If you type  num-bands  at the prompt, it will return the current value,  1 --this is too small; let's set it to a larger value:  (set!\u00a0num-bands\u00a08)  This is how we change the value of variables in Scheme. If you type  num-bands  now, it will return  8 . The next thing we want to set although the order really doesn't matter, is the set of k points (Bloch wavevectors) we want to compute the bands at. This is controlled by the variable  k-points , a list of 3-vectors which is initially empty. We'll set it to the corners of the irreducible Brillouin zone of a square lattice, Gamma, X, M, and Gamma again:  (set!\u00a0k-points\u00a0(list\u00a0(vector3\u00a00\u00a00\u00a00)\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0Gamma\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00.5\u00a00\u00a00)\u00a0\u00a0\u00a0;\u00a0X\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00.5\u00a00.5\u00a00)\u00a0;\u00a0M\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00\u00a00)))\u00a0\u00a0\u00a0;\u00a0Gamma  Notice how we construct a list, and how we make 3-vectors; notice also how we can break things into multiple lines if we want, and that a semicolon (';') marks the start of a comment. Typically, we'll want to also compute the bands at a lot of intermediate k points, so that we see the continuous band structure. Instead of manually specifying all of these intermediate points, however, we can just call one of the functions provided by libctl to interpolate them for us:  (set!\u00a0k-points\u00a0(interpolate\u00a04\u00a0k-points))  This takes the  k-points  and linearly interpolates four new points between each pair of consecutive points. If we type  k-points  now at the prompt, it will show us all 16 points in the new list:  (#(0\u00a00\u00a00)\u00a0#(0.1\u00a00.0\u00a00.0)\u00a0#(0.2\u00a00.0\u00a00.0)\u00a0#(0.3\u00a00.0\u00a00.0)\u00a0#(0.4\u00a00.0\u00a00.0)\u00a0#(0.5\u00a00\u00a00)\u00a0#(0.5\u00a00.1\u00a00.0)\u00a0#(0.5\u00a00.2\u00a00.0)\u00a0#(0.5\u00a00.3\u00a00.0)\u00a0#(0.5\u00a00.4\u00a00.0)\u00a0#(0.5\u00a00.5\u00a00)\u00a0#(0.4\u00a00.4\u00a00.0)\u00a0#(0.3\u00a00.3\u00a00.0)\u00a0#(0.2\u00a00.2\u00a00.0)\u00a0#(0.1\u00a00.1\u00a00.0)\u00a0#(0\u00a00\u00a00))  Alternatively, you can use  (set! k-points (kinterpolate-uniform 4 k-points))  to interpolate points that are roughly uniformly spaced in  k  space (i.e. it will use a variable number of points between each pair of vectors to keep the spacing roughly equal).  As is  described below , all spatial vectors in the program are specified in the basis of the lattice directions normalized to  basis-size  lengths. The default is unit-normalized. The k points are specified in the basis of the (unnormalized) reciprocal lattice vectors. In this case, we don't have to specify the lattice directions, because we are happy with the defaults--the lattice vectors default to the Cartesian unit axes (i.e. the most common case, a square/cubic lattice). The reciprocal lattice vectors in this case are also the unit axes. We'll see how to change the lattice vectors in later subsections.  Now, we want to set the geometry of the system--we need to specify which objects are in the primitive cell of the lattice, centered on the origin. This is controlled by the variable  geometry , which is a list of geometric objects. As you know from reading the libctl documentation, objects, which are more complicated, structured data types, are created by statements of the form  (make type (property1 value1) (property2 value2) ...) . There are various kinds (sub-classes) of geometric object: cylinders, spheres, blocks, ellipsoids, and perhaps others in the future. Right now, we want a square lattice of rods, so we put a single dielectric cylinder at the origin:  (set!\u00a0geometry\u00a0(list\u00a0(make\u00a0cylinder\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(center\u00a00\u00a00\u00a00)\u00a0(radius\u00a00.2)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0(make\u00a0dielectric\u00a0(epsilon\u00a012))))))  Here, we've set several properties of the cylinder: the  center  is the origin, its  radius  is 0.2, and its  height  (the length along its axis) is  infinity . Another property, the  material , it itself an object--we made it a dielectric with the property that its  epsilon  is 12. There is another property of the cylinder that we can set, the direction of its axis, but we're happy with the default value of pointing in the z direction.  All of the geometric objects are ostensibly three-dimensional, but since we're doing a two-dimensional simulation the only thing that matters is their intersection with the xy plane (z=0). Speaking of which, let us set the dimensionality of the system. Normally, we do this when we define the size of the computational cell, controlled by the  geometry-lattice  variable, an object of the  lattice  class: we can set some of the dimensions to have a size  no-size , which reduces the dimensionality of the system.  (set!\u00a0geometry-lattice\u00a0(make\u00a0lattice\u00a0(size\u00a01\u00a01\u00a0no-size)))  Here, we define a 1x1 two-dimensional cell (defaulting to square). This cell is  discretized  according to the  resolution  variable, which defaults to  10  (pixels/lattice-unit). That's on the small side, and this is only a 2d calculation, so let's increase the resolution:  (set!\u00a0resolution\u00a032)  This results in a 32x32 computational grid. For efficient calculation, it is best to make the grid sizes a power of two, or factorizable into powers of small primes (such as 2, 3, 5 and 7). As a rule of thumb, you should use a resolution of at least  8  in order to obtain reasonable accuracy.  Now, we're done setting the parameters--there are other parameters, but we're happy with their default values for now. At this point, we're ready to go ahead and compute the band structure. The simplest way to do this is to type  (run) . Since this is a two-dimensional calculation, however, we would like to split the bands up into TE- and TM-polarized modes, and we do this by invoking  (run-te)  and  (run-tm) .  These produce a lot of output, showing you exactly what the code is doing as it runs. Most of this is self-explanatory, but we should point out one output in particular. Among the output, you should see lines like:  tefreqs:,\u00a013,\u00a00.3,\u00a00.3,\u00a00,\u00a00.424264,\u00a00.372604,\u00a00.540287,\u00a00.644083,\u00a00.81406,\u00a00.828135,\u00a00.890673,\u00a01.01328,\u00a01.1124  These lines are designed to allow you to easily extract the band-structure information and import it into a spreadsheet for graphing. They comprise the k point index, the k components and magnitude, and the frequencies of the bands, in comma-delimited format. Each line is prefixed by \"tefreqs\" for TE bands, \"tmfreqs\" for TM bands, and \"freqs\" for ordinary bands produced by  (run) . Using this prefix, you can extract the data you want from the output by passing it through a program like  grep . For example, if you had redirected the output to a file  foo.out  as described earlier, you could extract the TM bands by running  grep tmfreqs foo.out  at the terminal prompt. Note that the output includes a header line, like:  tefreqs:,\u00a0k\u00a0index,\u00a0kx,\u00a0ky,\u00a0kz,\u00a0kmag/2pi,\u00a0band\u00a01,\u00a0band\u00a02,\u00a0band\u00a03,\u00a0band\u00a04,\u00a0band\u00a05,\u00a0band\u00a06,\u00a0band\u00a07,\u00a0band\u00a08  explaining each column of data. Another output of the  run  is the list of band gaps detected in the computed bands. For example the  (run-tm)  output includes the following gap output:  Gap\u00a0from\u00a0band\u00a01\u00a0(0.282623311147724)\u00a0to\u00a0band\u00a02\u00a0(0.419334798706834),\u00a038.9514660888911%\nGap\u00a0from\u00a0band\u00a04\u00a0(0.715673834754345)\u00a0to\u00a0band\u00a05\u00a0(0.743682920649084),\u00a03.8385522650349%  This data is also stored in the variable  gap-list , which is a list of  (gap-percent gap-min gap-max)  lists. It is important to realize, however, that this band-gap data may include \"false positives,\" from two possible sources:   If two bands cross, a false gap may result because the code computes the gap by assuming that bands never cross. Such false gaps are typically quite small (  1%). To be sure of what's going on, you should either look at the symmetry of the modes involved or compute k points very close to the crossing. Although even if the crossing occurs precisely at one of your k-points, there usually won't be an exact degeneracy for numerical reasons.  One typically computes band diagrams by considering k-points around the boundary of the irreducible Brillouin zone. It is possible, though rare, that the band edges may occur at points in the interior of the Brillouin zone. To be absolutely sure you have a band gap and of its size, you should compute the frequencies for points inside the Brillouin zone, too.   You've computed the band structure, and extracted the eigenfrequencies for each k point. But what if you want to see what the fields look like, or check that the dielectric function is what you expect? To do this, you need to output  HDF5 files  for these functions. HDF5 is a binary format for multi-dimensional scientific data, and can be read by many visualization programs. The output files have filenames with suffixes \".h5\".  When you invoke one of the  run  functions, the dielectric function in the unit cell is automatically written to the file  epsilon.h5 . To output the fields or other information, you need to pass one or more arguments to the  run  function. For example:  (run-tm\u00a0output-efield-z)\n(run-te\u00a0(output-at-kpoint\u00a0(vector3\u00a00.5\u00a00\u00a00)\u00a0output-hfield-z\u00a0output-dpwr))  This will output the electric (E) field z components for the TM bands at all k-points; and the magnetic (H) field z components and electric field energy densities (D power) for the TE bands at the X point only. The output filenames will be things like  e.k12.b03.z.te.h5 , which stands for the z component ( .z ) of the TE ( .te ) electric field ( e ) for the third band ( .b03 ) of the twelfth k point ( .k12 ). Each HDF5 file can contain multiple datasets. In this case, it will contain the real and imaginary parts of the field (in datasets \"z.r\" and \"z.i\"), and in general it may include other data too (e.g.  output-efield  outputs all the components in one file). See also the  Data Analysis Tutorial .  There are several other output functions you can pass, described in the  User Interface , like  output-dfield ,  output-hpwr , and  output-dpwr-in-objects . Actually, though, you can pass in arbitrary functions that can do much more than just output the fields--you can perform arbitrary analyses of the bands using functions that we will describe later.  Instead of calling one of the  run  functions, it is also possible to call lower-level functions of the code directly, to have a finer control of the computation. Such functions are described in the reference section.", 
            "title": "Our First Band Structure"
        }, 
        {
            "location": "/Scheme_Tutorial/#a-few-words-on-units", 
            "text": "In principle, you can use any units you want with MPB. Maxwell's equations possess an important property--they are  scale-invariant . See  our online textbook , ch. 2. If you multiply all of your sizes by 10, the solution scales are simply multiplied by 10 likewise while the frequencies are divided by 10. So, you can solve a problem once and apply that solution to all length-scales. For this reason, we usually pick some fundamental lengthscale  a  of a structure, such as its lattice constant (unit of periodicity), and write all distances in terms of that. That is, we choose units so that  a  is unity. Then, to apply to any physical system, one simply scales all distances by  a . This is what we have done in the preceding and following examples. This is the default behavior of MPB: the lattice constant is one, and all coordinates are scaled accordingly.  As has been mentioned already, nearly all 3-vectors in the program are specified in the  basis  of the lattice vectors  normalized  to lengths given by  basis-size , defaulting to the unit-normalized lattice vectors. That is, each component is multiplied by the corresponding basis vector and summed to compute the corresponding Cartesian vector. It is worth noting that a basis is not meaningful for scalar distances such as the cylinder radius. These are just the ordinary cartesian distances in your chosen units of  a .  Note also that the  k-points , as mentioned above, are an exception: they are in the basis of the reciprocal lattice vectors. See  our online textbook , appendix B. If a given dimension has size  no-size , its reciprocal lattice vector is taken to be 2 / a .  We provide  conversion functions  to transform vectors between the various bases.  The frequency eigenvalues returned by the program are in units of  c/a , where  c  is the speed of light and  a  is the unit of distance. Thus, the corresponding vacuum wavelength is  a  over the frequency eigenvalue.", 
            "title": "A Few Words on Units"
        }, 
        {
            "location": "/Scheme_Tutorial/#bands-of-a-triangular-lattice", 
            "text": "As a second example, we'll compute the TM band structure of a  triangular  lattice of dielectric rods in air. To do this, we only need to change the lattice, controlled by the variable  geometry-lattice . We'll set it so that the first two basis vectors (the properties  basis1  and  basis2 ) point 30 degrees above and below the x axis, instead of their default value of the x and y axes:  (set!\u00a0geometry-lattice\u00a0(make\u00a0lattice\u00a0(size\u00a01\u00a01\u00a0no-size)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis1\u00a0(/\u00a0(sqrt\u00a03)\u00a02)\u00a00.5)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis2\u00a0(/\u00a0(sqrt\u00a03)\u00a02)\u00a0-0.5)))  We don't specify  basis3 , keeping its default value of the z axis. Notice that Scheme supplies us with all the ordinary arithmetic operators and functions, but they use prefix (Polish) notation, in Scheme fashion. The  basis  properties only specify the directions of the lattice basis vectors, and not their lengths--the lengths default to unity, which is fine here.  The irreducible Brillouin zone of a triangular lattice is different from that of a square lattice, so we'll need to modify the  k-points  list accordingly:  (set!\u00a0k-points\u00a0(list\u00a0(vector3\u00a00\u00a00\u00a00)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0Gamma\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00.5\u00a00)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0M\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a0(/\u00a0-3)\u00a0(/\u00a03)\u00a00)\u00a0;\u00a0K\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00\u00a00)))\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0Gamma\n(set!\u00a0k-points\u00a0(interpolate\u00a04\u00a0k-points))  Note that these vectors are in the basis of the new reciprocal lattice vectors, which are different from before. Notice also the Scheme shorthand  (/   3) , which is the same as  (/   1   3)  or 1/3.  All of the other parameters ( geometry ,  num-bands , and  grid-size ) can remain the same as in the previous subsection, so we can now call  (run-tm)  to compute the bands. As it turns out, this structure has an even larger TM gap than the square lattice:  Gap\u00a0from\u00a0band\u00a01\u00a0(0.275065617068082)\u00a0to\u00a0band\u00a02\u00a0(0.446289918847647),\u00a047.4729292989213%", 
            "title": "Bands of a Triangular Lattice"
        }, 
        {
            "location": "/Scheme_Tutorial/#maximizing-the-first-tm-gap", 
            "text": "We will now show you a more sophisticated example utilizing the programming capabilities of Scheme. We will write a script to choose the cylinder radius that maximizes the first TM gap of the triangular lattice of rods from above. All of the Scheme syntax here won't be explained, but this should give you a flavor of what is possible.  First, we will write the function that want to maximize, a function that takes a dielectric constant and returns the size of the first TM gap. This function will change the geometry to reflect the new radius, run the calculation, and return the size of the first gap:  (define\u00a0(first-tm-gap\u00a0r)\n\u00a0\u00a0(set!\u00a0geometry\u00a0(list\u00a0(make\u00a0cylinder\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(center\u00a00\u00a00\u00a00)\u00a0(radius\u00a0r)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0(make\u00a0dielectric\u00a0(epsilon\u00a012))))))\n\u00a0\u00a0(run-tm)\n\u00a0\u00a0(retrieve-gap\u00a01))\u00a0;\u00a0return\u00a0the\u00a0gap\u00a0from\u00a0TM\u00a0band\u00a01\u00a0to\u00a0TM\u00a0band\u00a02  We'll leave most of the other parameters the same as in the previous example, but we'll also change  num-bands  to 2, since we only need to compute the first two bands:  (set!\u00a0num-bands\u00a02)  In order to distinguish small differences in radius during the optimization, it might seem that we have to increase the grid resolution, slowing down the computation. Instead, we can simply increase the  mesh  resolution. This is the size of the mesh over which the dielectric constant is averaged at each grid point, and increasing the mesh size means that the average index better reflects small changes in the structure.  (set!\u00a0mesh-size\u00a07)\u00a0;\u00a0increase\u00a0from\u00a0default\u00a0value\u00a0of\u00a03  Now, we're ready to maximize our function  first-tm-gap . We could write a loop to do this ourselves, but libctl provides a built-in function  (maximize function tolerance arg-min arg-max)  to do it for us using Brent's algorithm. So, we just tell it to find the maximum, searching in the range of radii from 0.1 to 0.5, with a tolerance of 0.1:  (define\u00a0result\u00a0(maximize\u00a0first-tm-gap\u00a00.1\u00a00.1\u00a00.5))\n(print\u00a0 radius\u00a0at\u00a0maximum:\u00a0 \u00a0(max-arg\u00a0result)\u00a0 \\n )\n(print\u00a0 gap\u00a0size\u00a0at\u00a0maximum:\u00a0 \u00a0(max-val\u00a0result)\u00a0 \\n )  print  is a function defined by libctl to apply the built-in  display  function to zero or more arguments. After five iterations, the output is:  radius\u00a0at\u00a0maximum:\u00a00.176393202250021\ngap\u00a0size\u00a0at\u00a0maximum:\u00a048.6252611051049  The tolerance of 0.1 that we specified means that the true maximum is within 0.1 * 0.176393202250021, or about 0.02, of the radius found here. It doesn't make much sense here to specify a lower tolerance, since the discretization of the grid means that the code can't accurately distinguish small differences in radius.  Before we continue, let's reset  mesh-size  to its default value:  (set!\u00a0mesh-size\u00a03)\u00a0;\u00a0reset\u00a0to\u00a0default\u00a0value\u00a0of\u00a03", 
            "title": "Maximizing the First TM Gap"
        }, 
        {
            "location": "/Scheme_Tutorial/#a-complete-2d-gap-with-an-anisotropic-dielectric", 
            "text": "As another example, one which does not require so much Scheme knowledge, let's construct a structure with a complete 2D gap (i.e., in both TE and TM polarizations), in a somewhat unusual way: using an  dielectric  structure. An anisotropic dielectric presents a different dielectric constant depending upon the direction of the electric field, and can be used in this case to make the TE and TM polarizations \"see\" different structures.  We already know that the triangular lattice of rods has a gap for TM light, but not for TE light. The dual structure, a triangular lattice of holes, has a gap for TE light but not for TM light at least for the small radii we will consider. Using an anisotropic dielectric, we can make both of these structures simultaneously, with each polarization seeing the structure that gives it a gap.  As before, our  geometry  will consist of a single cylinder, this time with a radius of 0.3, but now it will have an epsilon of 12 (dielectric rod) for TM light and 1 (air hole) for TE light:  (set!\u00a0geometry\u00a0(list\u00a0(make\u00a0cylinder\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(center\u00a00\u00a00\u00a00)\u00a0(radius\u00a00.3)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0(make\u00a0dielectric-anisotropic\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(epsilon-diag\u00a01\u00a01\u00a012))))))  Here,  epsilon-diag  specifies the diagonal elements of the dielectric tensor. The off-diagonal elements specified by  epsilon-offdiag  default to zero and are only needed when the principal axes of the dielectric tensor are different from the Cartesian xyz axes.  The background defaults to air, but we need to make it a dielectric (epsilon of 12) for the TE light, so that the cylinder forms a hole. This is controlled via the  default-material  variable:  (set!\u00a0default-material\u00a0(make\u00a0dielectric-anisotropic\u00a0(epsilon-diag\u00a012\u00a012\u00a01)))  Finally, we'll increase the number of bands back to eight and run the computation:  (set!\u00a0num-bands\u00a08)\n(run)\u00a0;\u00a0just\u00a0use\u00a0run,\u00a0instead\u00a0of\u00a0run-te\u00a0or\u00a0run-tm,\u00a0to\u00a0find\u00a0the\u00a0complete\u00a0gap  The result, as expected, is a complete band gap:  Gap\u00a0from\u00a0band\u00a02\u00a0(0.223977612336924)\u00a0to\u00a0band\u00a03\u00a0(0.274704473679751),\u00a020.3443687933601%  If we had computed the TM and TE bands separately, we would have found that the lower edge of the complete gap in this case comes from the TM gap, and the upper edge comes from the TE gap.", 
            "title": "A Complete 2D Gap with an Anisotropic Dielectric"
        }, 
        {
            "location": "/Scheme_Tutorial/#finding-a-point-defect-state", 
            "text": "Here, we consider the problem of finding a point-defect state in our square lattice of rods. This is a state that is localized in a small region by creating a point defect in the crystal \u2014 e.g., by removing a single rod. The resulting mode will have a frequency within, and be confined by, the gap. See  our online textbook , ch. 5.  To compute this, we need a supercell of bulk crystal, within which to put the defect \u2014 we will use a 5x5 cell of rods. To do this, we must first increase the size of the lattice by five, and then add all of the rods. We create the lattice by:  (set!\u00a0geometry-lattice\u00a0(make\u00a0lattice\u00a0(size\u00a05\u00a05\u00a0no-size)))  Here, we have used the default orthogonal basis, but have changed the size of the cell. To populate the cell, we could specify all 25 rods manually, but that would be tedious. A better approach would be to write a loop but in fact this has already been done for you. MPB provides a function,  geometric-objects-lattice-duplicates , that duplicates a list of objects over the lattice:  (set!\u00a0geometry\u00a0(list\u00a0(make\u00a0cylinder\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(center\u00a00\u00a00\u00a00)\u00a0(radius\u00a00.2)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0(make\u00a0dielectric\u00a0(epsilon\u00a012))))))\n(set!\u00a0geometry\u00a0(geometric-objects-lattice-duplicates\u00a0geometry))  There, now the  geometry  list contains 25 rods \u2014 the original  geometry  list, which contained one rod, duplicated over the 5x5 lattice.  To remove a rod, we'll just add another rod in the center of the cell with a dielectric constant of 1. When objects overlap, the later object in the list takes precedence, so we have to put the new rod at the end of  geometry :  (set!\u00a0geometry\u00a0(append\u00a0geometry\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(list\u00a0(make\u00a0cylinder\u00a0(center\u00a00\u00a00\u00a00)\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(radius\u00a00.2)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0air)))))  Here, we've used the Scheme  append  function to combine two lists, and have also snuck in the predefined material type  air  which has an epsilon of 1.  We'll be frugal and use only 16 points per lattice unit, resulting in an 80x80 grid, instead of the 32 from before:  (set!\u00a0resolution\u00a016)  Only a single k point is needed for a point-defect calculation which, for an infinite supercell, would be independent of k:  (set!\u00a0k-points\u00a0(list\u00a0(vector3\u00a00.5\u00a00.5\u00a00)))  Unfortunately, for a supercell the original bands are folded many times over, in this case, 25 times, so we need to compute many more bands to reach the same frequencies:  (set!\u00a0num-bands\u00a050)  At this point, we can call  (run-tm)  to solve for the TM bands. It will take several seconds to compute. Recall that the gap for this structure was for the frequency range 0.2812 to 0.4174. The bands of the solution include exactly one state in this frequency range: band 25, with a frequency of 0.378166. This is exactly what we should expect--the lowest band was folded 25 times into the supercell Brillouin zone, but one of these states was pushed up into the gap by the defect.  We haven't yet output any of the fields, but we don't have to repeat the run to do so. The fields from the last k-point computation remain in memory and can continue to be accessed and analyzed. For example, to output the electric field z component of band 25, we just do:  (output-efield-z\u00a025)  That's right, the output functions that we passed to  (run)  in the first example are just functions of the band index that are called on each band. We can do other computations too, like compute the fraction of the electric field energy near the defect cylinder within a radius 1.0 of the origin:  (get-dfield\u00a025)\u00a0\u00a0;\u00a0compute\u00a0the\u00a0D\u00a0field\u00a0for\u00a0band\u00a025\n(compute-field-energy)\u00a0\u00a0;\u00a0compute\u00a0the\u00a0energy\u00a0density\u00a0from\u00a0D\n(print\n\u00a0 energy\u00a0in\u00a0cylinder:\u00a0 \n\u00a0(compute-energy-in-objects\u00a0(make\u00a0cylinder\u00a0(center\u00a00\u00a00\u00a00)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(radius\u00a01.0)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0air)))\n\u00a0 \\n )  The result is 0.624794702341156, or over 62% of the field energy in this localized region; the field decays exponentially into the bulk crystal. The full range of available functions is described in the  User Interface , but the typical sequence is to first load a field with a  get-  function and then to call other functions to perform computations and transformations on it.  Note that the  compute-energy-in-objects  returns the energy fraction, but does not itself print this value. This is fine when you are running interactively, in which case Guile always displays the result of the last expression, but when running as part of a script you need to explicitly print the result as we have done above with the  print  function. The \"\\n\" string is newline character (like in C), to put subsequent output on a separate line.  Instead of computing all those bands, we can instead take advantage of a special feature of MPB that allows you to compute the bands closest to a \"target\" frequency, rather than the bands with the lowest frequencies. One uses this feature by setting the  target-freq  variable to something other than zero (e.g. the mid-gap frequency). In order to get accurate results, it's currently also recommended that you decrease the  tolerance  variable, which controls when convergence is judged to have occurred, from its default value of  1e-7 :  (set!\u00a0num-bands\u00a01)\u00a0\u00a0;\u00a0only\u00a0need\u00a0to\u00a0compute\u00a0a\u00a0single\u00a0band,\u00a0now!\n(set!\u00a0target-freq\u00a0(/\u00a0(+\u00a00.2812\u00a00.4174)\u00a02))\n(set!\u00a0tolerance\u00a01e-8)  Now, we just call  (run-tm)  as before. Convergence requires more iterations this time, both because we've decreased the tolerance and because of the nature of the eigenproblem that is now being solved, but only by about 3-4 times in this case. Since we now have to compute only a single band, however, we arrive at an answer much more quickly than before. The result, of course, is again the defect band, with a frequency of 0.378166.", 
            "title": "Finding a Point-defect State"
        }, 
        {
            "location": "/Scheme_Tutorial/#tuning-the-point-defect-mode", 
            "text": "As another example utilizing the programming capability of Scheme, we will write a script to \"tune\" the defect mode to a particular frequency. Instead of forming a defect by simply removing a rod, we can decrease the radius or the dielectric constant of the defect rod, thereby changing the corresponding mode frequency. In this case, we'll vary the dielectric constant, and try to find a mode with a frequency of, say, 0.314159 (a random number).  We could write a loop to search for this epsilon, but instead we'll use a root-finding function provided by libctl,  (find-root function tolerance arg-min arg-max) , that will solve the problem for us using a quadratically-convergent algorithm (Ridder's method). First, we need to define a function that takes an epsilon for the center rod and returns the mode frequency minus 0.314159; this is the function we'll be finding the root of:  (define\u00a0old-geometry\u00a0geometry)\u00a0;\u00a0save\u00a0the\u00a05x5\u00a0grid\u00a0with\u00a0a\u00a0missing\u00a0rod\n(define\u00a0(rootfun\u00a0eps)\n\u00a0\u00a0;\u00a0add\u00a0the\u00a0cylinder\u00a0of\u00a0epsilon\u00a0=\u00a0eps\u00a0to\u00a0the\u00a0old\u00a0geometry:\n\u00a0\u00a0(set!\u00a0geometry\u00a0(append\u00a0old-geometry\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(list\u00a0(make\u00a0cylinder\u00a0(center\u00a00\u00a00\u00a00)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(radius\u00a00.2)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0(make\u00a0dielectric\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(epsilon\u00a0eps)))))))\n\u00a0\u00a0(run-tm)\u00a0\u00a0;\u00a0solve\u00a0for\u00a0the\u00a0mode\u00a0(using\u00a0the\u00a0targeted\u00a0solver)\n\u00a0\u00a0(print\u00a0 epsilon\u00a0=\u00a0 \u00a0eps\u00a0 \u00a0gives\u00a0freq.\u00a0=\u00a0 \u00a0(list-ref\u00a0freqs\u00a00)\u00a0 \\n )\n\u00a0\u00a0(-\u00a0(list-ref\u00a0freqs\u00a00)\u00a00.314159))\u00a0\u00a0;\u00a0return\u00a01st\u00a0band\u00a0freq.\u00a0-\u00a00.314159  Now, we can solve for epsilon, searching in the range 1 to 12, with a fractional tolerance of 0.01, by:  (define\u00a0rooteps\u00a0(find-root\u00a0rootfun\u00a00.01\u00a01\u00a012))\n(print\u00a0 root\u00a0(value\u00a0of\u00a0epsilon)\u00a0is\u00a0at:\u00a0 \u00a0rooteps\u00a0 \\n )  The sequence of dielectric constants that it tries, along with the corresponding mode frequencies, is:     epsilon  frequency      1  0.378165893321125    12  0.283987088221692    6.5  0.302998920718043    5.14623274327171  0.317371748739314    5.82311637163586  0.309702408341706    5.41898003340128  0.314169110036439    5.62104820251857  0.311893530112625      The final answer that it returns is an epsilon of 5.41986120170136. Interestingly enough, the algorithm doesn't actually evaluate the function at the final point. You have to do so yourself if you want to find out how close it is to the root. Ridder's method successively reduces the interval bracketing the root by alternating bisection and interpolation steps. At the end, it does one last interpolation to give you its best guess for the root location within the current interval. If we go ahead and evaluate the band frequency at this dielectric constant, calling  (rootfun rooteps) , we find that it is 0.314159008193209, matching our desired frequency to nearly eight decimal places after seven function evaluations! Of course, the computation isn't really this accurate anyway, due to the finite discretization.  A slight improvement can be made to the calculation above. Ordinarily, each time you call the  (run-tm)  function, the fields are initialized to random values. It would speed convergence somewhat to use the fields of the previous calculation as the starting point for the next calculation. We can do this by instead calling a lower-level function,  (run-parity TM false) . The first parameter is the polarization to solve for, and the second tells it not to reset the fields if possible.", 
            "title": "Tuning the Point-defect Mode"
        }, 
        {
            "location": "/Scheme_Tutorial/#editors-and-ctl", 
            "text": "It is useful to have  emacs  use its  scheme-mode  for editing ctl files, so that hitting tab indents nicely, and so on.  emacs  does this automatically for files ending with \".scm\"; to do it for files ending with \".ctl\" as well, add the following lines to your  ~/.emacs  file:   (push '( \\\\.ctl\\\\'  . scheme-mode) auto-mode-alist)  or if your  emacs  version is 24.3 or earlier and you have other \".ctl\" files which are not Scheme:   (if (assoc  \\\\.ctl  auto-mode-alist)\n       nil\n         (add-to-list 'auto-mode-alist '( \\\\.ctl\\\\'  . scheme-mode))))  Incidentally,  emacs  scripts are written in \"elisp,\" a language closely related to Scheme.  If you don't use emacs (or derivatives such as Aquamacs), it would be good to find another editor that supports a Scheme mode.  For example,  jEdit  is a free/open-source cross-platform editor with Scheme-syntax support.  Another option is  gedit . One of our users has donated a  hilighting mode for Meep/MPB  that specially highlights the Meep/MPB keywords.", 
            "title": "Editors and ctl"
        }, 
        {
            "location": "/Data_Analysis_Tutorial/", 
            "text": "MPB Data Analysis Tutorial\n\n\nIn the previous section, we focused on how to perform a calculation in MPB. Now, we'll give a brief tutorial on what you might do with the results of the calculations, and in particular how you might visualize the results. We'll focus on two systems, one two-dimensional and one three-dimensional.\n\n\nTable of Contents\n\n\nMPB Data Analysis Tutorial\n\n\nTriangular Lattice of Rods\n\n\nThe tri-rods.ctl Control File\n\n\nThe tri-rods Dielectric Function\n\n\nGaps and Band Diagram for tri-rods\n\n\nThe Source of the TM Gap: Examining the Modes\n\n\n\n\n\n\nDiamond Lattice of Spheres\n\n\nDiamond Control File\n\n\nImportant Note on Units for the Diamond/FCC Lattice\n\n\nGaps and Band Diagram for the Diamond Lattice\n\n\nVisualizing the Diamond Lattice Structure and Bands\n\n\n\n\n\n\n\n\n\n\nTriangular Lattice of Rods\n\n\nFirst, we'll return to the two-dimensional \ntriangular lattice of rods\n in air.  See also \nour online textbook\n, ch. 5. The control file for this calculation, which can also be found in \nmpb-ctl/examples/tri-rods.ctl\n, will consist of:\n\n\nThe tri-rods.ctl Control File\n\n\n(set!\u00a0num-bands\u00a08)\n(set!\u00a0geometry-lattice\u00a0(make\u00a0lattice\u00a0(size\u00a01\u00a01\u00a0no-size)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis1\u00a0(/\u00a0(sqrt\u00a03)\u00a02)\u00a00.5)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis2\u00a0(/\u00a0(sqrt\u00a03)\u00a02)\u00a0-0.5)))\n(set!\u00a0geometry\u00a0(list\u00a0(make\u00a0cylinder\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(center\u00a00\u00a00\u00a00)\u00a0(radius\u00a00.2)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0(make\u00a0dielectric\u00a0(epsilon\u00a012))))))\n(set!\u00a0k-points\u00a0(list\u00a0(vector3\u00a00\u00a00\u00a00)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0Gamma\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00.5\u00a00)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0M\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a0(/\u00a0-3)\u00a0(/\u00a03)\u00a00)\u00a0;\u00a0K\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00\u00a00)))\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0Gamma\n(set!\u00a0k-points\u00a0(interpolate\u00a04\u00a0k-points))\n(set!\u00a0resolution\u00a032)\n(run-tm\u00a0(output-at-kpoint\u00a0(vector3\u00a0(/\u00a0-3)\u00a0(/\u00a03)\u00a00)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fix-efield-phase\u00a0output-efield-z))\n(run-te)\n\n\n\n\nNotice that we're computing both TM and TE bands where we expect a gap in the TM bands, and are outputting the z component of the electric field for the TM bands at the K point. The \nfix-efield-phase\n will be explained below.\n\n\nNow, run the calculation, directing the output to a file, by entering the following command at the Unix prompt:\n\n\nunix%\u00a0mpb\u00a0tri-rods.ctl\u00a0\n\u00a0tri-rods.out\n\n\n\n\nIt should finish in a few seconds.\n\n\nThe tri-rods Dielectric Function\n\n\nIn most cases, the first thing we'll want to do is to look at the dielectric function, to make sure that we specified the correct geometry. We can do this by looking at the \nepsilon.h5\n output file.\n\n\nThe first thing that might come to mind would be to examine \nepsilon.h5\n directly, say by converting it to a PNG image with \nh5topng\n from \nh5utils\n, magnifying it by 3:\n\n\nunix% h5topng -S 3 epsilon.h5\n\n\n\n\n\n\nThis image initially seems wrong! Why is the rod oval-shaped and not circular? Actually, the dielectric function is correct, but the image is distorted because the primitive cell of our lattice is a rhombus with 60\n\\circ\n acute angles. Since the output grid of MPB is defined over the non-orthogonal unit cell, while the image produced by \nh5topng\n and most other plotting programs is square, the image is skewed.\n\n\nWe can fix the image in a variety of ways, but the best way is probably to use the \nmpb-data\n utility included and installed with MPB. \nmpb-data\n allows us to rearrange the data into a rectangular cell (\n-r\n) with the same area/volume, expand the data to include multiple periods (\n-m\n \nperiods\n), and change the resolution per unit distance in each direction to a fixed value (\n-n\n \nresolution\n). \nman\n \nmpb-data\n or run \nmpb-data\n \n-h\n for more options. In this case, we'll rectify the cell, expand it to three periods in each direction, and fix the resolution to 32 pixels per \na\n:\n\n\nunix%\u00a0mpb-data\u00a0-r\u00a0-m\u00a03\u00a0-n\u00a032\u00a0epsilon.h5\n\n\n\n\nIt's important to use \n-n\n when you use \n-r\n, as otherwise the non-square unit cell output by \n-r\n will have a different density of grid points in each direction, and appear distorted. The output of \nmpb-data\n is by default an additional dataset within the input file, as we can see by running \nh5ls\n:\n\n\nunix%\u00a0h5ls\u00a0epsilon.h5\u00a0\ndata\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Dataset\u00a0{32,\u00a032}\ndata-new\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Dataset\u00a0{96,\u00a083}\ndescription\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Dataset\u00a0{SCALAR}\nlattice\\\u00a0copies\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Dataset\u00a0{3}\nlattice\\\u00a0vectors\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Dataset\u00a0{3,\u00a03}\n\n\n\n\n\n\nHere the new dataset output by \nmpb-data\n is the one called \ndata-new\n. We can examine it by running \nh5topng\n again, this time explicitly specifying the name of the dataset (and no longer magnifying):\n\n\nunix%\u00a0h5topng\u00a0epsilon.h5:data-new\n\n\n\n\nThe new \nepsilon.png\n output image is shown at right. As you can see, the rods are now circular as desired, and they clearly form a triangular lattice.\n\n\nGaps and Band Diagram for tri-rods\n\n\nAt this point, let's check for band gaps by picking out lines with the word \"Gap\" in them:\n\n\nunix%\u00a0grep\u00a0Gap\u00a0tri-rods.out\nGap\u00a0from\u00a0band\u00a01\u00a0(0.275065617068082)\u00a0to\u00a0band\u00a02\u00a0(0.446289918847647),\u00a047.4729292989213%\nGap\u00a0from\u00a0band\u00a03\u00a0(0.563582903703468)\u00a0to\u00a0band\u00a04\u00a0(0.593059066215511),\u00a05.0968516236891%\nGap\u00a0from\u00a0band\u00a04\u00a0(0.791161222813268)\u00a0to\u00a0band\u00a05\u00a0(0.792042731370125),\u00a00.111357548663006%\nGap\u00a0from\u00a0band\u00a05\u00a0(0.838730315053238)\u00a0to\u00a0band\u00a06\u00a0(0.840305955160638),\u00a00.187683867865441%\nGap\u00a0from\u00a0band\u00a06\u00a0(0.869285340346465)\u00a0to\u00a0band\u00a07\u00a0(0.873496724070656),\u00a00.483294361375001%\nGap\u00a0from\u00a0band\u00a04\u00a0(0.821658212109559)\u00a0to\u00a0band\u00a05\u00a0(0.864454087942874),\u00a05.07627823271133%\n\n\n\n\nThe first five gaps are for the TM bands (which we ran first), and the last gap is for the TE bands. Note, however that the \n 1% gaps are probably false positives due to band crossings, as described in the \ntutorial\n. There are no complete (overlapping TE/TM) gaps, and the largest gap is the 47% TM gap as expected. See \nour online textbook\n, appendix C. To be absolutely sure of this and other band gaps, we would also check k-points within the interior of the Brillouin zone, but we'll omit that step here.\n\n\nNext, let's plot out the band structure. To do this, we'll first extract the TM and TE bands as comma-delimited text, which can then be imported and plotted in our favorite spreadsheet/plotting program.\n\n\nunix%\u00a0grep\u00a0tmfreqs\u00a0tri-rods.out\u00a0\n\u00a0tri-rods.tm.dat\nunix%\u00a0grep\u00a0tefreqs\u00a0tri-rods.out\u00a0\n\u00a0tri-rods.te.dat\n\n\n\n\nThe TM and TE bands are both plotted below against the \"k index\" column of the data, with the special k-points labelled. TM bands are shown in blue (filled circles) with the gaps shaded light blue, while TE bands are shown in red (hollow circles) with the gaps shaded light red.\n\n\n\n\nNote that we truncated the upper frequencies at a cutoff of 1.0 c/a. Although some of our bands go above that frequency, we didn't compute enough bands to fill in all of the states in that range. Besides, we only really care about the states around the gap(s), in most cases.\n\n\nThe Source of the TM Gap: Examining the Modes\n\n\nNow, let's actually examine the electric-field distributions for some of the bands which were saved at the K point, remember. Besides looking neat, the field patterns will tell us about the characters of the modes and provide some hints regarding the origin of the band gap.\n\n\nAs before, we'll run \nmpb-data\n on the field output files (named \ne.k11.b*.z.tm.h5\n), and then run \nh5topng\n to view the results:\n\n\nunix%\u00a0mpb-data\u00a0-r\u00a0-m\u00a03\u00a0-n\u00a032\u00a0e.k11.b*.z.tm.h5\nunix%\u00a0h5topng\u00a0-C\u00a0epsilon.h5:data-new\u00a0-c\u00a0bluered\u00a0-Z\u00a0-d\u00a0z.r-new\u00a0e.k11.b*.z.tm.h5\n\n\n\n\nHere, we've used the \n-C\n option to superimpose black contours of the dielectric function over the fields, \n-c\n \nbluered\n to use a blue-white-red color table, \n-Z\n to center the color scale at zero (white), and \n-d\n to specify the dataset name for all of the files at once. \nman h5topng\n for more information. There are plenty of data-visualization programs available if you want more sophisticated plotting capabilities than what \nh5topng\n offers, of course; you can use \nh5totxt\n to convert the data to a format suitable for import into e.g. spreadsheets.\n\n\nNote that the dataset name is \nz.r-new\n, which is the real part of the z component of the output of \nmpb-data\n. Since these are TM fields, the z component is the only non-zero part of the electric field. The real and imaginary parts of the fields correspond to what the fields look like at half-period intervals in time, and in general they are different. However, at K they are redundant, due to the inversion symmetry of that k-point (proof left as an exercise for the reader). Usually, looking at the real parts alone gives you a pretty good picture of the state, especially if you use \nfix-efield-phase\n (see below), which chooses the phase to maximize the field energy in the real part. Sometimes, though, you have to be careful: if the real part happens to be zero, what you'll see is essentially numerical noise and you should switch to the imaginary part.\n\n\nThe resulting field images are shown below:\n\n\n\n\n\n\n\n\nTM band 1\n\n\nTM band 2\n\n\nTM band 3\n\n\nTM band 4\n\n\nTM band 5\n\n\nTM band 6\n\n\nTM band 7\n\n\nTM band 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYour images should look the same as the ones above. If we hadn't included \nfix-efield-phase\n before \noutput-efield-z\n in the ctl file, on the other hand, yours would have differed slightly (e.g. by a sign or a lattice shift), because by default the phase is \nrandom\n.\n\n\nWhen we look at the real parts of the fields, we are really looking at the fields of the modes at a particular instant in time and the imaginary part is half a period later. The point in time relative to the periodic oscillation of the state is determined by the phase of the eigenstate. The \nfix-efield-phase\n band function picks a canonical phase for the eigenstate, giving us a deterministic picture.\n\n\nWe can see several things from these plots:\n\n\nFirst, the origin of the band gap is apparent. The lowest band is concentrated within the dielectric rods in order to minimize its frequency. The next bands, in order to be orthogonal, are forced to have a node within the rods, imposing a large \"kinetic energy\" (and/or \"potential energy\") cost and hence a gap. See \nour online textbook\n, ch. 5. Successive bands have more and more complex nodal structures in order to maintain orthogonality. The contrasting absence of a large TE gap has to do with boundary conditions. The perpendicular component of the displacement field must be continuous across the dielectric boundary, but the parallel component need not be.\n\n\nWe can also see the deep impact of symmetry on the states. The K point has C\n3v\n symmetry and not quite the full C\n6v\n symmetry of the dielectric structure. This symmetry group has only one two-dimensional representation--that is what gives rise to the degenerate pairs of states (2/3, 4/5, and 7/8), all of which fall into this \"p-like\" category where the states transform like two orthogonal dipole field patterns, essentially. The other two bands, 1 and 6, transform under the trivial \"s-like\" representation with band 6 just a higher-order version of 1.\n\n\nDiamond Lattice of Spheres\n\n\nNow, let us turn to a three-dimensional structure, a diamond lattice of dielectric spheres in air. See \nour online textbook\n, ch. 6. The basic techniques to compute and analyze the modes of this structure are the same as in two dimensions, but of course, everything becomes more complicated in 3d. It's harder to find a structure with a complete gap, the modes are no longer polarized, the computations are bigger, and visualization is more difficult, for starters.\n\n\nThe control file for this calculation, which can also be found in \nmpb-ctl/examples/diamond.ctl\n, consists of:\n\n\nDiamond Control File\n\n\n\u00a0(set!\u00a0geometry-lattice\u00a0(make\u00a0lattice\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis-size\u00a0(sqrt\u00a00.5)\u00a0(sqrt\u00a00.5)\u00a0(sqrt\u00a00.5))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis1\u00a00\u00a01\u00a01)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis2\u00a01\u00a00\u00a01)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis3\u00a01\u00a01\u00a00)))\n\n;\u00a0Corners\u00a0of\u00a0the\u00a0irreducible\u00a0Brillouin\u00a0zone\u00a0for\u00a0the\u00a0fcc\u00a0lattice,\n;\u00a0in\u00a0a\u00a0canonical\u00a0order:\n\u00a0(set!\u00a0k-points\u00a0(interpolate\u00a04\u00a0(list\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00.5\u00a00.5)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0X\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00.625\u00a00.375)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0U\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00.5\u00a00)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0L\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00\u00a00)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0Gamma\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00.5\u00a00.5)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0X\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00.25\u00a00.75\u00a00.5)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0W\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00.375\u00a00.75\u00a00.375))))\u00a0\u00a0;\u00a0K\n\n\u00a0;\u00a0define\u00a0a\u00a0couple\u00a0of\u00a0parameters\u00a0(which\u00a0we\u00a0can\u00a0set\u00a0from\u00a0the\u00a0command-line)\n\u00a0(define-param\u00a0eps\u00a011.56)\u00a0;\u00a0the\u00a0dielectric\u00a0constant\u00a0of\u00a0the\u00a0spheres\n\u00a0(define-param\u00a0r\u00a00.25)\u00a0\u00a0\u00a0\u00a0;\u00a0the\u00a0radius\u00a0of\u00a0the\u00a0spheres\n\n\u00a0(define\u00a0diel\u00a0(make\u00a0dielectric\u00a0(epsilon\u00a0eps)))\n\n ;\u00a0A\u00a0diamond\u00a0lattice\u00a0has\u00a0two\u00a0\natoms\n\u00a0per\u00a0unit\u00a0cell:\n\u00a0(set!\u00a0geometry\u00a0(list\u00a0(make\u00a0sphere\u00a0(center\u00a00.125\u00a00.125\u00a00.125)\u00a0(radius\u00a0r)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0diel))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(make\u00a0sphere\u00a0(center\u00a0-0.125\u00a0-0.125\u00a0-0.125)\u00a0(radius\u00a0r)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0diel))))\n\n\u00a0;\u00a0(A\u00a0simple\u00a0fcc\u00a0lattice\u00a0would\u00a0have\u00a0only\u00a0one\u00a0sphere/object\u00a0at\u00a0the\u00a0origin.)\n\n (set-param!\u00a0resolution\u00a016)\u00a0;\u00a0use\u00a0a\u00a016x16x16\u00a0grid\n\u00a0(set-param!\u00a0mesh-size\u00a05)\n\u00a0(set-param!\u00a0num-bands\u00a05)\n\n ;\u00a0run\u00a0calculation,\u00a0outputting\u00a0electric-field\u00a0energy\u00a0density\u00a0at\u00a0the\u00a0U\u00a0point:\n (run\u00a0(output-at-kpoint\u00a0(vector3\u00a00\u00a00.625\u00a00.375)\u00a0output-dpwr))\n\n\n\n\nAs before, run the calculation, directing the output to a file. This will take a minute. We'll put it in the background with \nnohup\n so that it will finish even if we log out:\n\n\nunix%\u00a0nohup\u00a0mpb\u00a0diamond.ctl\u00a0\n\u00a0diamond.out\u00a0\n\n\n\n\n\nNote that, because we used \ndefine-param\n and \nset-param!\n to define/set some variables (see the \nlibctl reference\n, we can change them from the command line. For example, to use a radius of 0.3 and a resolution of 20, we can just type \nmpb r=0.3 resolution=20 diamond.ctl\n. This is an extremely useful feature, because it allows you to use one generic control file for many variations on the same structure.\n\n\nImportant Note on Units for the Diamond/FCC Lattice\n\n\nAs usual,\n all distances are in the dimensionless units determined by the length of the lattice vectors. We refer to these units as \na\n, and frequencies are given in units of \nc/a\n. By default, the lattice/basis vectors are unit vectors, but in the case of fcc lattices this conflicts with the convention in the literature. In particular, the canonical \na\n for fcc is the edge-length of a cubic supercell containing the lattice.\n\n\nIn order to follow this convention, we set the length of our basis vectors appropriately using the \nbasis-size\n property of \ngeometry-lattice\n. The lattice vectors default to the same length as the basis vectors. If the cubic supercell edge has unit length (\na\n), then the fcc lattice vectors have length sqrt(0.5), or \n(sqrt 0.5)\n in Scheme.\n\n\nGaps and Band Diagram for the Diamond Lattice\n\n\nThe diamond lattice has a complete band gap:\n\n\nunix%\u00a0grep\u00a0Gap\u00a0diamond.out\nGap\u00a0from\u00a0band\u00a02\u00a0(0.396348703007373)\u00a0to\u00a0band\u00a03\u00a0(0.440813418580596),\u00a010.6227251392791%\n\n\n\n\nWe can also plot its band diagram, much as for the tri-rods case except that now we can't classify the bands by polarization.\n\n\nunix%\u00a0grep\u00a0freqs\u00a0diamond.out\u00a0\n\u00a0diamond.dat\n\n\n\n\nThe resulting band diagram, with the complete band gap shaded yellow, is shown below. Note that we only computed 5 bands, so in reality the upper portion of the plot would contain a lot more bands which are of less interest than the bands adjoining the gap.\n\n\n\n\nVisualizing the Diamond Lattice Structure and Bands\n\n\nVisualizing fields in a useful way for general three-dimensional structures is fairly difficult, but we'll show you what we can with the help of the free \nVis5D\n volumetric-visualization program, and the \nh5tov5d\n conversion program from \nh5utils\n.\n\n\nFirst, of course, we've got to rectangularize the unit cell using \nmpb-data\n, as before. We'll also expand it to two periods in each direction.\n\n\nunix%\u00a0mpb-data\u00a0-m\u00a02\u00a0-r\u00a0-n\u00a032\u00a0epsilon.h5\u00a0dpwr.k06.b*.h5\n\n\n\n\nThen, we'll use \nh5tov5d\n to convert the resulting datasets to Vis5D format, joining all the datasets into a single file (\ndiamond.v5d\n) so that we can view them simultaneously if we want to:\n\n\nunix%\u00a0h5tov5d\u00a0-o\u00a0diamond.v5d\u00a0-d\u00a0data-new\u00a0epsilon.h5\u00a0dpwr.k06.b*.h5\n\n\n\n\nNote that all of the datasets are named \ndata-new\n from the original datasets called \ndata\n since we are looking at scalar data (the time-averaged electric-field energy density). No messy field components or real and imaginary parts this time; we have enough to deal with already.\n\n\nNow we can open the file with Vis5D and play around with various plots of the data:\n\n\nunix%\u00a0vis5d\u00a0diamond.v5d\u00a0\n\n\n\n\n\nIf you stare at the dielectric function long enough from various angles, you can convince yourself that it is a diamond lattice:\n\n\n\n\nThe lowest two bands have their fields concentrated within the spheres as you might expect, flowing along more-or-less linear paths. The second band differs from the first mainly by the orientation of its field paths. The fields for the first band at U are depicted below, with the strongest fields (highest energy density) shown as the most opaque, blue pixels. Next to it is the same plot but with an isosurface at the boundary of the dielectric superimposed, so you can see that the energy is concentrated inside the dielectric.\n\n\n\n\n\n\nThe first band above the gap is band 3. Its field energy densities are depicted below in the same manner as above. The field patterns are considerably harder to make out than for the lower band, but they seem to be more diffuse and \"clumpy,\" the latter likely indicating the expected field oscillations for orthogonality with the lower bands.", 
            "title": "Data Analysis Tutorial"
        }, 
        {
            "location": "/Data_Analysis_Tutorial/#triangular-lattice-of-rods", 
            "text": "First, we'll return to the two-dimensional  triangular lattice of rods  in air.  See also  our online textbook , ch. 5. The control file for this calculation, which can also be found in  mpb-ctl/examples/tri-rods.ctl , will consist of:", 
            "title": "Triangular Lattice of Rods"
        }, 
        {
            "location": "/Data_Analysis_Tutorial/#the-tri-rodsctl-control-file", 
            "text": "(set!\u00a0num-bands\u00a08)\n(set!\u00a0geometry-lattice\u00a0(make\u00a0lattice\u00a0(size\u00a01\u00a01\u00a0no-size)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis1\u00a0(/\u00a0(sqrt\u00a03)\u00a02)\u00a00.5)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis2\u00a0(/\u00a0(sqrt\u00a03)\u00a02)\u00a0-0.5)))\n(set!\u00a0geometry\u00a0(list\u00a0(make\u00a0cylinder\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(center\u00a00\u00a00\u00a00)\u00a0(radius\u00a00.2)\u00a0(height\u00a0infinity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0(make\u00a0dielectric\u00a0(epsilon\u00a012))))))\n(set!\u00a0k-points\u00a0(list\u00a0(vector3\u00a00\u00a00\u00a00)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0Gamma\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00.5\u00a00)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0M\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a0(/\u00a0-3)\u00a0(/\u00a03)\u00a00)\u00a0;\u00a0K\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00\u00a00)))\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0Gamma\n(set!\u00a0k-points\u00a0(interpolate\u00a04\u00a0k-points))\n(set!\u00a0resolution\u00a032)\n(run-tm\u00a0(output-at-kpoint\u00a0(vector3\u00a0(/\u00a0-3)\u00a0(/\u00a03)\u00a00)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fix-efield-phase\u00a0output-efield-z))\n(run-te)  Notice that we're computing both TM and TE bands where we expect a gap in the TM bands, and are outputting the z component of the electric field for the TM bands at the K point. The  fix-efield-phase  will be explained below.  Now, run the calculation, directing the output to a file, by entering the following command at the Unix prompt:  unix%\u00a0mpb\u00a0tri-rods.ctl\u00a0 \u00a0tri-rods.out  It should finish in a few seconds.", 
            "title": "The tri-rods.ctl Control File"
        }, 
        {
            "location": "/Data_Analysis_Tutorial/#the-tri-rods-dielectric-function", 
            "text": "In most cases, the first thing we'll want to do is to look at the dielectric function, to make sure that we specified the correct geometry. We can do this by looking at the  epsilon.h5  output file.  The first thing that might come to mind would be to examine  epsilon.h5  directly, say by converting it to a PNG image with  h5topng  from  h5utils , magnifying it by 3:  unix% h5topng -S 3 epsilon.h5   This image initially seems wrong! Why is the rod oval-shaped and not circular? Actually, the dielectric function is correct, but the image is distorted because the primitive cell of our lattice is a rhombus with 60 \\circ  acute angles. Since the output grid of MPB is defined over the non-orthogonal unit cell, while the image produced by  h5topng  and most other plotting programs is square, the image is skewed.  We can fix the image in a variety of ways, but the best way is probably to use the  mpb-data  utility included and installed with MPB.  mpb-data  allows us to rearrange the data into a rectangular cell ( -r ) with the same area/volume, expand the data to include multiple periods ( -m   periods ), and change the resolution per unit distance in each direction to a fixed value ( -n   resolution ).  man   mpb-data  or run  mpb-data   -h  for more options. In this case, we'll rectify the cell, expand it to three periods in each direction, and fix the resolution to 32 pixels per  a :  unix%\u00a0mpb-data\u00a0-r\u00a0-m\u00a03\u00a0-n\u00a032\u00a0epsilon.h5  It's important to use  -n  when you use  -r , as otherwise the non-square unit cell output by  -r  will have a different density of grid points in each direction, and appear distorted. The output of  mpb-data  is by default an additional dataset within the input file, as we can see by running  h5ls :  unix%\u00a0h5ls\u00a0epsilon.h5\u00a0\ndata\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Dataset\u00a0{32,\u00a032}\ndata-new\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Dataset\u00a0{96,\u00a083}\ndescription\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Dataset\u00a0{SCALAR}\nlattice\\\u00a0copies\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Dataset\u00a0{3}\nlattice\\\u00a0vectors\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Dataset\u00a0{3,\u00a03}   Here the new dataset output by  mpb-data  is the one called  data-new . We can examine it by running  h5topng  again, this time explicitly specifying the name of the dataset (and no longer magnifying):  unix%\u00a0h5topng\u00a0epsilon.h5:data-new  The new  epsilon.png  output image is shown at right. As you can see, the rods are now circular as desired, and they clearly form a triangular lattice.", 
            "title": "The tri-rods Dielectric Function"
        }, 
        {
            "location": "/Data_Analysis_Tutorial/#gaps-and-band-diagram-for-tri-rods", 
            "text": "At this point, let's check for band gaps by picking out lines with the word \"Gap\" in them:  unix%\u00a0grep\u00a0Gap\u00a0tri-rods.out\nGap\u00a0from\u00a0band\u00a01\u00a0(0.275065617068082)\u00a0to\u00a0band\u00a02\u00a0(0.446289918847647),\u00a047.4729292989213%\nGap\u00a0from\u00a0band\u00a03\u00a0(0.563582903703468)\u00a0to\u00a0band\u00a04\u00a0(0.593059066215511),\u00a05.0968516236891%\nGap\u00a0from\u00a0band\u00a04\u00a0(0.791161222813268)\u00a0to\u00a0band\u00a05\u00a0(0.792042731370125),\u00a00.111357548663006%\nGap\u00a0from\u00a0band\u00a05\u00a0(0.838730315053238)\u00a0to\u00a0band\u00a06\u00a0(0.840305955160638),\u00a00.187683867865441%\nGap\u00a0from\u00a0band\u00a06\u00a0(0.869285340346465)\u00a0to\u00a0band\u00a07\u00a0(0.873496724070656),\u00a00.483294361375001%\nGap\u00a0from\u00a0band\u00a04\u00a0(0.821658212109559)\u00a0to\u00a0band\u00a05\u00a0(0.864454087942874),\u00a05.07627823271133%  The first five gaps are for the TM bands (which we ran first), and the last gap is for the TE bands. Note, however that the   1% gaps are probably false positives due to band crossings, as described in the  tutorial . There are no complete (overlapping TE/TM) gaps, and the largest gap is the 47% TM gap as expected. See  our online textbook , appendix C. To be absolutely sure of this and other band gaps, we would also check k-points within the interior of the Brillouin zone, but we'll omit that step here.  Next, let's plot out the band structure. To do this, we'll first extract the TM and TE bands as comma-delimited text, which can then be imported and plotted in our favorite spreadsheet/plotting program.  unix%\u00a0grep\u00a0tmfreqs\u00a0tri-rods.out\u00a0 \u00a0tri-rods.tm.dat\nunix%\u00a0grep\u00a0tefreqs\u00a0tri-rods.out\u00a0 \u00a0tri-rods.te.dat  The TM and TE bands are both plotted below against the \"k index\" column of the data, with the special k-points labelled. TM bands are shown in blue (filled circles) with the gaps shaded light blue, while TE bands are shown in red (hollow circles) with the gaps shaded light red.   Note that we truncated the upper frequencies at a cutoff of 1.0 c/a. Although some of our bands go above that frequency, we didn't compute enough bands to fill in all of the states in that range. Besides, we only really care about the states around the gap(s), in most cases.", 
            "title": "Gaps and Band Diagram for tri-rods"
        }, 
        {
            "location": "/Data_Analysis_Tutorial/#the-source-of-the-tm-gap-examining-the-modes", 
            "text": "Now, let's actually examine the electric-field distributions for some of the bands which were saved at the K point, remember. Besides looking neat, the field patterns will tell us about the characters of the modes and provide some hints regarding the origin of the band gap.  As before, we'll run  mpb-data  on the field output files (named  e.k11.b*.z.tm.h5 ), and then run  h5topng  to view the results:  unix%\u00a0mpb-data\u00a0-r\u00a0-m\u00a03\u00a0-n\u00a032\u00a0e.k11.b*.z.tm.h5\nunix%\u00a0h5topng\u00a0-C\u00a0epsilon.h5:data-new\u00a0-c\u00a0bluered\u00a0-Z\u00a0-d\u00a0z.r-new\u00a0e.k11.b*.z.tm.h5  Here, we've used the  -C  option to superimpose black contours of the dielectric function over the fields,  -c   bluered  to use a blue-white-red color table,  -Z  to center the color scale at zero (white), and  -d  to specify the dataset name for all of the files at once.  man h5topng  for more information. There are plenty of data-visualization programs available if you want more sophisticated plotting capabilities than what  h5topng  offers, of course; you can use  h5totxt  to convert the data to a format suitable for import into e.g. spreadsheets.  Note that the dataset name is  z.r-new , which is the real part of the z component of the output of  mpb-data . Since these are TM fields, the z component is the only non-zero part of the electric field. The real and imaginary parts of the fields correspond to what the fields look like at half-period intervals in time, and in general they are different. However, at K they are redundant, due to the inversion symmetry of that k-point (proof left as an exercise for the reader). Usually, looking at the real parts alone gives you a pretty good picture of the state, especially if you use  fix-efield-phase  (see below), which chooses the phase to maximize the field energy in the real part. Sometimes, though, you have to be careful: if the real part happens to be zero, what you'll see is essentially numerical noise and you should switch to the imaginary part.  The resulting field images are shown below:     TM band 1  TM band 2  TM band 3  TM band 4  TM band 5  TM band 6  TM band 7  TM band 8                 Your images should look the same as the ones above. If we hadn't included  fix-efield-phase  before  output-efield-z  in the ctl file, on the other hand, yours would have differed slightly (e.g. by a sign or a lattice shift), because by default the phase is  random .  When we look at the real parts of the fields, we are really looking at the fields of the modes at a particular instant in time and the imaginary part is half a period later. The point in time relative to the periodic oscillation of the state is determined by the phase of the eigenstate. The  fix-efield-phase  band function picks a canonical phase for the eigenstate, giving us a deterministic picture.  We can see several things from these plots:  First, the origin of the band gap is apparent. The lowest band is concentrated within the dielectric rods in order to minimize its frequency. The next bands, in order to be orthogonal, are forced to have a node within the rods, imposing a large \"kinetic energy\" (and/or \"potential energy\") cost and hence a gap. See  our online textbook , ch. 5. Successive bands have more and more complex nodal structures in order to maintain orthogonality. The contrasting absence of a large TE gap has to do with boundary conditions. The perpendicular component of the displacement field must be continuous across the dielectric boundary, but the parallel component need not be.  We can also see the deep impact of symmetry on the states. The K point has C 3v  symmetry and not quite the full C 6v  symmetry of the dielectric structure. This symmetry group has only one two-dimensional representation--that is what gives rise to the degenerate pairs of states (2/3, 4/5, and 7/8), all of which fall into this \"p-like\" category where the states transform like two orthogonal dipole field patterns, essentially. The other two bands, 1 and 6, transform under the trivial \"s-like\" representation with band 6 just a higher-order version of 1.", 
            "title": "The Source of the TM Gap: Examining the Modes"
        }, 
        {
            "location": "/Data_Analysis_Tutorial/#diamond-lattice-of-spheres", 
            "text": "Now, let us turn to a three-dimensional structure, a diamond lattice of dielectric spheres in air. See  our online textbook , ch. 6. The basic techniques to compute and analyze the modes of this structure are the same as in two dimensions, but of course, everything becomes more complicated in 3d. It's harder to find a structure with a complete gap, the modes are no longer polarized, the computations are bigger, and visualization is more difficult, for starters.  The control file for this calculation, which can also be found in  mpb-ctl/examples/diamond.ctl , consists of:", 
            "title": "Diamond Lattice of Spheres"
        }, 
        {
            "location": "/Data_Analysis_Tutorial/#diamond-control-file", 
            "text": "(set!\u00a0geometry-lattice\u00a0(make\u00a0lattice\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis-size\u00a0(sqrt\u00a00.5)\u00a0(sqrt\u00a00.5)\u00a0(sqrt\u00a00.5))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis1\u00a00\u00a01\u00a01)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis2\u00a01\u00a00\u00a01)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(basis3\u00a01\u00a01\u00a00)))\n\n;\u00a0Corners\u00a0of\u00a0the\u00a0irreducible\u00a0Brillouin\u00a0zone\u00a0for\u00a0the\u00a0fcc\u00a0lattice,\n;\u00a0in\u00a0a\u00a0canonical\u00a0order:\n\u00a0(set!\u00a0k-points\u00a0(interpolate\u00a04\u00a0(list\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00.5\u00a00.5)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0X\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00.625\u00a00.375)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0U\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00.5\u00a00)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0L\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00\u00a00)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0Gamma\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00\u00a00.5\u00a00.5)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0X\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00.25\u00a00.75\u00a00.5)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0W\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vector3\u00a00.375\u00a00.75\u00a00.375))))\u00a0\u00a0;\u00a0K\n\n\u00a0;\u00a0define\u00a0a\u00a0couple\u00a0of\u00a0parameters\u00a0(which\u00a0we\u00a0can\u00a0set\u00a0from\u00a0the\u00a0command-line)\n\u00a0(define-param\u00a0eps\u00a011.56)\u00a0;\u00a0the\u00a0dielectric\u00a0constant\u00a0of\u00a0the\u00a0spheres\n\u00a0(define-param\u00a0r\u00a00.25)\u00a0\u00a0\u00a0\u00a0;\u00a0the\u00a0radius\u00a0of\u00a0the\u00a0spheres\n\n\u00a0(define\u00a0diel\u00a0(make\u00a0dielectric\u00a0(epsilon\u00a0eps)))\n\n ;\u00a0A\u00a0diamond\u00a0lattice\u00a0has\u00a0two\u00a0 atoms \u00a0per\u00a0unit\u00a0cell:\n\u00a0(set!\u00a0geometry\u00a0(list\u00a0(make\u00a0sphere\u00a0(center\u00a00.125\u00a00.125\u00a00.125)\u00a0(radius\u00a0r)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0diel))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(make\u00a0sphere\u00a0(center\u00a0-0.125\u00a0-0.125\u00a0-0.125)\u00a0(radius\u00a0r)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(material\u00a0diel))))\n\n\u00a0;\u00a0(A\u00a0simple\u00a0fcc\u00a0lattice\u00a0would\u00a0have\u00a0only\u00a0one\u00a0sphere/object\u00a0at\u00a0the\u00a0origin.)\n\n (set-param!\u00a0resolution\u00a016)\u00a0;\u00a0use\u00a0a\u00a016x16x16\u00a0grid\n\u00a0(set-param!\u00a0mesh-size\u00a05)\n\u00a0(set-param!\u00a0num-bands\u00a05)\n\n ;\u00a0run\u00a0calculation,\u00a0outputting\u00a0electric-field\u00a0energy\u00a0density\u00a0at\u00a0the\u00a0U\u00a0point:\n (run\u00a0(output-at-kpoint\u00a0(vector3\u00a00\u00a00.625\u00a00.375)\u00a0output-dpwr))  As before, run the calculation, directing the output to a file. This will take a minute. We'll put it in the background with  nohup  so that it will finish even if we log out:  unix%\u00a0nohup\u00a0mpb\u00a0diamond.ctl\u00a0 \u00a0diamond.out\u00a0   Note that, because we used  define-param  and  set-param!  to define/set some variables (see the  libctl reference , we can change them from the command line. For example, to use a radius of 0.3 and a resolution of 20, we can just type  mpb r=0.3 resolution=20 diamond.ctl . This is an extremely useful feature, because it allows you to use one generic control file for many variations on the same structure.", 
            "title": "Diamond Control File"
        }, 
        {
            "location": "/Data_Analysis_Tutorial/#important-note-on-units-for-the-diamondfcc-lattice", 
            "text": "As usual,  all distances are in the dimensionless units determined by the length of the lattice vectors. We refer to these units as  a , and frequencies are given in units of  c/a . By default, the lattice/basis vectors are unit vectors, but in the case of fcc lattices this conflicts with the convention in the literature. In particular, the canonical  a  for fcc is the edge-length of a cubic supercell containing the lattice.  In order to follow this convention, we set the length of our basis vectors appropriately using the  basis-size  property of  geometry-lattice . The lattice vectors default to the same length as the basis vectors. If the cubic supercell edge has unit length ( a ), then the fcc lattice vectors have length sqrt(0.5), or  (sqrt 0.5)  in Scheme.", 
            "title": "Important Note on Units for the Diamond/FCC Lattice"
        }, 
        {
            "location": "/Data_Analysis_Tutorial/#gaps-and-band-diagram-for-the-diamond-lattice", 
            "text": "The diamond lattice has a complete band gap:  unix%\u00a0grep\u00a0Gap\u00a0diamond.out\nGap\u00a0from\u00a0band\u00a02\u00a0(0.396348703007373)\u00a0to\u00a0band\u00a03\u00a0(0.440813418580596),\u00a010.6227251392791%  We can also plot its band diagram, much as for the tri-rods case except that now we can't classify the bands by polarization.  unix%\u00a0grep\u00a0freqs\u00a0diamond.out\u00a0 \u00a0diamond.dat  The resulting band diagram, with the complete band gap shaded yellow, is shown below. Note that we only computed 5 bands, so in reality the upper portion of the plot would contain a lot more bands which are of less interest than the bands adjoining the gap.", 
            "title": "Gaps and Band Diagram for the Diamond Lattice"
        }, 
        {
            "location": "/Data_Analysis_Tutorial/#visualizing-the-diamond-lattice-structure-and-bands", 
            "text": "Visualizing fields in a useful way for general three-dimensional structures is fairly difficult, but we'll show you what we can with the help of the free  Vis5D  volumetric-visualization program, and the  h5tov5d  conversion program from  h5utils .  First, of course, we've got to rectangularize the unit cell using  mpb-data , as before. We'll also expand it to two periods in each direction.  unix%\u00a0mpb-data\u00a0-m\u00a02\u00a0-r\u00a0-n\u00a032\u00a0epsilon.h5\u00a0dpwr.k06.b*.h5  Then, we'll use  h5tov5d  to convert the resulting datasets to Vis5D format, joining all the datasets into a single file ( diamond.v5d ) so that we can view them simultaneously if we want to:  unix%\u00a0h5tov5d\u00a0-o\u00a0diamond.v5d\u00a0-d\u00a0data-new\u00a0epsilon.h5\u00a0dpwr.k06.b*.h5  Note that all of the datasets are named  data-new  from the original datasets called  data  since we are looking at scalar data (the time-averaged electric-field energy density). No messy field components or real and imaginary parts this time; we have enough to deal with already.  Now we can open the file with Vis5D and play around with various plots of the data:  unix%\u00a0vis5d\u00a0diamond.v5d\u00a0   If you stare at the dielectric function long enough from various angles, you can convince yourself that it is a diamond lattice:   The lowest two bands have their fields concentrated within the spheres as you might expect, flowing along more-or-less linear paths. The second band differs from the first mainly by the orientation of its field paths. The fields for the first band at U are depicted below, with the strongest fields (highest energy density) shown as the most opaque, blue pixels. Next to it is the same plot but with an isosurface at the boundary of the dielectric superimposed, so you can see that the energy is concentrated inside the dielectric.    The first band above the gap is band 3. Its field energy densities are depicted below in the same manner as above. The field patterns are considerably harder to make out than for the lower band, but they seem to be more diffuse and \"clumpy,\" the latter likely indicating the expected field oscillations for orthogonality with the lower bands.", 
            "title": "Visualizing the Diamond Lattice Structure and Bands"
        }, 
        {
            "location": "/Scheme_User_Interface/", 
            "text": "Scheme User Interface\n\n\n\n\nThe user interface is documented in this page. We do not document the Scheme language or the functions provided by \nlibctl\n. See also the \nlibctl User Reference\n section of the \nlibctl manual\n.\n\n\nTable of Contents\n\n\nScheme User Interface\n\n\nInput Variables\n\n\nPredefined Variables\n\n\nOutput Variables\n\n\nClasses\n\n\nlattice\n\n\nmaterial-type\n\n\ngeometric-object\n\n\n\n\n\n\nFunctions\n\n\nGeometry Utilities\n\n\nCoordinate Conversion Functions\n\n\nRun Functions\n\n\nThe Inverse Problem: k as a Function of Frequency\n\n\nBand/Output Functions\n\n\nMiscellaneous Functions\n\n\nParity\n\n\nGroup Velocities\n\n\n\n\n\n\n\n\n\n\nField Manipulation\n\n\nField Normalization\n\n\nLoading and Manipulating the Current Field\n\n\nStoring and Combining Multiple Fields\n\n\nStored Fields and Bloch Phases\n\n\n\n\n\n\nManipulating the Raw Eigenvectors\n\n\n\n\n\n\nInversion Symmetry\n\n\nParallel MPB\n\n\nMPB with MPI Parallelization\n\n\nAlternative Parallelization: mpb-split\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInput Variables\n\n\nThese are global variables that you can set to control various parameters of the MPB computation. They are also listed, along with their current values, by the \n(help)\n command. In brackets after each variable is the type of value that it should hold. The classes, complex datatypes like \ngeometric-object\n, are described in a later subsection. The basic datatypes, like \ninteger\n, \nboolean\n, \ncnumber\n, and \nvector3\n, are defined by libctl.\n\n\ngeometry\n [ list of \ngeometric-object\n class ]\n\n\n\nSpecifies the geometric objects making up the structure being simulated. When objects overlap, later objects in the list take precedence. Defaults to no objects (empty list).\n\n\ndefault-material\n [ \nmaterial-type\n class ]\n\n\n\nHolds the default material that is used for points not in any object of the geometry list. Defaults to air (epsilon of 1). See also \nepsilon-input-file\n, below.\n\n\nensure-periodicity\n [\nboolean\n]\n\n\n\nIf true (the default), then geometric objects are treated as if they were shifted by all possible lattice vectors; i.e. they are made periodic in the lattice.\n\n\ngeometry-lattice\n [\nlattice\n class ]\n\n\n\nSpecifies the basis vectors and lattice size of the computational cell which is centered on the origin of the coordinate system. These vectors form the basis for all other 3-vectors in the geometry, and the lattice size determines the size of the primitive cell. If any dimension of the lattice size is the special value \nno-size\n, then the dimension of the lattice is reduced (i.e. it becomes two- or one-dimensional). That is, the dielectric function becomes two-dimensional; it is still, in principle, a three dimensional system, and the k-point vectors can be three-dimensional. Generally, you should make any \nno-size\n dimension(s) perpendicular to the others. Defaults to the orthogonal x-y-z vectors of unit length (i.e. a square/cubic lattice).\n\n\nresolution\n [\nnumber\n or \nvector3\n]\n\n\n\nSpecifies the computational grid resolution, in pixels per lattice unit (a lattice unit is one basis vector in a given direction). If \nresolution\n is a \nvector3\n, then specifies a different resolution for each direction; otherwise the resolution is uniform. The grid size is then the product of the lattice size and the resolution, rounded up to the next positive integer. Defaults to \n10\n. You can call \n(optimize-grid-size!)\n \nafter\n setting the \nresolution\n and \ngeometry-lattice\n to adjust the grid size for maximal performance. This rounds the grid size in each direction to the nearest integer with small factors, to improve FFT speed.\n\n\ngrid-size\n [\nvector3\n]\n\n\n\nSpecifies the size of the discrete computational grid along each of the lattice directions. \nDeprecated:\n the preferred method is to use the \nresolution\n variable, above, in which case the \ngrid-size\n defaults to \nfalse\n. To get the grid size you should instead use the \n(get-grid-size)\n function.\n\n\ndimensions\n [\ninteger\n]\n\n\n\nExplicitly specifies the dimensionality of the simulation; if the value is less than 3, the sizes of the extra dimensions in \ngrid-size\n are ignored (assumed to be one). Defaults to 3. \nDeprecated:\n the preferred method is to set \ngeometry-lattice\n to have size no-size in any unwanted dimensions.\n\n\nk-points\n [ list of \nvector3\n]\n\n\n\nList of Bloch wavevectors to compute the bands at, expressed in the basis of the reciprocal lattice vectors. The reciprocal lattice vectors are defined as follows (see \nour online textbook\n, appendix B): Given the lattice vectors R\ni\n (\nnot\n the basis vectors), the reciprocal lattice vector G\nj\n satisfies R\ni\n * G\nj\n = 2\ni,j\n, where \ni,j\n is the Kronecker delta (1 for \ni=j\n and 0 otherwise). R\ni\n for any \nno-size\n dimensions is taken to be the corresponding basis vector. Normally, the wavevectors should be in the first Brillouin zone (\nsee below\n). \nk-points\n defaults to none (empty list).\n\n\nnum-bands\n [\ninteger\n]\n \n\n\n\nNumber of bands (eigenvectors) to compute at each k point. Defaults to 1.\n\n\ntarget-freq\n [\nnumber\n]\n\n\n\nIf zero, the lowest-frequency \nnum-bands\n states are solved for at each k point (ordinary eigenproblem). If non-zero, solve for the \nnum-bands\n states whose frequencies have the smallest absolute difference with \ntarget-freq\n (special, \"targeted\" eigenproblem). Beware that the targeted solver converges more slowly than the ordinary eigensolver and may require a lower \ntolerance\n to get reliable results. Defaults to 0.\n\n\ntolerance\n [\nnumber\n]\n\n\n\nSpecifies when convergence of the eigensolver is judged to have been reached when the eigenvalues have a fractional change less than \ntolerance\n between iterations. Defaults to 1.0e-7.\n\n\nfilename-prefix\n [\nstring\n]\n\n\n\nA string prepended to all output filenames. Defaults to \n\"FILE-\"\n, where your control file is FILE.ctl. You can change this to \nfalse\n to use no prefix.\n\n\nepsilon-input-file\n [\nstring\n]\n\n\n\nIf this string is not \n\"\"\n (the default), then it should be the name of an HDF5 file whose first/only dataset defines a dielectric function over some discrete grid. This dielectric function is then used in place of \ndefault-material\n (\ni.e.\n where there are no \ngeometry\n objects). The grid of the epsilon file dataset need not match \ngrid-size\n; it is scaled and/or linearly interpolated as needed. The lattice vectors for the epsilon file are assumed to be the same as \ngeometry-lattice\n. Note that, even if the grid sizes match and there are no geometric objects, the dielectric function used by MPB will not be exactly the dielectric function of the epsilon file, unless you also set \nmesh-size\n to 1 (see above).\n\n\neigensolver-block-size\n [\ninteger\n]\n\n\n\nThe eigensolver uses a \"block\" algorithm, which means that it solves for several bands simultaneously at each k-point. \neigensolver-block-size\n specifies this number of bands to solve for at a time; if it is zero or \n= \nnum-bands\n, then all the bands are solved for at once. If \neigensolver-block-size\n is a negative number, -\nn\n, then MPB will try to use nearly-equal block-sizes close to \nn\n. Making the block size a small number can reduce the memory requirements of MPB, but block sizes \n 1 are usually more efficient. There is typically some optimum size for any given problem. Defaults to -11 (i.e. solve for around 11 bands at a time).\n\n\nsimple-preconditioner?\n [\nboolean\n]\n\n\n\nWhether or not to use a simplified preconditioner. Defaults to \nfalse\n which is fastest most of the time. Turning this on increases the number of iterations, but decreases the time for each iteration.\n\n\ndeterministic?\n [\nboolean\n]\n\n\n\nSince the fields are initialized to random values at the start of each run, there are normally slight differences in the number of iterations, etcetera, between runs. Setting \ndeterministic?\n to \ntrue\n makes things deterministic. The default is \nfalse\n.\n\n\neigensolver-flags\n [\ninteger\n]\n\n\n\nThis variable is undocumented and reserved for use by Jedi Masters only.\n\n\nPredefined Variables\n\n\nVariables predefined for your convenience and amusement.\n\n\nair\n, \nvacuum\n [\nmaterial-type\n class ]\n\n\n\nTwo aliases for a predefined material type with a dielectric constant of 1.\n\n\nnothing\n [\nmaterial-type\n class ]\n\n\n\nA material that, effectively, punches a hole through other objects to the background (\ndefault-material\n or \nepsilon-input-file\n).\n\n\ninfinity\n [\nnumber\n]\n\n\n\nA big number (1e20) to use for \"infinite\" dimensions of objects.\n\n\nOutput Variables\n\n\nGlobal variables whose values are set upon completion of the eigensolver.\n\n\nfreqs\n [ list of \nnumber\n]\n\n\n\nA list of the frequencies of each band computed for the last k point. Guaranteed to be sorted in increasing order. The frequency of band \nb\n can be retrieved via \n(list-ref freqs (- b 1))\n.\n\n\niterations\n [\ninteger\n]\n\n\n\nThe number of iterations required for convergence of the last k point.\n\n\nparity\n [\nstring\n]\n\n\n\nA string describing the current required parity/polarization (\nte\n, \nzeven\n, etcetera, or \"\" for none). Useful for prefixing output lines for grepping.\n\n\nYet more global variables are set by the \nrun\n function and its variants, for use after \nrun\n completes or by a band function which is called for each band during the execution of \nrun\n.\n\n\ncurrent-k\n [\nvector3\n]\n\n\n\nThe k point most recently solved from the \nk-points\n list.\n\n\ngap-list\n [ list of (\npercent freq-min freq-max\n) lists ]\n\n\n\nThis is a list of the gaps found by the eigensolver, and is set by the \nrun\n functions when two or more k-points are solved. It is the empty list if no gaps are found.\n\n\nband-range-data\n [ list of ((\nmin .  kpoint\n) . (\nmax . kpoint\n)) ]\n\n\n\nFor each band, this list contains the minimum and maximum frequencies of the band, and the associated k points where the extrema are achieved. Note that the bands are defined by sorting the frequencies in increasing order, so this can be confused if two bands cross.\n\n\nClasses\n\n\nClasses are complex datatypes with various \"properties\" which may have default values. Classes can be \"subclasses\" of other classes; subclasses inherit all the properties of their superclass, and can be used any place the superclass is expected. An object of a class is constructed with:\n\n\n(make class (prop1 val1) (prop2 val2) ...)\n\n\n\n\nSee also the \nlibctl manual\n.\n\n\nMPB defines several types of classes, the most numerous of which are the various geometric object classes. You can also get a list of the available classes, along with their property types and default values, at runtime with the \n(help)\n command.\n\n\nlattice\n\n\nThe lattice class is normally used only for the \ngeometry-lattice\n variable and specifies the three lattice directions of the crystal and the lengths of the corresponding lattice vectors.\n\n\nbasis1, basis2, basis3\n [\nvector3\n]\n\n\n\nThe three lattice directions of the crystal, specified in the cartesian basis. The lengths of these vectors are ignored--only their directions matter. The lengths are determined by the \nbasis-size\n property, below. These vectors are then used as a basis for all other 3-vectors in the ctl file. They default to the x, y, and z directions, respectively.\n\n\nbasis-size\n [\nvector3\n]\n\n\n\nThe components of \nbasis-size\n are the lengths of the three basis vectors, respectively. They default to unit lengths.\n\n\nsize\n [\nvector3\n]\n\n\n\nThe size of the lattice (i.e. the length of the lattice vectors R\ni\n, in which the crystal is periodic) in units of the basis vectors. Thus, the actual lengths of the lattice vectors are given by the components of \nsize\n multiplied by the components of \nbasis-size\n. Alternatively, you can think of \nsize\n as the vector between opposite corners of the primitive cell, specified in the lattice basis. Defaults to unit lengths.\n\n\nIf any dimension has the special size \nno-size\n, then the dimensionality of the problem is reduced by one. Strictly speaking, the dielectric function is taken to be uniform along that dimension. In this case, the \nno-size\n dimension should generally be orthogonal to the other dimensions.\n\n\nmaterial-type\n\n\nThis class is used to specify the materials that geometric objects are made of. Currently, there are three subclasses, \ndielectric\n, \ndielectric-anisotropic\n, and \nmaterial-function\n.\n\n\ndielectric\n\n\n\nA uniform, isotropic, linear dielectric material, with one property:\n\n\nepsilon\n [\nnumber\n]\n\n\n\nThe dielectric constant (must be positive). No default value. You can also use \n(index n)\n as a synonym for \n(epsilon (* n n))\n.\n\n\ndielectric-anisotropic\n\n\n\nA uniform, possibly anisotropic, linear dielectric material. For this material type, you specify the dielectric tensor \n\\varepsilon\n, which is real-symmetric or possibly complex-hermitian, relative to the cartesian xyz axes:\n\n\n\\begin{pmatrix} a \n u \n v \\\\ u^* \n b \n w \\\\ v^* \n w^* \n c \\end{pmatrix}\n\n\nThis allows your dielectric to have different dielectric constants for fields polarized in different directions. The epsilon tensor must be positive-definite (have all positive eigenvalues); if it is not, MPB exits with an error. This does \nnot\n imply that all of the entries of the epsilon matrix need be positive. The components of the tensor are specified via three properties:\n\n\nepsilon-diag\n [\nvector3\n]\n\n\n\nThe diagonal elements (a b c) of the dielectric tensor. No default value.\n\n\nepsilon-offdiag\n [\ncvector3\n]\n\n\n\nThe off-diagonal elements (u v w) of the dielectric tensor. Defaults to zero. This is a \ncvector3\n, which simply means that the components may be complex numbers (e.g. \n3+0.1i\n). If non-zero imaginary parts are specified, then the dielectric tensor is complex-hermitian. This is only supported when MPB is configured with the \n--with-hermitian-eps\n flag. This is not dissipative (the eigenvalues of epsilon are real), but rather breaks time-reversal symmetry, corresponding to a gyrotropic (magneto-optic) material (see \nour online textbook\n, ch. 2). Note that \ninversion symmetry\n may not mean what you expect for complex-hermitian epsilon, so be cautious about using \nmpbi\n in this case.\n\n\nepsilon-offdiag-imag\n [\nvector3\n]\n\n\n\n\nDeprecated:\n The imaginary parts of the off-diagonal elements (u v w) of the dielectric tensor; defaults to zero. Setting the imaginary parts directly by specifying complex numbers in \nepsilon-offdiag\n is preferred.\n\n\nFor example, a material with a dielectric constant of 3.0 for P-polarization and 5.0 for S-polarization would be specified via \n(make (dielectric-anisotropic (epsilon-diag 3 3 5)))\n. Please \nbe aware\n that not all 2d anisotropic dielectric structures will have P- and S-polarized modes, however.\n\n\nmaterial-function\n\n\n\nThis material type allows you to specify the material as an arbitrary function of position. For an example of this, see the \nbragg-sine.ctl\n file in the \nexamples/\n directory. It has one property:\n\n\nmaterial-func\n [\nfunction\n]\n\n\n\nA function of one argument, the position \nvector3\n in lattice coordinates, that returns the material at that point. Note that the function you supply can return \nany\n material; wild and crazy users could even return another \nmaterial-function\n object which would then have its function invoked in turn.\n\n\nInstead of \nmaterial-func\n, you can use \nepsilon-func\n: for \nepsilon-func\n, you give it a function of position that returns the dielectric constant at that point.\n\n\nNormally, the dielectric constant is required to be positive or positive-definite, for a tensor. However, MPB does have a somewhat experimental feature allowing negative dielectrics (e.g. in a plasma). To use it, call the function \n(allow-negative-epsilon)\n before \n(run)\n. In this case, it will output the (real) frequency \nsquared\n in place of the (possibly imaginary) frequencies. Convergence will be somewhat slower because the eigenoperator is not positive definite.\n\n\ngeometric-object\n\n\nThis class, and its descendants, are used to specify the solid geometric objects that form the dielectric structure being simulated. The properties are:\n\n\nmaterial\n [\nmaterial-type\n class ]\n\n\n\nThe material that the object is made of which is usually some sort of dielectric. No default value. Must be specified.\n\n\ncenter\n [\nvector3\n]\n\n\n\nCenter point of the object. No default value.\n\n\nOne normally does not create objects of type \ngeometric-object\n directly, however; instead, you use one of the following subclasses. Recall that subclasses inherit the properties of their superclass, so these subclasses automatically have the \nmaterial\n and \ncenter\n properties which must be specified, since they have no default values.\n\n\nRecall that all 3-vectors, including the center of an object, its axes, and so on, are specified in the basis of the normalized lattice vectors normalized to \nbasis-size\n. Note also that 3-vector properties can be specified by either \n(property (vector3 x y z))\n or, equivalently, \n(property x y z)\n.\n\n\nIn a two-dimensional calculation, only the intersections of the objects with the x-y plane are considered.\n\n\nsphere\n\n\n\nA sphere. Properties:\n\n\nradius\n [\nnumber\n]\n\n\n\nRadius of the sphere. No default value.\n\n\ncylinder\n\n\n\nA cylinder, with circular cross-section and finite height. Properties:\n\n\nradius\n [\nnumber\n]\n\n\n\nRadius of the cylinder's cross-section. No default value.\n\n\nheight\n [\nnumber\n]\n\n\n\nLength of the cylinder along its axis. No default value.\n\n\naxis\n [\nvector3\n]\n\n\n\nDirection of the cylinder's axis; the length of this vector is ignored. Defaults to point parallel to the z axis.\n\n\ncone\n\n\n\nA cone, or possibly a truncated cone. This is actually a subclass of \ncylinder\n, and inherits all of the same properties, with one additional property. The radius of the base of the cone is given by the \nradius\n property inherited from \ncylinder\n, while the radius of the tip is given by the new property, \nradius2\n. The \ncenter\n of a cone is halfway between the two circular ends.\n\n\nradius2\n [\nnumber\n]\n\n\n\nRadius of the tip of the cone (i.e. the end of the cone pointed to by the \naxis\n vector). Defaults to zero (a \"sharp\" cone).\n\n\nblock\n\n\n\nA parallelepiped (i.e., a brick, possibly with non-orthogonal axes). Properties:\n\n\nsize\n [\nvector3\n]\n\n\n\nThe lengths of the block edges along each of its three axes. Not really a 3-vector (at least, not in the lattice basis), but it has three components, each of which should be nonzero. No default value.\n\n\ne1\n, \ne2\n, \ne3\n [\nvector3\n]\n\n\n\nThe directions of the axes of the block; the lengths of these vectors are ignored. Must be linearly independent. They default to the three lattice directions.\n\n\nellipsoid\n\n\n\nAn ellipsoid. This is actually a subclass of \nblock\n, and inherits all the same properties, but defines an ellipsoid inscribed inside the block.\n\n\nHere are some examples of geometric objects created using the above classes, assuming that the lattice directions (the basis) are just the ordinary unit axes, and \nm\n is some material we have defined:\n\n\n;\u00a0A\u00a0cylinder\u00a0of\u00a0infinite\u00a0radius\u00a0and\u00a0height\u00a00.25\u00a0pointing\u00a0along\u00a0the\u00a0x\u00a0axis,\n;\u00a0centered\u00a0at\u00a0the\u00a0origin:\n(make\u00a0cylinder\u00a0(center\u00a00\u00a00\u00a00)\u00a0(material\u00a0m)\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(radius\u00a0infinity)\u00a0(height\u00a00.25)\u00a0(axis\u00a01\u00a00\u00a00))\n\n\n\n\n;\u00a0An\u00a0ellipsoid\u00a0with\u00a0its\u00a0long\u00a0axis\u00a0pointing\u00a0along\u00a0(1,1,1),\u00a0centered\u00a0on\n;\u00a0the\u00a0origin\u00a0(the\u00a0other\u00a0two\u00a0axes\u00a0are\u00a0orthogonal\u00a0and\u00a0have\u00a0equal\n;\u00a0semi-axis\u00a0lengths):\n(make\u00a0ellipsoid\u00a0(center\u00a00\u00a00\u00a00)\u00a0(material\u00a0m)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(size\u00a00.8\u00a00.2\u00a00.2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(e1\u00a01\u00a01\u00a01)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(e2\u00a00\u00a01\u00a0-1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(e3\u00a0-2\u00a01\u00a01))\n\n\n\n\n;\u00a0A\u00a0unit\u00a0cube\u00a0of\u00a0material\u00a0m\u00a0with\u00a0a\u00a0spherical\u00a0air\u00a0hole\u00a0of\u00a0radius\u00a00.2\u00a0at\n;\u00a0its\u00a0center,\u00a0the\u00a0whole\u00a0thing\u00a0centered\u00a0at\u00a0(1,2,3):\n(set!\u00a0geometry\u00a0(list\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(make\u00a0block\u00a0(center\u00a01\u00a02\u00a03)\u00a0(material\u00a0m)\u00a0(size\u00a01\u00a01\u00a01))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(make\u00a0sphere\u00a0(center\u00a01\u00a02\u00a03)\u00a0(material\u00a0air)\u00a0(radius\u00a00.2))))\n\n\n\n\nFunctions\n\n\nHere, we describe the functions that are defined by MPB. There are many types of functions defined ranging from utility functions for duplicating geometric objects to run functions that start the computation.\n\n\nSee also the \nreference section\n of the libctl manual, which describes a number of useful functions defined by libctl.\n\n\nGeometry Utilities\n\n\nSome utility functions are provided to help you manipulate geometric objects:\n\n\n(shift-geometric-object obj shift-vector)\n\n\n\nTranslate \nobj\n by the 3-vector \nshift-vector\n.\n\n\n(geometric-object-duplicates shift-vector min-multiple max-multiple obj)\n\n\n\nReturn a list of duplicates of \nobj\n, shifted by various multiples of \nshift-vector\n from \nmin-multiple\n to \nmax-multiple\n, inclusive, in steps of 1.\n\n\n(geometric-objects-duplicates shift-vector min-multiple max-multiple obj-list)\n\n\n\nSame as \ngeometric-object-duplicates\n, except operates on a list of objects, \nobj-list\n. If \nA\n appears before \nB\n in the input list, then all the duplicates of \nA\n appear before all the duplicates of \nB\n in the output list.\n\n\n(geometric-objects-lattice-duplicates obj-list [ ux uy uz ])\n\n\n\nDuplicates the objects in \nobj-list\n by multiples of the lattice basis vectors, making all possible shifts of the \"primitive cell\" (see below) that fit inside the lattice cell. This is useful for supercell calculations. See the \ntutorial\n. The primitive cell to duplicate is \nux\n by \nuy\n by \nuz\n, in units of the basis vectors. These three parameters are optional; any that you do not specify are assumed to be \n1\n.\n\n\n(point-in-object? point obj)\n\n\n\nReturns whether or not the given 3-vector \npoint\n is inside the geometric object \nobj\n.\n\n\n(point-in-periodic-object? point obj)\n\n\n\nAs \npoint-in-object?\n, but also checks translations of the given object by the lattice vectors.\n\n\n(display-geometric-object-info indent-by obj)\n\n\n\nOutputs some information about the given \nobj\n, indented by \nindent-by\n spaces.\n\n\nCoordinate Conversion Functions\n\n\nThe following functions allow you to easily convert back and forth between the lattice, cartesian, and reciprocal bases. See also the \nnote on units\n in the tutorial.\n\n\n(lattice-\ncartesian x)\n, \n(cartesian-\nlattice x)\n\n\n\nConvert \nx\n between the lattice basis (the basis of the lattice vectors normalized to \nbasis-size\n) and the ordinary cartesian basis, where \nx\n is either a \nvector3\n or a \nmatrix3x3\n, returning the transformed vector/matrix. In the case of a matrix argument, the matrix is treated as an operator on vectors in the given basis, and is transformed into the same operator on vectors in the new basis.\n\n\n(reciprocal-\ncartesian x)\n, \n(cartesian-\nreciprocal x)\n\n\n\nLike the above, except that they convert to/from reciprocal space (the basis of the reciprocal lattice vectors). Also, the cartesian vectors output/input are in units of 2\n.\n\n\n(reciprocal-\nlattice x)\n, \n(lattice-\nreciprocal x)\n\n\n\nConvert between the reciprocal and lattice bases, where the conversion again leaves out the factor of 2\n (i.e. the lattice-basis vectors are assumed to be in units of 2\n).\n\n\nAlso, a couple of rotation functions are defined, for convenience, so that you don't have to explicitly convert to cartesian coordinates in order to use libctl's \nrotate-vector3\n function. See the \nLibctl User Reference\n:\n\n\n(rotate-lattice-vector3 axis theta v)\n, \n(rotate-reciprocal-vector3 axis theta v)\n\n\n\nLike \nrotate-vector3\n , except that \naxis\n and \nv\n are specified in the lattice/reciprocal bases.\n\n\nUsually, k-points are specified in the first Brillouin zone, but sometimes it is convenient to specify an arbitrary k-point. However, the accuracy of MPB degrades as you move farther from the first Brillouin zone due to the choice of a fixed planewave set for a basis. This is easily fixed: simply transform the k-point to a corresponding point in the first Brillouin zone, and a completely equivalent solution (identical frequency, fields, etcetera) is obtained with maximum accuracy. The following function accomplishes this:\n\n\n(first-brillouin-zone k)\n\n\n\nGiven a k-point \nk\n in the basis of the reciprocal lattice vectors, as usual, return an equivalent point in the first Brillouin zone of the current lattice (\ngeometry-lattice\n).\n\n\nNote that \nfirst-brillouin-zone\n can be applied to the entire \nk-points\n list with the Scheme expression: \n(map first-brillouin-zone k-points)\n.\n\n\nRun Functions\n\n\nThese are functions to help you run and control the simulation. The ones you will most commonly use are the \nrun\n function and its variants. The syntax of these functions, and one lower-level function, is:\n\n\n(run\n \nband-func\n \n...)\n\n\n\nThis runs the simulation described by the input parameters (see above), with no constraints on the polarization of the solution. That is, it reads the input parameters, initializes the simulation, and solves for the requested eigenstates of each k-point. The dielectric function is outputted to \nepsilon.h5\n before any eigenstates are computed. \nrun\n takes as arguments zero or more \"band functions\" \nband-func\n. A band function should be a function of one integer argument, the band index, so that \n(band-func\n \nwhich-band)\n performs some operation on the band \nwhich-band\n (e.g. outputting fields). After every k-point, each band function is called for the indices of all the bands that were computed. Alternatively, a band function may be a \"thunk\" (function of zero arguments), in which case \n(band-func)\n is called exactly once per k-point.\n\n\n(run-zeven\n \nband-func\n \n...)\n, \n(run-zodd\n \nband-func\n \n...)\n\n\n\nThese are the same as the \nrun\n function except that they constrain their solutions to have even and odd symmetry with respect to the z=0 plane. You should use these functions \nonly\n for structures that are symmetric through the z=0 mirror plane, where the third basis vector is in the z direction (0,0,1) and is orthogonal to the other two basis vectors, and when the k vectors are in the xy plane. Under these conditions, the eigenmodes always have either even or odd symmetry. In two dimensions, even/odd parities are equivalent to P/S polarizations, respectively and are often strongly analogous even in 3d. Such a symmetry classification is useful for structures such as waveguides and photonic-crystal slabs. See the \nonline book\n (ch. 3).\n\n\n(run-te\n \nband-func\n \n...)\n, \n(run-tm\n \nband-func\n \n...)\n\n\n\nThese are the same as the \nrun\n function except that they constrain their solutions to be TE- and TM-polarized, respectively, in two dimensions. The TE and TM polarizations are defined has having electric and magnetic fields in the xy plane, respectively. Equivalently, the H/E field of TE/TM light has only a z component (making it easier to visualize).\n\n\nThese functions are actually equivalent to calling \nrun-zeven\n and \nrun-zodd\n, respectively. Note that for the modes to be segregated into TE and TM polarizations, the dielectric function must have mirror symmetry for reflections through the xy plane. If you use \nanisotropic dielectrics\n, you should be aware that they break this symmetry if the z direction is not one of the principle axes. If you use \nrun-te\n or \nrun-tm\n in such a case of broken symmetry, MPB will exit with an error.\n\n\n(run-yeven\n \nband-func\n \n...)\n, \n(run-yodd\n \nband-func\n \n...)\n\n\n\nThese functions are analogous to \nrun-zeven\n and \nrun-zodd\n, except that they constrain their solutions to have even and odd symmetry with respect to the y=0 plane. You should use these functions \nonly\n for structures that are symmetric through the y=0 mirror plane, where the second basis vector is in the y direction (0,1,0) and is orthogonal to the other two basis vectors, and when the k vectors are in the xz plane.\n\n\nrun-yeven-zeven\n, \nrun-yeven-zodd\n, \nrun-yodd-zeven\n, \nrun-yodd-zodd\n, \nrun-te-yeven\n, \nrun-te-yodd\n, \nrun-tm-yeven\n, \nrun-tm-yodd\n\n\n\nThese \nrun\n-like functions combine the \nyeven\n/\nyodd\n constraints with \nzeven\n/\nzodd\n or \nte\n/\ntm\n. See also \nrun-parity\n, below.\n\n\n(run-parity\n \np reset-fields band-func\n \n...)\n\n\n\nLike the \nrun\n function, except that it takes two extra parameters, a parity \np\n and a boolean (\ntrue\n/\nfalse\n) value \nreset-fields\n. \np\n specifies a parity constraint, and should be one of the predefined variables:\n\n\n\n\nNO-PARITY\n: equivalent to \nrun\n\n\nEVEN-Z\n (or \nTE\n): equivalent to \nrun-zeven\n or \nrun-te\n\n\nODD-Z\n (or \nTM\n): equivalent to \nrun-zodd\n or \nrun-tm\n\n\nEVEN-Y\n (like \nEVEN-Z\n but for y=0 plane)\n\n\nODD-Y\n (like \nODD-Z\n but for y=0 plane)\n\n\n\n\nIt is possible to specify more than one symmetry constraint simultaneously by adding them, e.g. \n(+\n \nEVEN-Z\n \nODD-Y)\n requires the fields to be even through z=0 and odd through y=0. It is an error to specify incompatible constraints (e.g. \n(+\n \nEVEN-Z\n \nODD-Z)\n). \nImportant:\n if you specify the z/y parity, the dielectric structure \nand\n the k vector \nmust\n be symmetric about the z/y=0 plane, respectively. If \nreset-fields\n is \nfalse\n, the fields from any previous calculation will be reused as the starting point from this calculation, if possible; otherwise, the fields are reset to random values. The ordinary \nrun\n functions use a default \nreset-fields\n of\ntrue\n. Alternatively, \nreset-fields\n may be a string, the name of an HDF5 file to load the initial fields from as exported by \nsave-eigenvectors\n, as shown \nbelow\n.\n\n\n(display-eigensolver-stats)\n\n\n\nDisplay some statistics on the eigensolver convergence; this function is useful mainly for MPB developers in tuning the eigensolver.\n\n\nSeveral band functions for outputting the eigenfields are defined for your convenience, and are described in the \nsection below\n. You can also define your own band functions, and for this purpose the functions described in the section \nField manipulation functions\n, below, are useful. A band function takes the form:\n\n\n(define\u00a0(my-band-func\u00a0which-band)\n...do stuff here with band index which-band...\n)\n\n\n\n\nNote that the output variable \nfreqs\n may be used to retrieve the frequency of the band (see above). Also, a global variable \ncurrent-k\n is defined holding the current k-point vector from the \nk-points\n list.\n\n\nThere are also some even lower-level functions that you can call, although you should not need to do most of the time:\n\n\n(init-params p reset-fields?)\n\n\n\nRead the input variables and initialize the simulation in preparation for computing the eigenvalues. The parameters are the same as the first two parameters of \nrun-parity\n. This function \nmust\n be called before any of the other simulation functions below. Note, however, that the \nrun\n functions all call \ninit-params\n.\n\n\n(set-parity p)\n\n\n\nAfter calling \ninit-params\n, you can change the parity constraint without resetting the other parameters by calling this function. Beware that this does not randomize the fields (see below); you don't want to try to solve for, say, the TM eigenstates when the fields are initialized to TE states from a previous calculation.\n\n\n(randomize-fields)\n\n\n\nInitialize the fields to random values.\n\n\n(solve-kpoint k)\n\n\n\nSolve for the requested eigenstates at the Bloch wavevector \nk\n.\n\n\nThe Inverse Problem: k as a Function of Frequency\n\n\nMPB's \n(run)\n function(s) and its underlying algorithms compute the frequency \nw\n as a function of wavevector \nk\n. Sometimes, however, it is desirable to solve the inverse problem, for \nk\n at a given frequency \nw\n. This is useful, for example, when studying coupling in a waveguide between different bands at the same frequency since frequency is conserved even when wavevector is not. One also uses \nk(w)\n to construct wavevector diagrams, which aid in understanding diffraction (e.g. negative-diffraction materials and super-prisms). To solve such problems, therefore, we provide the \nfind-k\n function described below, which inverts \nw(k)\n via a few iterations of Newton's method using the group velocity \ndw/dk\n. Because it employs a root-finding method, you need to specify bounds on \nk\n and a \ncrude\n initial guess where order of magnitude is usually good enough.\n\n\n(find-k p omega band-min band-max kdir tol kmag-guess kmag-min kmag-max [band-func...])\n\n\n\nFind the wavevectors in the current geometry/structure for the bands from \nband-min\n to \nband-max\n at the frequency \nomega\n along the \nkdir\n direction in k-space. Returns a list of the wavevector magnitudes for each band; the actual wavevectors are \n(vector3-scale magnitude (unit-vector3 kdir))\n. The arguments of \nfind-k\n are:\n\n\n\n\np\n: parity (same as first argument to \nrun-parity\n, \nabove\n).\n\n\nomega\n: the frequency at which to find the bands\n\n\nband-min\n, \nband-max\n: the range of bands to solve for the wavevectors of (inclusive).\n\n\nkdir\n: the direction in k-space in which to find the wavevectors. (The magnitude of \nkdir\n is ignored.)\n\n\ntol\n: the fractional tolerance with which to solve for the wavevector; \n1e-4\n is usually sufficient. (Like the \ntolerance\n input variable, this is only the tolerance of the numerical iteration...it does not have anything to do with e.g. the error from finite grid \nresolution\n.)\n\n\nkmag-guess\n: an initial guess for the k magnitude (along \nkdir\n) of the wavevector at \nomega\n. Can either be a list (one guess for each band from \nband-min\n to \nband-max\n) or a single number (same guess for all bands, which is usually sufficient).\n\n\nkmag-min\n, \nkmag-max\n: a range of k magnitudes to search; should be large enough to include the correct k values for all bands.\n\n\nband-func\n: zero or more \nband functions\n, just as in \n(run)\n, which are evaluated at the computed k points for each band.\n\n\n\n\nThe \nfind-k\n routine also prints a line suitable for grepping:\n\n\nkvals: omega, band-min, band-max, kdir1, kdir2, kdir3, k magnitudes...\n\n\n\n\nBand/Output Functions\n\n\nAll of these are functions that, given a band index, output the corresponding field or compute some function thereof in the primitive cell of the lattice. They are designed to be passed as band functions to the \nrun\n routines, although they can also be called directly. See also the section on \nfield normalizations\n.\n\n\n(output-hfield which-band)\n\n\n(output-hfield-x which-band)\n\n\n(output-hfield-y which-band)\n\n\n(output-hfield-z which-band)\n\n\n\nOutput the magnetic (\n\\mathbf{H}\n) field for \nwhich-band\n; either all or one of the Cartesian components, respectively.\n\n\n(output-dfield which-band)\n\n\n(output-dfield-x which-band)\n\n\n(output-dfield-y which-band)\n\n\n(output-dfield-z which-band)\n\n\n\nOutput the electric displacement (\n\\mathbf{D}\n) field for \nwhich-band\n; either all or one of the Cartesian components, respectively.\n\n\n(output-efield which-band)\n\n\n(output-efield-x which-band)\n\n\n(output-efield-y which-band)\n\n\n(output-efield-z which-band)\n\n\n\nOutput the electric (\n\\mathbf{E}\n) field for \nwhich-band\n; either all or one of the Cartesian components, respectively.\n\n\n(output-hpwr which-band)\n\n\n\nOutput the time-averaged magnetic-field energy density (hpwr = \n|\\mathbf{H}|^2\n) for \nwhich-band\n.\n\n\n(output-dpwr which-band)\n\n\n\nOutput the time-averaged electric-field energy density (dpwr = \n\\varepsilon|\\mathbf{E}|^2\n) for \nwhich-band\n.\n\n\n(fix-hfield-phase which-band)\n\n\n(fix-dfield-phase which-band)\n\n\n(fix-efield-phase which-band)\n\n\n\nFix the phase of the given eigenstate in a canonical way based on the given spatial field. See also \nfix-field-phase\n, below. Otherwise, the phase is random. These functions also maximize the real part of the given field so that one can hopefully just visualize the real part. To fix the phase for output, pass one of these functions to \nrun\n before the corresponding output function, e.g. \n(run-tm fix-dfield-phase output-dfield-z)\n\n\nAlthough we try to maximize the \"real-ness\" of the field, this has a couple of limitations. First, the phase of the different field components cannot, of course, be chosen independently, so an individual field component may still be imaginary. Second, if you use \nmpbi\n to take advantage of \ninversion symmetry\n in your problem, the phase is mostly determined elsewhere in the program; \nfix-Xfield-phase\n in that case only determines the sign.\n\n\nSee also below for the \noutput-poynting\n and \noutput-tot-pwr\n functions to output the Poynting vector and the total electromagnetic energy density, respectively, and the \noutput-charge-density\n function to output the bound charge density.\n\n\nSometimes, you only want to output certain bands. For example, here is a function that, given an band/output function like the ones above, returns a new output function that only calls the first function for bands with a large fraction of their energy in an object(s). This is useful for picking out defect states in supercell calculations.\n\n\n(output-dpwr-in-objects\n \nband-func min-energy objects\n...)\n\n\n\nGiven a band function \nband-func\n, returns a new band function that only calls \nband-func\n for bands having a fraction of their electric-field energy greater than \nmin-energy\n inside the given objects (zero or more geometric objects). Also, for each band, prints the fraction of their energy in the objects in the following form which is suitable for grepping:\n\n\ndpwr:, band-index, frequency, energy-in-objects\n\n\n\n\noutput-dpwr-in-objects\n only takes a single band function as a parameter, but if you want it to call several band functions, you can easily combine them into one with the following routine:\n\n\n(combine-band-functions\n \nband-funcs\n...)\n\n\n\nGiven zero or more band functions, returns a new band function that calls all of them in sequence. When passed zero parameters, returns a band function that does nothing.\n\n\nIt is also often useful to output the fields only at a certain k-point, to let you look at typical field patterns for a given band while avoiding gratuitous numbers of output files. This can be accomplished via:\n\n\n(output-at-kpoint\n \nk-point band-funcs\n...)\n\n\n\nGiven zero or more band functions, returns a new band function that calls all of them in sequence, but only at the specified \nk-point\n. For other k-points, does nothing.\n\n\nMiscellaneous Functions\n\n\n(retrieve-gap lower-band)\n\n\n\nReturn the frequency gap from the band \nlower-band\n to the band \nlower-band+1\n, as a percentage of mid-gap frequency. The \"gap\" may be negative if the maximum of the lower band is higher than the minimum of the upper band. The gap is computed from the \nband-range-data\n of the previous run.\n\n\nParity\n\n\nGiven a set of eigenstates at a k-point, MPB can compute their \nparities\n with respect to the z=0 or y=0 plane. The z/y parity of a state is defined as the expectation value under the usual inner product of the mirror-flip operation through z/y=0, respectively. For true even and odd eigenstates (see e.g. \nrun-zeven\n and \nrun-zodd\n), this will be +1 and -1, respectively; for other states it will be something in between.\n\n\nThis is useful e.g. when you have a nearly symmetric structure, such as a waveguide with a substrate underneath, and you want to tell which bands are even-like (parity \n 0) and odd-like (parity \n 0). Indeed, any state can be decomposed into purely even and odd functions, with absolute-value-squared amplitudes of (1+parity)/2 and (1-parity)/2, respectively.\n\n\ndisplay-zparities\n, \ndisplay-yparities\n\n\n\nThese are band functions, designed to be passed to \n(run)\n, which output all of the z/y parities, respectively, at each k-point in comma-delimited format suitable for grepping.\n\n\n(compute-zparities)\n\n\n\nReturns a list of the parities about the z=0 plane, one number for each band computed at the last k-point.\n\n\n(compute-yparities)\n\n\n\nReturns a list of the parities about the y=0 plane, one number for each band computed at the last k-point.\n\n\nNote that the magnetic field is only a pseudo-vector, and is therefore multiplied by -1 under mirror-flip operations. For this reason, the magnetic field \nappears\n to have opposite symmetry from the electric field, but is really the same.\n\n\nGroup Velocities\n\n\nGiven a set of eigenstates at a given k-point, MPB can compute their group velocities (the derivative \nd\\omega/d\\mathbf{k}\n of frequency with respect to wavevector) using the Hellman-Feynmann theorem. Three functions are provided for this purpose, and we document them here from highest-level to lowest-level.\n\n\ndisplay-group-velocities\n\n\n\nThis is a band function, designed to be passed to \n(run)\n, which outputs all of the group velocity vectors (in the Cartesian basis, in units of \nc\n) at each k-point.\n\n\n(compute-group-velocities)\n\n\n\nReturns a list of group-velocity vectors (in the Cartesian basis, units of \nc\n) for the bands at the last-computed k-point.\n\n\n(compute-group-velocity-component direction)\n\n\n\nReturns a list of the group-velocity components (units of \nc\n) in the given \ndirection\n, one for each band at the last-computed k-point. \ndirection\n is a vector in the reciprocal-lattice basis like the k-points and its length is ignored. This has the advantage of being three times faster than \ncompute-group-velocities\n.\n\n\n(compute-1-group-velocity which-band)\n, \n(compute-1-group-velocity-component direction which-band)\n\n\n\nAs above, but returns the group velocity or component thereof only for band \nwhich-band\n.\n\n\nField Manipulation\n\n\nMPB provides a number of ways to take the field of a band and manipulate, process, or output it. These methods usually work in two stages. First, one loads a field into memory, computing it in position space, by calling one of the \nget\n functions below. Then, other functions can be called to transform or manipulate the field.\n\n\nThe simplest class of operations involve only the currently-loaded field, which we describe in the \nsecond subsection\n below. To perform more sophisticated operations, involving more than one field, one must copy or transform the current field into a new field variable, and then call one of the functions that operate on multiple field variables described in the \nthird subsection\n.\n\n\nField Normalization\n\n\nIn order to perform useful operations on the fields, it is important to understand how they are normalized. We normalize the fields in the way that is most convenient for perturbation and coupled-mode theory (see \nS.G. Johnson et al., (2002)\n and also \nour online textbook\n, ch. 2), so that their energy densities have unit integral. In particular, we normalize the electric (\n\\mathbf{E}\n), displacement (\n\\mathbf{D} = \\varepsilon \\mathbf{E}\n) and magnetic (\n\\mathbf{H} = -\\frac{i}{\\omega} \\nabla \\times \\mathbf{E}\n) fields, so that:\n\n\n\n\n\n\n\n\n-   (\\int \\varepsilon\n\n\n\\mathbf{E}\n\n\n^2  d^3\\mathbf{x} = 1)\n\n\n\n\n\n\n\n\n\n\nwhere the integrals are over the computational cell. Note the volume element \nd^3\\mathbf{x}\n which is the volume of a grid pixel/voxel. If you simply sum \n|\\mathbf{H}|^2\n over all the grid points, therefore, you will get (# grid points) / (volume of cell).\n\n\nNote that we have dropped the pesky factors of 1/2, \u03c0, etcetera from the energy densities, since these do not appear in e.g. perturbation theory, and the fields have arbitrary units anyway. The functions to compute/output energy densities below similarly use \n\\varepsilon |\\mathbf{E}|^2\n and \n|\\mathbf{H}|^2\n without any prefactors.\n\n\nLoading and Manipulating the Current Field\n\n\nIn order to load a field into memory, call one of the \nget\n functions follow. They should only be called after the eigensolver has run or after \ninit-params\n, in the case of \nget-epsilon\n. One normally calls them after \nrun\n, or in one of the band functions passed to \nrun\n.\n\n\n(get-hfield which-band)\n\n\n\nLoads the magnetic (\n\\mathbf{H}\n) field for the band \nwhich-band\n.\n\n\n(get-dfield which-band)\n\n\n\nLoads the electric displacement (\n\\mathbf{D}\n) field for the band \nwhich-band\n.\n\n\n(get-efield which-band)\n\n\n\nLoads the electric (\n\\mathbf{E}\n) field for the band \nwhich-band\n. This function actually calls \nget-dfield\n followed by \nget-efield-from-dfield\n, below.\n\n\n(get-charge-density which-band)\n\n\n\nLoads the bound charge density \n\\nabla \\cdot \\mathbf{E}\n for the band \nwhich-band\n.\n\n\n(get-epsilon)\n\n\n\nLoads the dielectric function.\n\n\nOnce loaded, the field can be transformed into another field or a scalar field:\n\n\n(get-efield-from-dfield)\n\n\n\nMultiplies by the inverse dielectric tensor to compute the electric field from the displacement field. Only works if a \n\\mathbf{D}\n field has been loaded.\n\n\n(fix-field-phase)\n\n\n\nFix the currently-loaded eigenstate's phase which is normally random in a canonical way, based on the spatial field (\n\\mathbf{H}\n, \n\\mathbf{D}\n, or \n\\mathbf{E}\n) that has currently been loaded. The phase is fixed to make the real part of the spatial field as big as possible so that you can hopefully visualize just the real part of the field, and a canonical sign is chosen. See also the \nfix-Xfield-phase\n band functions, above, which are convenient wrappers around \nfix-field-phase\n.\n\n\n(compute-field-energy)\n\n\n\nGiven the \n\\mathbf{H}\n or \n\\mathbf{D}\n fields, computes the corresponding energy density function normalized by the total energy in \n\\mathbf{H}\n or \n\\mathbf{D}\n, respectively. Also prints the fraction of the field in each of its Cartesian components in the following form which is suitable for grepping:\n\n\nf-energy-components:, k-index, band-index, x-fraction, y-fraction, z-fraction\n\n\n\n\nwhere \nf\n is either \nh\n or \nd\n. The return value of \ncompute-field-energy\n is a list of 7 numbers: \n(U xr xi yr yi zr zi)\n. \nU\n is the total, unnormalized energy, which is in arbitrary units deriving from the normalization of the eigenstate (e.g. the total energy for \n\\mathbf{H}\n is always 1.0). \nxr\n is the fraction of the energy in the real part of the field's x component, \nxi\n is the fraction in the imaginary part of the x component, etcetera (\nyr + yi = y-fraction\n, and so on).\n\n\n(compute-field-divergence)\n\n\n\nGiven a vector field, compute its divergence.\n\n\nVarious integrals and other information about the eigenstate can be accessed by the following functions, useful e.g. for perturbation theory. Functions dealing with the field vectors require a field to be loaded, and functions dealing with the energy density require an energy density to be loaded via \ncompute-field-energy\n.\n\n\n(compute-energy-in-dielectric min-eps max-eps)\n\n\n\nReturns the fraction of the energy that resides in dielectrics with epsilon in the range \nmin-eps\n to \nmax-eps\n.\n\n\n(compute-energy-in-objects objects...)\n\n\n\nReturns the fraction of the energy inside zero or more geometric objects.\n\n\n(compute-energy-integral f)\n\n\n\n\nf\n is a function \n(f u eps r)\n that returns a number given three parameters: \nu\n, the energy density at a point; \neps\n, the dielectric constant at the same point; and \nr\n, the position vector in lattice coordinates of the point. \ncompute-energy-integral\n returns the integral of \nf\n over the unit cell. The integral is computed simply as the sum over the grid points times the volume of a grid pixel/voxel. This can be useful e.g. for perturbation-theory calculations.\n\n\n(compute-field-integral f)\n\n\n\nLike \ncompute-energy-integral\n, but \nf\n is a function \n(f F eps r)\n that returns a number, possibly complex, where \nF\n is the complex field vector at the given point.\n\n\n(get-epsilon-point r)\n\n\n\nGiven a position vector \nr\n (in lattice coordinates), return the interpolated dielectric constant at that point. (Since MPB uses a an effective dielectric tensor internally, this actually returns the mean dielectric constant.)\n\n\n(get-epsilon-inverse-tensor-point r)\n\n\n\nGiven a position vector \nr\n in lattice coordinates, return the interpolated inverse dielectric tensor (a 3x3 matrix) at that point. Near a dielectric interface, the effective dielectric constant is a tensor even if you input only scalar dielectrics; see the \nepsilon overview\n for more information. The returned matrix may be complex-Hermetian if you are employing magnetic materials.\n\n\n(get-energy-point r)\n\n\n\nGiven a position vector \nr\n in lattice coordinates, return the interpolated energy density at that point.\n\n\n(get-field-point r)\n\n\n\nGiven a position vector \nr\n in lattice coordinates, return the interpolated (complex) field vector at that point.\n\n\n(get-bloch-field-point r)\n\n\n\nGiven a position vector \nr\n in lattice coordinates, return the interpolated complex Bloch field vector at that point. This is the field without the exp(ikx) envelope.\n\n\nFinally, we have the following functions to output fields (either the vector fields, the scalar energy density, or epsilon), with the option of outputting several periods of the lattice.\n\n\n(output-field [ nx [ ny [ nz ] ] ])\n\n\n(output-field-x [ nx [ ny [ nz ] ] ])\n\n\n(output-field-y [ nx [ ny [ nz ] ] ])\n\n\n(output-field-z [ nx [ ny [ nz ] ] ])\n\n\n\nOutput the currently-loaded field. The optional (as indicated by the brackets) parameters \nnx\n, \nny\n, and \nnz\n indicate the number of periods to be outputted along each of the three lattice directions. Omitted parameters are assumed to be 1. For vector fields, \noutput-field\n outputs all of the Cartesian components, while the other variants output only one component.\n\n\n(output-epsilon [ nx [ ny [ nz ] ] ])\n\n\n\nA shortcut for calling \nget-epsilon\n followed by \noutput-field\n. Note that, because epsilon is a tensor, a number of datasets are outputted in \n\"epsilon.h5\"\n:\n\n\n\n\n\"data\"\n: 3/trace(1/epsilon)\n\n\n\"epsilon.{xx,xy,xz,yy,yz,zz}\"\n: the (Cartesian) components of the (symmetric) dielectric tensor.\n\n\n\"epsilon_inverse.{xx,xy,xz,yy,yz,zz}\"\n: the (Cartesian) components of the (symmetric) inverse dielectric tensor.\n\n\n\n\nStoring and Combining Multiple Fields\n\n\nIn order to perform operations involving multiple fields, e.g. computing the Poynting vector \n\\mathbf{E}^* \\times \\mathbf{H}\n, they must be stored in field variables. Field variables come in three flavors, real-scalar (rscalar) fields, complex-scalar (cscalar) fields, and complex-vector (cvector) fields. There is a pre-defined field variable \ncur-field\n representing the currently-loaded field (see above), and you can \"clone\" it to create more field variables with one of:\n\n\n(field-make f)\n\n\n\nReturn a new field variable of the same type and size as the field variable \nf\n. Does \nnot\n copy the field contents. See \nfield-copy\n and \nfield-set!\n, below.\n\n\n(rscalar-field-make f)\n\n\n(cscalar-field-make f)\n\n\n(cvector-field-make f)\n\n\n\nLike \nfield-make\n, but return a real-scalar, complex-scalar, or complex-vector field variable, respectively, of the same size as \nf\n but ignoring \nf\n's type.\n\n\n(cvector-field-nonbloch! f)\n\n\n\nBy default, complex vector fields are assumed to be Bloch-periodic and are multiplied by \ne\nikx\n in output routines. This function tells MPB that the complex vector field \nf\n should never be multiplied by Bloch phases.\n\n\n(field-set! fdest fsrc)\n\n\n\nSet \nfdest\n to store the same field values as \nfsrc\n, which must be of the same size and type.\n\n\n(field-copy f)\n\n\n\nReturn a new field variable that is exact copy of \nf\n; this is equivalent to calling \nfield-make\n followed by \nfield-set!\n.\n\n\n(field-load f)\n\n\n\nLoads the field \nf\n as the current field, at which point you can use all of the functions in the \nprevious section\n to operate on it or output it.\n\n\nOnce you have stored the fields in variables, you probably want to compute something with them. This can be done in three ways: combining fields into new fields with \nfield-map!\n (e.g. combine \n\\mathbf{E}\n and \n\\mathbf{H}\n to \n\\mathbf{E}^* \\times \\mathbf{H}\n), integrating some function of the fields with \nintegrate-fields\n (e.g. to compute coupling integrals for perturbation theory), and getting the field values at arbitrary points with \n*-field-get-point\n (e.g. to do a line or surface integral). These three functions are described below:\n\n\n(field-map! fdest func [f1 f2 ...])\n\n\n\nCompute the new field \nfdest\n to be \n(func f1-val f2-val ...)\n at each point in the grid, where \nf1-val\n etcetera is the corresponding value of \nf1\n etcetera. All the fields must be of the same size, and the argument and return types of \nfunc\n must match those of the \nf1...\n and \nfdest\n fields, respectively. \nfdest\n may be the same field as one of the \nf1...\n arguments. Note: all fields are \nwithout\n Bloch phase factors exp(ikx).\n\n\n(integrate-fields func [f1 f2 ...])\n\n\n\nCompute the integral of the function \n(func r [f1 f2 ...])\n over the computational cell, where \nr\n is the position in the usual lattice basis and \nf1\n etc. are fields which must all be of the same size. The integral is computed simply as the sum over the grid points times the volume of a grid pixel/voxel. Note: all fields are \nwithout\n Bloch phase factors exp(ikx). See also the note \nbelow\n.\n\n\n(cvector-field-get-point f r)\n\n\n(cvector-field-get-point-bloch f r)\n\n\n(rscalar-field-get-point f r)\n\n\n\nGiven a position vector \nr\n in lattice coordinates, return the interpolated field cvector/rscalar from \nf\n at that point. \ncvector-field-get-point-bloch\n returns the field \nwithout\n the exp(ikx) Bloch wavevector, in analogue to \nget-bloch-field-point\n.\n\n\nYou may be wondering how to get rid of the field variables once you are done with them: you don't, since they are \ngarbage collected\n automatically.\n\n\nWe also provide functions, in analogue to e.g \nget-efield\n and \noutput-efield\n above, to \"get\" various useful functions as the \ncurrent field\n and to output them to a file:\n\n\n(get-poynting which-band)\n\n\n\nLoads the Poynting vector \n\\mathbf{E}^* \\times \\mathbf{H}\n for the band \nwhich-band\n, the flux density of electromagnetic energy flow, as the current field. 1/2 of the real part of this vector is the time-average flux density which can be combined with the imaginary part to determine the amplitude and phase of the time-dependent flux.\n\n\n(output-poynting which-band)\n\n\n(output-poynting-x which-band)\n\n\n(output-poynting-y which-band)\n\n\n(output-poynting-z which-band)\n\n\n\nOutput the Poynting vector field for \nwhich-band\n; either all or one of the Cartesian components, respectively.\n\n\n(get-tot-pwr which-band)\n\n\n\nLoad the time-averaged electromagnetic-field energy density (\n|\\mathbf{H}|^2 + \\varepsilon |\\mathbf{E}|^2\n) for \nwhich-band\n. If you multiply the real part of the Poynting vector by a factor of 1/2, above, you should multiply by a factor of 1/4 here for consistency.\n\n\n(output-tot-pwr which-band)\n\n\n\nOutput the time-averaged electromagnetic-field energy density (above) for \nwhich-band\n.\n\n\n(output-charge-density which-band)\n\n\n\nOutput the bound charge density (above) for \nwhich-band\n.\n\n\nAs an example, below is the Scheme source code for the \nget-poynting\n function, illustrating the use of the various field functions:\n\n\n(define\u00a0(get-poynting\u00a0which-band)\n\u00a0\u00a0(get-efield\u00a0which-band)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0put\u00a0E\u00a0in\u00a0cur-field\n\u00a0\u00a0(let\u00a0((e\u00a0(field-copy\u00a0cur-field)))\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0...\u00a0and\u00a0copy\u00a0to\u00a0local\u00a0var.\n\u00a0\u00a0\u00a0\u00a0(get-hfield\u00a0which-band)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0put\u00a0H\u00a0in\u00a0cur-field\n\u00a0\u00a0\u00a0\u00a0(field-map!\u00a0cur-field\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0write\u00a0ExH\u00a0to\u00a0cur-field\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(lambda\u00a0(e\u00a0h)\u00a0(vector3-cross\u00a0(vector3-conj\u00a0e)\u00a0h))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0e\u00a0cur-field)\n\u00a0\u00a0\u00a0\u00a0(cvector-field-nonbloch!\u00a0cur-field)))\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0see\u00a0below\n\n\n\n\nStored Fields and Bloch Phases\n\n\nComplex vector fields like \nE\n and \nH\n as computed by MPB are physically of the Bloch form: exp(ikx) times a periodic function. What MPB actually stores, however, is just the periodic function, the Bloch envelope, and only multiplies by exp(ikx) when the fields are output or passed to the user (e.g. in integration functions). This is mostly transparent, with a few exceptions noted above for functions that do not include the exp(ikx) Bloch phase. It is somewhat faster to operate without including the phase.\n\n\nOn some occasions, however, when you create a field with \nfield-map!\n, the resulting field should \nnot\n have any Bloch phase. For example, for the Poynting vector \nE\n*\nx\nH\n, the exp(ikx) cancels because of the complex conjugation. After creating this sort of field, we must use the special function \ncvector-field-nonbloch!\n to tell MPB that the field is purely periodic:\n\n\n(cvector-field-nonbloch! f)\n\n\n\nSpecify that the field \nf\n is \nnot\n of the Bloch form, but rather that it is purely periodic.\n\n\nCurrently, all fields must be either Bloch or non-Bloch (i.e. periodic), which covers most physically meaningful possibilities.\n\n\nThere is another wrinkle: even for fields in Bloch form, the exp(ikx) phase currently always uses the \ncurrent\n k-point, even if the field was computed from another k-point. So, if you are performing computations combining fields from different k-points, you should take care to always use the periodic envelope of the field, putting the Bloch phase in manually if necessary.\n\n\nManipulating the Raw Eigenvectors\n\n\nMPB also includes a few low-level routines to manipulate the raw eigenvectors that it computes in a transverse planewave basis.\n\n\nThe most basic operations involve copying, saving, and restoring the current set of eigenvectors or some subset thereof:\n\n\n(get-eigenvectors first-band num-bands)\n\n\n\nReturn an eigenvector object that is a copy of \nnum-bands\n current eigenvectors starting at \nfirst-band\n. e.g. to get a copy of all of the eigenvectors, use \n(get-eigenvectors 1 num-bands)\n.\n\n\n(set-eigenvectors ev first-band)\n\n\n\nSet the current eigenvectors, starting at \nfirst-band\n, to those in the \nev\n eigenvector object (as returned by \nget-eigenvectors\n). Does not work if the grid sizes don't match.\n\n\n(load-eigenvectors filename)\n\n\n(save-eigenvectors filename)\n\n\n\nRead/write the current eigenvectors (raw planewave amplitudes) to/from an HDF5 file named \nfilename\n. Instead of using \nload-eigenvectors\n directly, you can pass the \nfilename\n as the \nreset-fields\n parameter of \nrun-parity\n, as \nshown above\n. Loaded eigenvectors must be of the same size (same grid size and #bands) as the current settings.\n\n\nCurrently, there's only one other interesting thing you can do with the raw eigenvectors, and that is to compute the dot-product matrix between a set of saved eigenvectors and the current eigenvectors. This can be used, e.g., to detect band crossings or to set phases consistently at different k points. The dot product is returned as a \"sqmatrix\" object, whose elements can be read with the \nsqmatrix-size\n and \nsqmatrix-ref\n routines.\n\n\n(dot-eigenvectors ev first-band)\n\n\n\nReturns a sqmatrix object containing the dot product of the saved eigenvectors \nev\n with the current eigenvectors, starting at \nfirst-band\n. That is, the (\ni,j\n)th output matrix element contains the dot product of the (\ni+1\n)th vector of \nev\n conjugated with the (\nfirst-band+j\n)th eigenvector. Note that the eigenvectors, when computed, are orthonormal, so the dot product of the eigenvectors with themselves is the identity matrix.\n\n\n(sqmatrix-size sm)\n\n\n\nReturn the size \nn\n of an \nn\nx\nn\n sqmatrix \nsm\n.\n\n\n(sqmatrix-ref sm i j)\n\n\n\nReturn the (\ni\n,\nj\n)th element of the \nn\nx\nn\n sqmatrix \nsm\n, where {\ni\n,\nj\n} range from 0..\nn\n-1.\n\n\nInversion Symmetry\n\n\nIf you \nconfigure\n MPB with the \n--with-inv-symmetry\n flag, then the program is configured to assume inversion symmetry in the dielectric function. This allows it to run at least twice as fast and use half as much memory as the more general case. This version of MPB is by default installed as \nmpbi\n, so that it can coexist with the usual \nmpb\n program.\n\n\nInversion symmetry means that if you transform (x,y,z) to (-x,-y,-z) in the coordinate system, the dielectric structure is not affected. Or, more technically, that (see \nour online textbook\n, ch. 3):\n\n\n\n\n\\varepsilon(\\mathbf{x}) = \\varepsilon(-\\mathbf{x})^*\n\n\n\n\nwhere the conjugation is significant for complex-hermitian dielectric tensors. This symmetry is very common; all of the examples in this manual have inversion symmetry, for example.\n\n\nNote that inversion symmetry is defined with respect to a specific origin, so that you may \"break\" the symmetry if you define a given structure in the wrong way\u2014this will prevent \nmpbi\n from working properly. For example, the \ndiamond structure\n that we considered earlier would not have possessed inversion symmetry had we positioned one of the \"atoms\" to lie at the origin.\n\n\nYou might wonder what happens if you pass a structure lacking inversion symmetry to \nmpbi\n. As it turns out, \nmpbi\n only looks at half of the structure, and infers the other half by the inversion symmetry, so the resulting structure \nalways\n has inversion symmetry, even if its original description did not. So, you should be careful, and look at the \nepsilon.h5\n output to make sure it is what you expected.\n\n\nParallel MPB\n\n\nWe provide two methods by which you can parallelize MPB. The first, using MPI, is the most sophisticated and potentially provides the greatest and most general benefits. The second, which involves a simple script to split e.g. the \nk-points\n list among several processes, is less general but may be useful in many cases.\n\n\nMPB with MPI Parallelization\n\n\nIf you \nconfigure\n MPB with the \n--with-mpi\n flag, then the program is compiled to take advantage of distributed-memory parallel machines with \nMPI\n, and is installed as \nmpb-mpi\n. See also the \ninstallation guide\n. This means that computations will potentially run more quickly and take up less memory per processor than for the serial code. Normally, you should also install the serial version of MPB, if only to get the \nmpb-data\n program, which is not installed with \nmpb-mpi\n.\n\n\nUsing the parallel MPB is almost identical to using the serial version(s), with a couple of minor exceptions. The same ctl files should work for both. Running a program that uses MPI requires slightly different invocations on different systems, but will typically be something like:\n\n\nunix% mpirun -np 4 mpb-mpi foo.ctl\n\n\n\n\nto run on e.g. 4 processors. A second difference is that 1D systems are currently not supported in the MPI code, but the serial code should be fast enough for those anyway. A third difference is that the output HDF5 files (epsilon, fields, etcetera) from \nmpb-mpi\n have their first two dimensions (x and y) \ntransposed\n; i.e. they are output as YxXxZ arrays. This doesn't prevent you from visualizing them, but the coordinate system is left-handed; to un-transpose the data, you can process it with \nmpb-data\n and the \n-T\n option in addition to any other options.\n\n\nIn order to get optimal benefit (time and memory savings) from \nmpb-mpi\n, the first two dimensions (n\nx\n and n\ny\n) of your grid should \nboth\n be divisible by the number of processes. If you violate this constraint, MPB will still work, but the load balance between processors will be uneven. At worst, e.g. if either n\nx\n or n\ny\n is smaller than the number of processes, then some of the processors will be idle for part or all of the computation. When using \ninversion symmetry\n (\nmpbi-mpi\n) for 2D grids only, the optimal case is somewhat more complicated: n\nx\n and (n\ny\n/2 + 1), not n\ny\n, should both be divisible by the number of processes.\n\n\nmpb-mpi\n divides each band at each k-point between the available processors. This means that, even if you have only a single k-point (e.g. in a defect calculation) and/or a single band, it can benefit from parallelization. Moreover, memory usage per processor is inversely proportional to the number of processors used. For sufficiently large problems, the speedup is also nearly linear.\n\n\nAlternative Parallelization: mpb-split\n\n\nThere is an alternative method of parallelization when you have multiple k points: do each k-point on a different processor. This does not provide any memory benefits, and does not allow one k-point to benefit by starting with the fields of the previous k-point, but is easy and may be the only effective way to parallelize calculations for small problems. This method also does not require MPI: it can utilize the unmodified serial \nmpb\n program. To make it even easier, we supply a simple script called \nmpb-split\n (or \nmpbi-split\n) to break the \nk-points\n list into chunks for you. Running:\n\n\nunix% mpb-split num-split foo.ctl\n\n\n\n\nwill break the \nk-points\n list in \nfoo.ctl\n into \nnum-split\n more-or-less equal chunks, launch \nnum-split\n processes of \nmpb\n in parallel to process each chunk, and output the results of each in order. Each process is an ordinary \nmpb\n execution, except that it numbers its \nk-points\n depending upon which chunk it is in, so that output files will not overwrite one another and you can still \ngrep\n for frequencies as usual.\n\n\nOf course, this will only benefit you on a system where different processes will run on different processors, such as an SMP or a cluster with automatic process migration (e.g. \nMOSIX\n). \nmpb-split\n is actually a trivial shell script, though, so you can easily modify it if you need to use a special command to launch processes on other processors/machines (e.g. via \nGNU Parallel\n).\n\n\nThe general syntax for \nmpb-split\n is:\n\n\nunix% mpb-split num-split mpb-arguments...\n\n\n\n\nwhere all of the arguments following \nnum-split\n are passed along to \nmpb\n. What \nmpb-split\n technically does is to set the MPB variable \nk-split-num\n to \nnum-split\n and \nk-split-index\n to the index (starting with 0) of the chunk for each process.", 
            "title": "Scheme User Interface"
        }, 
        {
            "location": "/Scheme_User_Interface/#input-variables", 
            "text": "These are global variables that you can set to control various parameters of the MPB computation. They are also listed, along with their current values, by the  (help)  command. In brackets after each variable is the type of value that it should hold. The classes, complex datatypes like  geometric-object , are described in a later subsection. The basic datatypes, like  integer ,  boolean ,  cnumber , and  vector3 , are defined by libctl.  geometry  [ list of  geometric-object  class ]  \nSpecifies the geometric objects making up the structure being simulated. When objects overlap, later objects in the list take precedence. Defaults to no objects (empty list).  default-material  [  material-type  class ]  \nHolds the default material that is used for points not in any object of the geometry list. Defaults to air (epsilon of 1). See also  epsilon-input-file , below.  ensure-periodicity  [ boolean ]  \nIf true (the default), then geometric objects are treated as if they were shifted by all possible lattice vectors; i.e. they are made periodic in the lattice.  geometry-lattice  [ lattice  class ]  \nSpecifies the basis vectors and lattice size of the computational cell which is centered on the origin of the coordinate system. These vectors form the basis for all other 3-vectors in the geometry, and the lattice size determines the size of the primitive cell. If any dimension of the lattice size is the special value  no-size , then the dimension of the lattice is reduced (i.e. it becomes two- or one-dimensional). That is, the dielectric function becomes two-dimensional; it is still, in principle, a three dimensional system, and the k-point vectors can be three-dimensional. Generally, you should make any  no-size  dimension(s) perpendicular to the others. Defaults to the orthogonal x-y-z vectors of unit length (i.e. a square/cubic lattice).  resolution  [ number  or  vector3 ]  \nSpecifies the computational grid resolution, in pixels per lattice unit (a lattice unit is one basis vector in a given direction). If  resolution  is a  vector3 , then specifies a different resolution for each direction; otherwise the resolution is uniform. The grid size is then the product of the lattice size and the resolution, rounded up to the next positive integer. Defaults to  10 . You can call  (optimize-grid-size!)   after  setting the  resolution  and  geometry-lattice  to adjust the grid size for maximal performance. This rounds the grid size in each direction to the nearest integer with small factors, to improve FFT speed.  grid-size  [ vector3 ]  \nSpecifies the size of the discrete computational grid along each of the lattice directions.  Deprecated:  the preferred method is to use the  resolution  variable, above, in which case the  grid-size  defaults to  false . To get the grid size you should instead use the  (get-grid-size)  function.  dimensions  [ integer ]  \nExplicitly specifies the dimensionality of the simulation; if the value is less than 3, the sizes of the extra dimensions in  grid-size  are ignored (assumed to be one). Defaults to 3.  Deprecated:  the preferred method is to set  geometry-lattice  to have size no-size in any unwanted dimensions.  k-points  [ list of  vector3 ]  \nList of Bloch wavevectors to compute the bands at, expressed in the basis of the reciprocal lattice vectors. The reciprocal lattice vectors are defined as follows (see  our online textbook , appendix B): Given the lattice vectors R i  ( not  the basis vectors), the reciprocal lattice vector G j  satisfies R i  * G j  = 2 i,j , where  i,j  is the Kronecker delta (1 for  i=j  and 0 otherwise). R i  for any  no-size  dimensions is taken to be the corresponding basis vector. Normally, the wavevectors should be in the first Brillouin zone ( see below ).  k-points  defaults to none (empty list).  num-bands  [ integer ]    \nNumber of bands (eigenvectors) to compute at each k point. Defaults to 1.  target-freq  [ number ]  \nIf zero, the lowest-frequency  num-bands  states are solved for at each k point (ordinary eigenproblem). If non-zero, solve for the  num-bands  states whose frequencies have the smallest absolute difference with  target-freq  (special, \"targeted\" eigenproblem). Beware that the targeted solver converges more slowly than the ordinary eigensolver and may require a lower  tolerance  to get reliable results. Defaults to 0.  tolerance  [ number ]  \nSpecifies when convergence of the eigensolver is judged to have been reached when the eigenvalues have a fractional change less than  tolerance  between iterations. Defaults to 1.0e-7.  filename-prefix  [ string ]  \nA string prepended to all output filenames. Defaults to  \"FILE-\" , where your control file is FILE.ctl. You can change this to  false  to use no prefix.  epsilon-input-file  [ string ]  \nIf this string is not  \"\"  (the default), then it should be the name of an HDF5 file whose first/only dataset defines a dielectric function over some discrete grid. This dielectric function is then used in place of  default-material  ( i.e.  where there are no  geometry  objects). The grid of the epsilon file dataset need not match  grid-size ; it is scaled and/or linearly interpolated as needed. The lattice vectors for the epsilon file are assumed to be the same as  geometry-lattice . Note that, even if the grid sizes match and there are no geometric objects, the dielectric function used by MPB will not be exactly the dielectric function of the epsilon file, unless you also set  mesh-size  to 1 (see above).  eigensolver-block-size  [ integer ]  \nThe eigensolver uses a \"block\" algorithm, which means that it solves for several bands simultaneously at each k-point.  eigensolver-block-size  specifies this number of bands to solve for at a time; if it is zero or  =  num-bands , then all the bands are solved for at once. If  eigensolver-block-size  is a negative number, - n , then MPB will try to use nearly-equal block-sizes close to  n . Making the block size a small number can reduce the memory requirements of MPB, but block sizes   1 are usually more efficient. There is typically some optimum size for any given problem. Defaults to -11 (i.e. solve for around 11 bands at a time).  simple-preconditioner?  [ boolean ]  \nWhether or not to use a simplified preconditioner. Defaults to  false  which is fastest most of the time. Turning this on increases the number of iterations, but decreases the time for each iteration.  deterministic?  [ boolean ]  \nSince the fields are initialized to random values at the start of each run, there are normally slight differences in the number of iterations, etcetera, between runs. Setting  deterministic?  to  true  makes things deterministic. The default is  false .  eigensolver-flags  [ integer ]  \nThis variable is undocumented and reserved for use by Jedi Masters only.", 
            "title": "Input Variables"
        }, 
        {
            "location": "/Scheme_User_Interface/#predefined-variables", 
            "text": "Variables predefined for your convenience and amusement.  air ,  vacuum  [ material-type  class ]  \nTwo aliases for a predefined material type with a dielectric constant of 1.  nothing  [ material-type  class ]  \nA material that, effectively, punches a hole through other objects to the background ( default-material  or  epsilon-input-file ).  infinity  [ number ]  \nA big number (1e20) to use for \"infinite\" dimensions of objects.", 
            "title": "Predefined Variables"
        }, 
        {
            "location": "/Scheme_User_Interface/#output-variables", 
            "text": "Global variables whose values are set upon completion of the eigensolver.  freqs  [ list of  number ]  \nA list of the frequencies of each band computed for the last k point. Guaranteed to be sorted in increasing order. The frequency of band  b  can be retrieved via  (list-ref freqs (- b 1)) .  iterations  [ integer ]  \nThe number of iterations required for convergence of the last k point.  parity  [ string ]  \nA string describing the current required parity/polarization ( te ,  zeven , etcetera, or \"\" for none). Useful for prefixing output lines for grepping.  Yet more global variables are set by the  run  function and its variants, for use after  run  completes or by a band function which is called for each band during the execution of  run .  current-k  [ vector3 ]  \nThe k point most recently solved from the  k-points  list.  gap-list  [ list of ( percent freq-min freq-max ) lists ]  \nThis is a list of the gaps found by the eigensolver, and is set by the  run  functions when two or more k-points are solved. It is the empty list if no gaps are found.  band-range-data  [ list of (( min .  kpoint ) . ( max . kpoint )) ]  \nFor each band, this list contains the minimum and maximum frequencies of the band, and the associated k points where the extrema are achieved. Note that the bands are defined by sorting the frequencies in increasing order, so this can be confused if two bands cross.", 
            "title": "Output Variables"
        }, 
        {
            "location": "/Scheme_User_Interface/#classes", 
            "text": "Classes are complex datatypes with various \"properties\" which may have default values. Classes can be \"subclasses\" of other classes; subclasses inherit all the properties of their superclass, and can be used any place the superclass is expected. An object of a class is constructed with:  (make class (prop1 val1) (prop2 val2) ...)  See also the  libctl manual .  MPB defines several types of classes, the most numerous of which are the various geometric object classes. You can also get a list of the available classes, along with their property types and default values, at runtime with the  (help)  command.", 
            "title": "Classes"
        }, 
        {
            "location": "/Scheme_User_Interface/#lattice", 
            "text": "The lattice class is normally used only for the  geometry-lattice  variable and specifies the three lattice directions of the crystal and the lengths of the corresponding lattice vectors.  basis1, basis2, basis3  [ vector3 ]  \nThe three lattice directions of the crystal, specified in the cartesian basis. The lengths of these vectors are ignored--only their directions matter. The lengths are determined by the  basis-size  property, below. These vectors are then used as a basis for all other 3-vectors in the ctl file. They default to the x, y, and z directions, respectively.  basis-size  [ vector3 ]  \nThe components of  basis-size  are the lengths of the three basis vectors, respectively. They default to unit lengths.  size  [ vector3 ]  \nThe size of the lattice (i.e. the length of the lattice vectors R i , in which the crystal is periodic) in units of the basis vectors. Thus, the actual lengths of the lattice vectors are given by the components of  size  multiplied by the components of  basis-size . Alternatively, you can think of  size  as the vector between opposite corners of the primitive cell, specified in the lattice basis. Defaults to unit lengths.  If any dimension has the special size  no-size , then the dimensionality of the problem is reduced by one. Strictly speaking, the dielectric function is taken to be uniform along that dimension. In this case, the  no-size  dimension should generally be orthogonal to the other dimensions.", 
            "title": "lattice"
        }, 
        {
            "location": "/Scheme_User_Interface/#material-type", 
            "text": "This class is used to specify the materials that geometric objects are made of. Currently, there are three subclasses,  dielectric ,  dielectric-anisotropic , and  material-function .  dielectric  \nA uniform, isotropic, linear dielectric material, with one property:  epsilon  [ number ]  \nThe dielectric constant (must be positive). No default value. You can also use  (index n)  as a synonym for  (epsilon (* n n)) .  dielectric-anisotropic  \nA uniform, possibly anisotropic, linear dielectric material. For this material type, you specify the dielectric tensor  \\varepsilon , which is real-symmetric or possibly complex-hermitian, relative to the cartesian xyz axes:  \\begin{pmatrix} a   u   v \\\\ u^*   b   w \\\\ v^*   w^*   c \\end{pmatrix}  This allows your dielectric to have different dielectric constants for fields polarized in different directions. The epsilon tensor must be positive-definite (have all positive eigenvalues); if it is not, MPB exits with an error. This does  not  imply that all of the entries of the epsilon matrix need be positive. The components of the tensor are specified via three properties:  epsilon-diag  [ vector3 ]  \nThe diagonal elements (a b c) of the dielectric tensor. No default value.  epsilon-offdiag  [ cvector3 ]  \nThe off-diagonal elements (u v w) of the dielectric tensor. Defaults to zero. This is a  cvector3 , which simply means that the components may be complex numbers (e.g.  3+0.1i ). If non-zero imaginary parts are specified, then the dielectric tensor is complex-hermitian. This is only supported when MPB is configured with the  --with-hermitian-eps  flag. This is not dissipative (the eigenvalues of epsilon are real), but rather breaks time-reversal symmetry, corresponding to a gyrotropic (magneto-optic) material (see  our online textbook , ch. 2). Note that  inversion symmetry  may not mean what you expect for complex-hermitian epsilon, so be cautious about using  mpbi  in this case.  epsilon-offdiag-imag  [ vector3 ]   Deprecated:  The imaginary parts of the off-diagonal elements (u v w) of the dielectric tensor; defaults to zero. Setting the imaginary parts directly by specifying complex numbers in  epsilon-offdiag  is preferred.  For example, a material with a dielectric constant of 3.0 for P-polarization and 5.0 for S-polarization would be specified via  (make (dielectric-anisotropic (epsilon-diag 3 3 5))) . Please  be aware  that not all 2d anisotropic dielectric structures will have P- and S-polarized modes, however.  material-function  \nThis material type allows you to specify the material as an arbitrary function of position. For an example of this, see the  bragg-sine.ctl  file in the  examples/  directory. It has one property:  material-func  [ function ]  \nA function of one argument, the position  vector3  in lattice coordinates, that returns the material at that point. Note that the function you supply can return  any  material; wild and crazy users could even return another  material-function  object which would then have its function invoked in turn.  Instead of  material-func , you can use  epsilon-func : for  epsilon-func , you give it a function of position that returns the dielectric constant at that point.  Normally, the dielectric constant is required to be positive or positive-definite, for a tensor. However, MPB does have a somewhat experimental feature allowing negative dielectrics (e.g. in a plasma). To use it, call the function  (allow-negative-epsilon)  before  (run) . In this case, it will output the (real) frequency  squared  in place of the (possibly imaginary) frequencies. Convergence will be somewhat slower because the eigenoperator is not positive definite.", 
            "title": "material-type"
        }, 
        {
            "location": "/Scheme_User_Interface/#geometric-object", 
            "text": "This class, and its descendants, are used to specify the solid geometric objects that form the dielectric structure being simulated. The properties are:  material  [ material-type  class ]  \nThe material that the object is made of which is usually some sort of dielectric. No default value. Must be specified.  center  [ vector3 ]  \nCenter point of the object. No default value.  One normally does not create objects of type  geometric-object  directly, however; instead, you use one of the following subclasses. Recall that subclasses inherit the properties of their superclass, so these subclasses automatically have the  material  and  center  properties which must be specified, since they have no default values.  Recall that all 3-vectors, including the center of an object, its axes, and so on, are specified in the basis of the normalized lattice vectors normalized to  basis-size . Note also that 3-vector properties can be specified by either  (property (vector3 x y z))  or, equivalently,  (property x y z) .  In a two-dimensional calculation, only the intersections of the objects with the x-y plane are considered.  sphere  \nA sphere. Properties:  radius  [ number ]  \nRadius of the sphere. No default value.  cylinder  \nA cylinder, with circular cross-section and finite height. Properties:  radius  [ number ]  \nRadius of the cylinder's cross-section. No default value.  height  [ number ]  \nLength of the cylinder along its axis. No default value.  axis  [ vector3 ]  \nDirection of the cylinder's axis; the length of this vector is ignored. Defaults to point parallel to the z axis.  cone  \nA cone, or possibly a truncated cone. This is actually a subclass of  cylinder , and inherits all of the same properties, with one additional property. The radius of the base of the cone is given by the  radius  property inherited from  cylinder , while the radius of the tip is given by the new property,  radius2 . The  center  of a cone is halfway between the two circular ends.  radius2  [ number ]  \nRadius of the tip of the cone (i.e. the end of the cone pointed to by the  axis  vector). Defaults to zero (a \"sharp\" cone).  block  \nA parallelepiped (i.e., a brick, possibly with non-orthogonal axes). Properties:  size  [ vector3 ]  \nThe lengths of the block edges along each of its three axes. Not really a 3-vector (at least, not in the lattice basis), but it has three components, each of which should be nonzero. No default value.  e1 ,  e2 ,  e3  [ vector3 ]  \nThe directions of the axes of the block; the lengths of these vectors are ignored. Must be linearly independent. They default to the three lattice directions.  ellipsoid  \nAn ellipsoid. This is actually a subclass of  block , and inherits all the same properties, but defines an ellipsoid inscribed inside the block.  Here are some examples of geometric objects created using the above classes, assuming that the lattice directions (the basis) are just the ordinary unit axes, and  m  is some material we have defined:  ;\u00a0A\u00a0cylinder\u00a0of\u00a0infinite\u00a0radius\u00a0and\u00a0height\u00a00.25\u00a0pointing\u00a0along\u00a0the\u00a0x\u00a0axis,\n;\u00a0centered\u00a0at\u00a0the\u00a0origin:\n(make\u00a0cylinder\u00a0(center\u00a00\u00a00\u00a00)\u00a0(material\u00a0m)\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(radius\u00a0infinity)\u00a0(height\u00a00.25)\u00a0(axis\u00a01\u00a00\u00a00))  ;\u00a0An\u00a0ellipsoid\u00a0with\u00a0its\u00a0long\u00a0axis\u00a0pointing\u00a0along\u00a0(1,1,1),\u00a0centered\u00a0on\n;\u00a0the\u00a0origin\u00a0(the\u00a0other\u00a0two\u00a0axes\u00a0are\u00a0orthogonal\u00a0and\u00a0have\u00a0equal\n;\u00a0semi-axis\u00a0lengths):\n(make\u00a0ellipsoid\u00a0(center\u00a00\u00a00\u00a00)\u00a0(material\u00a0m)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(size\u00a00.8\u00a00.2\u00a00.2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(e1\u00a01\u00a01\u00a01)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(e2\u00a00\u00a01\u00a0-1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(e3\u00a0-2\u00a01\u00a01))  ;\u00a0A\u00a0unit\u00a0cube\u00a0of\u00a0material\u00a0m\u00a0with\u00a0a\u00a0spherical\u00a0air\u00a0hole\u00a0of\u00a0radius\u00a00.2\u00a0at\n;\u00a0its\u00a0center,\u00a0the\u00a0whole\u00a0thing\u00a0centered\u00a0at\u00a0(1,2,3):\n(set!\u00a0geometry\u00a0(list\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(make\u00a0block\u00a0(center\u00a01\u00a02\u00a03)\u00a0(material\u00a0m)\u00a0(size\u00a01\u00a01\u00a01))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(make\u00a0sphere\u00a0(center\u00a01\u00a02\u00a03)\u00a0(material\u00a0air)\u00a0(radius\u00a00.2))))", 
            "title": "geometric-object"
        }, 
        {
            "location": "/Scheme_User_Interface/#functions", 
            "text": "Here, we describe the functions that are defined by MPB. There are many types of functions defined ranging from utility functions for duplicating geometric objects to run functions that start the computation.  See also the  reference section  of the libctl manual, which describes a number of useful functions defined by libctl.", 
            "title": "Functions"
        }, 
        {
            "location": "/Scheme_User_Interface/#geometry-utilities", 
            "text": "Some utility functions are provided to help you manipulate geometric objects:  (shift-geometric-object obj shift-vector)  \nTranslate  obj  by the 3-vector  shift-vector .  (geometric-object-duplicates shift-vector min-multiple max-multiple obj)  \nReturn a list of duplicates of  obj , shifted by various multiples of  shift-vector  from  min-multiple  to  max-multiple , inclusive, in steps of 1.  (geometric-objects-duplicates shift-vector min-multiple max-multiple obj-list)  \nSame as  geometric-object-duplicates , except operates on a list of objects,  obj-list . If  A  appears before  B  in the input list, then all the duplicates of  A  appear before all the duplicates of  B  in the output list.  (geometric-objects-lattice-duplicates obj-list [ ux uy uz ])  \nDuplicates the objects in  obj-list  by multiples of the lattice basis vectors, making all possible shifts of the \"primitive cell\" (see below) that fit inside the lattice cell. This is useful for supercell calculations. See the  tutorial . The primitive cell to duplicate is  ux  by  uy  by  uz , in units of the basis vectors. These three parameters are optional; any that you do not specify are assumed to be  1 .  (point-in-object? point obj)  \nReturns whether or not the given 3-vector  point  is inside the geometric object  obj .  (point-in-periodic-object? point obj)  \nAs  point-in-object? , but also checks translations of the given object by the lattice vectors.  (display-geometric-object-info indent-by obj)  \nOutputs some information about the given  obj , indented by  indent-by  spaces.", 
            "title": "Geometry Utilities"
        }, 
        {
            "location": "/Scheme_User_Interface/#coordinate-conversion-functions", 
            "text": "The following functions allow you to easily convert back and forth between the lattice, cartesian, and reciprocal bases. See also the  note on units  in the tutorial.  (lattice- cartesian x) ,  (cartesian- lattice x)  \nConvert  x  between the lattice basis (the basis of the lattice vectors normalized to  basis-size ) and the ordinary cartesian basis, where  x  is either a  vector3  or a  matrix3x3 , returning the transformed vector/matrix. In the case of a matrix argument, the matrix is treated as an operator on vectors in the given basis, and is transformed into the same operator on vectors in the new basis.  (reciprocal- cartesian x) ,  (cartesian- reciprocal x)  \nLike the above, except that they convert to/from reciprocal space (the basis of the reciprocal lattice vectors). Also, the cartesian vectors output/input are in units of 2 .  (reciprocal- lattice x) ,  (lattice- reciprocal x)  \nConvert between the reciprocal and lattice bases, where the conversion again leaves out the factor of 2  (i.e. the lattice-basis vectors are assumed to be in units of 2 ).  Also, a couple of rotation functions are defined, for convenience, so that you don't have to explicitly convert to cartesian coordinates in order to use libctl's  rotate-vector3  function. See the  Libctl User Reference :  (rotate-lattice-vector3 axis theta v) ,  (rotate-reciprocal-vector3 axis theta v)  \nLike  rotate-vector3  , except that  axis  and  v  are specified in the lattice/reciprocal bases.  Usually, k-points are specified in the first Brillouin zone, but sometimes it is convenient to specify an arbitrary k-point. However, the accuracy of MPB degrades as you move farther from the first Brillouin zone due to the choice of a fixed planewave set for a basis. This is easily fixed: simply transform the k-point to a corresponding point in the first Brillouin zone, and a completely equivalent solution (identical frequency, fields, etcetera) is obtained with maximum accuracy. The following function accomplishes this:  (first-brillouin-zone k)  \nGiven a k-point  k  in the basis of the reciprocal lattice vectors, as usual, return an equivalent point in the first Brillouin zone of the current lattice ( geometry-lattice ).  Note that  first-brillouin-zone  can be applied to the entire  k-points  list with the Scheme expression:  (map first-brillouin-zone k-points) .", 
            "title": "Coordinate Conversion Functions"
        }, 
        {
            "location": "/Scheme_User_Interface/#run-functions", 
            "text": "These are functions to help you run and control the simulation. The ones you will most commonly use are the  run  function and its variants. The syntax of these functions, and one lower-level function, is:  (run   band-func   ...)  \nThis runs the simulation described by the input parameters (see above), with no constraints on the polarization of the solution. That is, it reads the input parameters, initializes the simulation, and solves for the requested eigenstates of each k-point. The dielectric function is outputted to  epsilon.h5  before any eigenstates are computed.  run  takes as arguments zero or more \"band functions\"  band-func . A band function should be a function of one integer argument, the band index, so that  (band-func   which-band)  performs some operation on the band  which-band  (e.g. outputting fields). After every k-point, each band function is called for the indices of all the bands that were computed. Alternatively, a band function may be a \"thunk\" (function of zero arguments), in which case  (band-func)  is called exactly once per k-point.  (run-zeven   band-func   ...) ,  (run-zodd   band-func   ...)  \nThese are the same as the  run  function except that they constrain their solutions to have even and odd symmetry with respect to the z=0 plane. You should use these functions  only  for structures that are symmetric through the z=0 mirror plane, where the third basis vector is in the z direction (0,0,1) and is orthogonal to the other two basis vectors, and when the k vectors are in the xy plane. Under these conditions, the eigenmodes always have either even or odd symmetry. In two dimensions, even/odd parities are equivalent to P/S polarizations, respectively and are often strongly analogous even in 3d. Such a symmetry classification is useful for structures such as waveguides and photonic-crystal slabs. See the  online book  (ch. 3).  (run-te   band-func   ...) ,  (run-tm   band-func   ...)  \nThese are the same as the  run  function except that they constrain their solutions to be TE- and TM-polarized, respectively, in two dimensions. The TE and TM polarizations are defined has having electric and magnetic fields in the xy plane, respectively. Equivalently, the H/E field of TE/TM light has only a z component (making it easier to visualize).  These functions are actually equivalent to calling  run-zeven  and  run-zodd , respectively. Note that for the modes to be segregated into TE and TM polarizations, the dielectric function must have mirror symmetry for reflections through the xy plane. If you use  anisotropic dielectrics , you should be aware that they break this symmetry if the z direction is not one of the principle axes. If you use  run-te  or  run-tm  in such a case of broken symmetry, MPB will exit with an error.  (run-yeven   band-func   ...) ,  (run-yodd   band-func   ...)  \nThese functions are analogous to  run-zeven  and  run-zodd , except that they constrain their solutions to have even and odd symmetry with respect to the y=0 plane. You should use these functions  only  for structures that are symmetric through the y=0 mirror plane, where the second basis vector is in the y direction (0,1,0) and is orthogonal to the other two basis vectors, and when the k vectors are in the xz plane.  run-yeven-zeven ,  run-yeven-zodd ,  run-yodd-zeven ,  run-yodd-zodd ,  run-te-yeven ,  run-te-yodd ,  run-tm-yeven ,  run-tm-yodd  \nThese  run -like functions combine the  yeven / yodd  constraints with  zeven / zodd  or  te / tm . See also  run-parity , below.  (run-parity   p reset-fields band-func   ...)  \nLike the  run  function, except that it takes two extra parameters, a parity  p  and a boolean ( true / false ) value  reset-fields .  p  specifies a parity constraint, and should be one of the predefined variables:   NO-PARITY : equivalent to  run  EVEN-Z  (or  TE ): equivalent to  run-zeven  or  run-te  ODD-Z  (or  TM ): equivalent to  run-zodd  or  run-tm  EVEN-Y  (like  EVEN-Z  but for y=0 plane)  ODD-Y  (like  ODD-Z  but for y=0 plane)   It is possible to specify more than one symmetry constraint simultaneously by adding them, e.g.  (+   EVEN-Z   ODD-Y)  requires the fields to be even through z=0 and odd through y=0. It is an error to specify incompatible constraints (e.g.  (+   EVEN-Z   ODD-Z) ).  Important:  if you specify the z/y parity, the dielectric structure  and  the k vector  must  be symmetric about the z/y=0 plane, respectively. If  reset-fields  is  false , the fields from any previous calculation will be reused as the starting point from this calculation, if possible; otherwise, the fields are reset to random values. The ordinary  run  functions use a default  reset-fields  of true . Alternatively,  reset-fields  may be a string, the name of an HDF5 file to load the initial fields from as exported by  save-eigenvectors , as shown  below .  (display-eigensolver-stats)  \nDisplay some statistics on the eigensolver convergence; this function is useful mainly for MPB developers in tuning the eigensolver.  Several band functions for outputting the eigenfields are defined for your convenience, and are described in the  section below . You can also define your own band functions, and for this purpose the functions described in the section  Field manipulation functions , below, are useful. A band function takes the form:  (define\u00a0(my-band-func\u00a0which-band)\n...do stuff here with band index which-band...\n)  Note that the output variable  freqs  may be used to retrieve the frequency of the band (see above). Also, a global variable  current-k  is defined holding the current k-point vector from the  k-points  list.  There are also some even lower-level functions that you can call, although you should not need to do most of the time:  (init-params p reset-fields?)  \nRead the input variables and initialize the simulation in preparation for computing the eigenvalues. The parameters are the same as the first two parameters of  run-parity . This function  must  be called before any of the other simulation functions below. Note, however, that the  run  functions all call  init-params .  (set-parity p)  \nAfter calling  init-params , you can change the parity constraint without resetting the other parameters by calling this function. Beware that this does not randomize the fields (see below); you don't want to try to solve for, say, the TM eigenstates when the fields are initialized to TE states from a previous calculation.  (randomize-fields)  \nInitialize the fields to random values.  (solve-kpoint k)  \nSolve for the requested eigenstates at the Bloch wavevector  k .", 
            "title": "Run Functions"
        }, 
        {
            "location": "/Scheme_User_Interface/#the-inverse-problem-k-as-a-function-of-frequency", 
            "text": "MPB's  (run)  function(s) and its underlying algorithms compute the frequency  w  as a function of wavevector  k . Sometimes, however, it is desirable to solve the inverse problem, for  k  at a given frequency  w . This is useful, for example, when studying coupling in a waveguide between different bands at the same frequency since frequency is conserved even when wavevector is not. One also uses  k(w)  to construct wavevector diagrams, which aid in understanding diffraction (e.g. negative-diffraction materials and super-prisms). To solve such problems, therefore, we provide the  find-k  function described below, which inverts  w(k)  via a few iterations of Newton's method using the group velocity  dw/dk . Because it employs a root-finding method, you need to specify bounds on  k  and a  crude  initial guess where order of magnitude is usually good enough.  (find-k p omega band-min band-max kdir tol kmag-guess kmag-min kmag-max [band-func...])  \nFind the wavevectors in the current geometry/structure for the bands from  band-min  to  band-max  at the frequency  omega  along the  kdir  direction in k-space. Returns a list of the wavevector magnitudes for each band; the actual wavevectors are  (vector3-scale magnitude (unit-vector3 kdir)) . The arguments of  find-k  are:   p : parity (same as first argument to  run-parity ,  above ).  omega : the frequency at which to find the bands  band-min ,  band-max : the range of bands to solve for the wavevectors of (inclusive).  kdir : the direction in k-space in which to find the wavevectors. (The magnitude of  kdir  is ignored.)  tol : the fractional tolerance with which to solve for the wavevector;  1e-4  is usually sufficient. (Like the  tolerance  input variable, this is only the tolerance of the numerical iteration...it does not have anything to do with e.g. the error from finite grid  resolution .)  kmag-guess : an initial guess for the k magnitude (along  kdir ) of the wavevector at  omega . Can either be a list (one guess for each band from  band-min  to  band-max ) or a single number (same guess for all bands, which is usually sufficient).  kmag-min ,  kmag-max : a range of k magnitudes to search; should be large enough to include the correct k values for all bands.  band-func : zero or more  band functions , just as in  (run) , which are evaluated at the computed k points for each band.   The  find-k  routine also prints a line suitable for grepping:  kvals: omega, band-min, band-max, kdir1, kdir2, kdir3, k magnitudes...", 
            "title": "The Inverse Problem: k as a Function of Frequency"
        }, 
        {
            "location": "/Scheme_User_Interface/#bandoutput-functions", 
            "text": "All of these are functions that, given a band index, output the corresponding field or compute some function thereof in the primitive cell of the lattice. They are designed to be passed as band functions to the  run  routines, although they can also be called directly. See also the section on  field normalizations .  (output-hfield which-band)  (output-hfield-x which-band)  (output-hfield-y which-band)  (output-hfield-z which-band)  \nOutput the magnetic ( \\mathbf{H} ) field for  which-band ; either all or one of the Cartesian components, respectively.  (output-dfield which-band)  (output-dfield-x which-band)  (output-dfield-y which-band)  (output-dfield-z which-band)  \nOutput the electric displacement ( \\mathbf{D} ) field for  which-band ; either all or one of the Cartesian components, respectively.  (output-efield which-band)  (output-efield-x which-band)  (output-efield-y which-band)  (output-efield-z which-band)  \nOutput the electric ( \\mathbf{E} ) field for  which-band ; either all or one of the Cartesian components, respectively.  (output-hpwr which-band)  \nOutput the time-averaged magnetic-field energy density (hpwr =  |\\mathbf{H}|^2 ) for  which-band .  (output-dpwr which-band)  \nOutput the time-averaged electric-field energy density (dpwr =  \\varepsilon|\\mathbf{E}|^2 ) for  which-band .  (fix-hfield-phase which-band)  (fix-dfield-phase which-band)  (fix-efield-phase which-band)  \nFix the phase of the given eigenstate in a canonical way based on the given spatial field. See also  fix-field-phase , below. Otherwise, the phase is random. These functions also maximize the real part of the given field so that one can hopefully just visualize the real part. To fix the phase for output, pass one of these functions to  run  before the corresponding output function, e.g.  (run-tm fix-dfield-phase output-dfield-z)  Although we try to maximize the \"real-ness\" of the field, this has a couple of limitations. First, the phase of the different field components cannot, of course, be chosen independently, so an individual field component may still be imaginary. Second, if you use  mpbi  to take advantage of  inversion symmetry  in your problem, the phase is mostly determined elsewhere in the program;  fix-Xfield-phase  in that case only determines the sign.  See also below for the  output-poynting  and  output-tot-pwr  functions to output the Poynting vector and the total electromagnetic energy density, respectively, and the  output-charge-density  function to output the bound charge density.  Sometimes, you only want to output certain bands. For example, here is a function that, given an band/output function like the ones above, returns a new output function that only calls the first function for bands with a large fraction of their energy in an object(s). This is useful for picking out defect states in supercell calculations.  (output-dpwr-in-objects   band-func min-energy objects ...)  \nGiven a band function  band-func , returns a new band function that only calls  band-func  for bands having a fraction of their electric-field energy greater than  min-energy  inside the given objects (zero or more geometric objects). Also, for each band, prints the fraction of their energy in the objects in the following form which is suitable for grepping:  dpwr:, band-index, frequency, energy-in-objects  output-dpwr-in-objects  only takes a single band function as a parameter, but if you want it to call several band functions, you can easily combine them into one with the following routine:  (combine-band-functions   band-funcs ...)  \nGiven zero or more band functions, returns a new band function that calls all of them in sequence. When passed zero parameters, returns a band function that does nothing.  It is also often useful to output the fields only at a certain k-point, to let you look at typical field patterns for a given band while avoiding gratuitous numbers of output files. This can be accomplished via:  (output-at-kpoint   k-point band-funcs ...)  \nGiven zero or more band functions, returns a new band function that calls all of them in sequence, but only at the specified  k-point . For other k-points, does nothing.", 
            "title": "Band/Output Functions"
        }, 
        {
            "location": "/Scheme_User_Interface/#miscellaneous-functions", 
            "text": "(retrieve-gap lower-band)  \nReturn the frequency gap from the band  lower-band  to the band  lower-band+1 , as a percentage of mid-gap frequency. The \"gap\" may be negative if the maximum of the lower band is higher than the minimum of the upper band. The gap is computed from the  band-range-data  of the previous run.", 
            "title": "Miscellaneous Functions"
        }, 
        {
            "location": "/Scheme_User_Interface/#parity", 
            "text": "Given a set of eigenstates at a k-point, MPB can compute their  parities  with respect to the z=0 or y=0 plane. The z/y parity of a state is defined as the expectation value under the usual inner product of the mirror-flip operation through z/y=0, respectively. For true even and odd eigenstates (see e.g.  run-zeven  and  run-zodd ), this will be +1 and -1, respectively; for other states it will be something in between.  This is useful e.g. when you have a nearly symmetric structure, such as a waveguide with a substrate underneath, and you want to tell which bands are even-like (parity   0) and odd-like (parity   0). Indeed, any state can be decomposed into purely even and odd functions, with absolute-value-squared amplitudes of (1+parity)/2 and (1-parity)/2, respectively.  display-zparities ,  display-yparities  \nThese are band functions, designed to be passed to  (run) , which output all of the z/y parities, respectively, at each k-point in comma-delimited format suitable for grepping.  (compute-zparities)  \nReturns a list of the parities about the z=0 plane, one number for each band computed at the last k-point.  (compute-yparities)  \nReturns a list of the parities about the y=0 plane, one number for each band computed at the last k-point.  Note that the magnetic field is only a pseudo-vector, and is therefore multiplied by -1 under mirror-flip operations. For this reason, the magnetic field  appears  to have opposite symmetry from the electric field, but is really the same.", 
            "title": "Parity"
        }, 
        {
            "location": "/Scheme_User_Interface/#group-velocities", 
            "text": "Given a set of eigenstates at a given k-point, MPB can compute their group velocities (the derivative  d\\omega/d\\mathbf{k}  of frequency with respect to wavevector) using the Hellman-Feynmann theorem. Three functions are provided for this purpose, and we document them here from highest-level to lowest-level.  display-group-velocities  \nThis is a band function, designed to be passed to  (run) , which outputs all of the group velocity vectors (in the Cartesian basis, in units of  c ) at each k-point.  (compute-group-velocities)  \nReturns a list of group-velocity vectors (in the Cartesian basis, units of  c ) for the bands at the last-computed k-point.  (compute-group-velocity-component direction)  \nReturns a list of the group-velocity components (units of  c ) in the given  direction , one for each band at the last-computed k-point.  direction  is a vector in the reciprocal-lattice basis like the k-points and its length is ignored. This has the advantage of being three times faster than  compute-group-velocities .  (compute-1-group-velocity which-band) ,  (compute-1-group-velocity-component direction which-band)  \nAs above, but returns the group velocity or component thereof only for band  which-band .", 
            "title": "Group Velocities"
        }, 
        {
            "location": "/Scheme_User_Interface/#field-manipulation", 
            "text": "MPB provides a number of ways to take the field of a band and manipulate, process, or output it. These methods usually work in two stages. First, one loads a field into memory, computing it in position space, by calling one of the  get  functions below. Then, other functions can be called to transform or manipulate the field.  The simplest class of operations involve only the currently-loaded field, which we describe in the  second subsection  below. To perform more sophisticated operations, involving more than one field, one must copy or transform the current field into a new field variable, and then call one of the functions that operate on multiple field variables described in the  third subsection .", 
            "title": "Field Manipulation"
        }, 
        {
            "location": "/Scheme_User_Interface/#field-normalization", 
            "text": "In order to perform useful operations on the fields, it is important to understand how they are normalized. We normalize the fields in the way that is most convenient for perturbation and coupled-mode theory (see  S.G. Johnson et al., (2002)  and also  our online textbook , ch. 2), so that their energy densities have unit integral. In particular, we normalize the electric ( \\mathbf{E} ), displacement ( \\mathbf{D} = \\varepsilon \\mathbf{E} ) and magnetic ( \\mathbf{H} = -\\frac{i}{\\omega} \\nabla \\times \\mathbf{E} ) fields, so that:     -   (\\int \\varepsilon  \\mathbf{E}  ^2  d^3\\mathbf{x} = 1)      where the integrals are over the computational cell. Note the volume element  d^3\\mathbf{x}  which is the volume of a grid pixel/voxel. If you simply sum  |\\mathbf{H}|^2  over all the grid points, therefore, you will get (# grid points) / (volume of cell).  Note that we have dropped the pesky factors of 1/2, \u03c0, etcetera from the energy densities, since these do not appear in e.g. perturbation theory, and the fields have arbitrary units anyway. The functions to compute/output energy densities below similarly use  \\varepsilon |\\mathbf{E}|^2  and  |\\mathbf{H}|^2  without any prefactors.", 
            "title": "Field Normalization"
        }, 
        {
            "location": "/Scheme_User_Interface/#loading-and-manipulating-the-current-field", 
            "text": "In order to load a field into memory, call one of the  get  functions follow. They should only be called after the eigensolver has run or after  init-params , in the case of  get-epsilon . One normally calls them after  run , or in one of the band functions passed to  run .  (get-hfield which-band)  \nLoads the magnetic ( \\mathbf{H} ) field for the band  which-band .  (get-dfield which-band)  \nLoads the electric displacement ( \\mathbf{D} ) field for the band  which-band .  (get-efield which-band)  \nLoads the electric ( \\mathbf{E} ) field for the band  which-band . This function actually calls  get-dfield  followed by  get-efield-from-dfield , below.  (get-charge-density which-band)  \nLoads the bound charge density  \\nabla \\cdot \\mathbf{E}  for the band  which-band .  (get-epsilon)  \nLoads the dielectric function.  Once loaded, the field can be transformed into another field or a scalar field:  (get-efield-from-dfield)  \nMultiplies by the inverse dielectric tensor to compute the electric field from the displacement field. Only works if a  \\mathbf{D}  field has been loaded.  (fix-field-phase)  \nFix the currently-loaded eigenstate's phase which is normally random in a canonical way, based on the spatial field ( \\mathbf{H} ,  \\mathbf{D} , or  \\mathbf{E} ) that has currently been loaded. The phase is fixed to make the real part of the spatial field as big as possible so that you can hopefully visualize just the real part of the field, and a canonical sign is chosen. See also the  fix-Xfield-phase  band functions, above, which are convenient wrappers around  fix-field-phase .  (compute-field-energy)  \nGiven the  \\mathbf{H}  or  \\mathbf{D}  fields, computes the corresponding energy density function normalized by the total energy in  \\mathbf{H}  or  \\mathbf{D} , respectively. Also prints the fraction of the field in each of its Cartesian components in the following form which is suitable for grepping:  f-energy-components:, k-index, band-index, x-fraction, y-fraction, z-fraction  where  f  is either  h  or  d . The return value of  compute-field-energy  is a list of 7 numbers:  (U xr xi yr yi zr zi) .  U  is the total, unnormalized energy, which is in arbitrary units deriving from the normalization of the eigenstate (e.g. the total energy for  \\mathbf{H}  is always 1.0).  xr  is the fraction of the energy in the real part of the field's x component,  xi  is the fraction in the imaginary part of the x component, etcetera ( yr + yi = y-fraction , and so on).  (compute-field-divergence)  \nGiven a vector field, compute its divergence.  Various integrals and other information about the eigenstate can be accessed by the following functions, useful e.g. for perturbation theory. Functions dealing with the field vectors require a field to be loaded, and functions dealing with the energy density require an energy density to be loaded via  compute-field-energy .  (compute-energy-in-dielectric min-eps max-eps)  \nReturns the fraction of the energy that resides in dielectrics with epsilon in the range  min-eps  to  max-eps .  (compute-energy-in-objects objects...)  \nReturns the fraction of the energy inside zero or more geometric objects.  (compute-energy-integral f)   f  is a function  (f u eps r)  that returns a number given three parameters:  u , the energy density at a point;  eps , the dielectric constant at the same point; and  r , the position vector in lattice coordinates of the point.  compute-energy-integral  returns the integral of  f  over the unit cell. The integral is computed simply as the sum over the grid points times the volume of a grid pixel/voxel. This can be useful e.g. for perturbation-theory calculations.  (compute-field-integral f)  \nLike  compute-energy-integral , but  f  is a function  (f F eps r)  that returns a number, possibly complex, where  F  is the complex field vector at the given point.  (get-epsilon-point r)  \nGiven a position vector  r  (in lattice coordinates), return the interpolated dielectric constant at that point. (Since MPB uses a an effective dielectric tensor internally, this actually returns the mean dielectric constant.)  (get-epsilon-inverse-tensor-point r)  \nGiven a position vector  r  in lattice coordinates, return the interpolated inverse dielectric tensor (a 3x3 matrix) at that point. Near a dielectric interface, the effective dielectric constant is a tensor even if you input only scalar dielectrics; see the  epsilon overview  for more information. The returned matrix may be complex-Hermetian if you are employing magnetic materials.  (get-energy-point r)  \nGiven a position vector  r  in lattice coordinates, return the interpolated energy density at that point.  (get-field-point r)  \nGiven a position vector  r  in lattice coordinates, return the interpolated (complex) field vector at that point.  (get-bloch-field-point r)  \nGiven a position vector  r  in lattice coordinates, return the interpolated complex Bloch field vector at that point. This is the field without the exp(ikx) envelope.  Finally, we have the following functions to output fields (either the vector fields, the scalar energy density, or epsilon), with the option of outputting several periods of the lattice.  (output-field [ nx [ ny [ nz ] ] ])  (output-field-x [ nx [ ny [ nz ] ] ])  (output-field-y [ nx [ ny [ nz ] ] ])  (output-field-z [ nx [ ny [ nz ] ] ])  \nOutput the currently-loaded field. The optional (as indicated by the brackets) parameters  nx ,  ny , and  nz  indicate the number of periods to be outputted along each of the three lattice directions. Omitted parameters are assumed to be 1. For vector fields,  output-field  outputs all of the Cartesian components, while the other variants output only one component.  (output-epsilon [ nx [ ny [ nz ] ] ])  \nA shortcut for calling  get-epsilon  followed by  output-field . Note that, because epsilon is a tensor, a number of datasets are outputted in  \"epsilon.h5\" :   \"data\" : 3/trace(1/epsilon)  \"epsilon.{xx,xy,xz,yy,yz,zz}\" : the (Cartesian) components of the (symmetric) dielectric tensor.  \"epsilon_inverse.{xx,xy,xz,yy,yz,zz}\" : the (Cartesian) components of the (symmetric) inverse dielectric tensor.", 
            "title": "Loading and Manipulating the Current Field"
        }, 
        {
            "location": "/Scheme_User_Interface/#storing-and-combining-multiple-fields", 
            "text": "In order to perform operations involving multiple fields, e.g. computing the Poynting vector  \\mathbf{E}^* \\times \\mathbf{H} , they must be stored in field variables. Field variables come in three flavors, real-scalar (rscalar) fields, complex-scalar (cscalar) fields, and complex-vector (cvector) fields. There is a pre-defined field variable  cur-field  representing the currently-loaded field (see above), and you can \"clone\" it to create more field variables with one of:  (field-make f)  \nReturn a new field variable of the same type and size as the field variable  f . Does  not  copy the field contents. See  field-copy  and  field-set! , below.  (rscalar-field-make f)  (cscalar-field-make f)  (cvector-field-make f)  \nLike  field-make , but return a real-scalar, complex-scalar, or complex-vector field variable, respectively, of the same size as  f  but ignoring  f 's type.  (cvector-field-nonbloch! f)  \nBy default, complex vector fields are assumed to be Bloch-periodic and are multiplied by  e ikx  in output routines. This function tells MPB that the complex vector field  f  should never be multiplied by Bloch phases.  (field-set! fdest fsrc)  \nSet  fdest  to store the same field values as  fsrc , which must be of the same size and type.  (field-copy f)  \nReturn a new field variable that is exact copy of  f ; this is equivalent to calling  field-make  followed by  field-set! .  (field-load f)  \nLoads the field  f  as the current field, at which point you can use all of the functions in the  previous section  to operate on it or output it.  Once you have stored the fields in variables, you probably want to compute something with them. This can be done in three ways: combining fields into new fields with  field-map!  (e.g. combine  \\mathbf{E}  and  \\mathbf{H}  to  \\mathbf{E}^* \\times \\mathbf{H} ), integrating some function of the fields with  integrate-fields  (e.g. to compute coupling integrals for perturbation theory), and getting the field values at arbitrary points with  *-field-get-point  (e.g. to do a line or surface integral). These three functions are described below:  (field-map! fdest func [f1 f2 ...])  \nCompute the new field  fdest  to be  (func f1-val f2-val ...)  at each point in the grid, where  f1-val  etcetera is the corresponding value of  f1  etcetera. All the fields must be of the same size, and the argument and return types of  func  must match those of the  f1...  and  fdest  fields, respectively.  fdest  may be the same field as one of the  f1...  arguments. Note: all fields are  without  Bloch phase factors exp(ikx).  (integrate-fields func [f1 f2 ...])  \nCompute the integral of the function  (func r [f1 f2 ...])  over the computational cell, where  r  is the position in the usual lattice basis and  f1  etc. are fields which must all be of the same size. The integral is computed simply as the sum over the grid points times the volume of a grid pixel/voxel. Note: all fields are  without  Bloch phase factors exp(ikx). See also the note  below .  (cvector-field-get-point f r)  (cvector-field-get-point-bloch f r)  (rscalar-field-get-point f r)  \nGiven a position vector  r  in lattice coordinates, return the interpolated field cvector/rscalar from  f  at that point.  cvector-field-get-point-bloch  returns the field  without  the exp(ikx) Bloch wavevector, in analogue to  get-bloch-field-point .  You may be wondering how to get rid of the field variables once you are done with them: you don't, since they are  garbage collected  automatically.  We also provide functions, in analogue to e.g  get-efield  and  output-efield  above, to \"get\" various useful functions as the  current field  and to output them to a file:  (get-poynting which-band)  \nLoads the Poynting vector  \\mathbf{E}^* \\times \\mathbf{H}  for the band  which-band , the flux density of electromagnetic energy flow, as the current field. 1/2 of the real part of this vector is the time-average flux density which can be combined with the imaginary part to determine the amplitude and phase of the time-dependent flux.  (output-poynting which-band)  (output-poynting-x which-band)  (output-poynting-y which-band)  (output-poynting-z which-band)  \nOutput the Poynting vector field for  which-band ; either all or one of the Cartesian components, respectively.  (get-tot-pwr which-band)  \nLoad the time-averaged electromagnetic-field energy density ( |\\mathbf{H}|^2 + \\varepsilon |\\mathbf{E}|^2 ) for  which-band . If you multiply the real part of the Poynting vector by a factor of 1/2, above, you should multiply by a factor of 1/4 here for consistency.  (output-tot-pwr which-band)  \nOutput the time-averaged electromagnetic-field energy density (above) for  which-band .  (output-charge-density which-band)  \nOutput the bound charge density (above) for  which-band .  As an example, below is the Scheme source code for the  get-poynting  function, illustrating the use of the various field functions:  (define\u00a0(get-poynting\u00a0which-band)\n\u00a0\u00a0(get-efield\u00a0which-band)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0put\u00a0E\u00a0in\u00a0cur-field\n\u00a0\u00a0(let\u00a0((e\u00a0(field-copy\u00a0cur-field)))\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0...\u00a0and\u00a0copy\u00a0to\u00a0local\u00a0var.\n\u00a0\u00a0\u00a0\u00a0(get-hfield\u00a0which-band)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0put\u00a0H\u00a0in\u00a0cur-field\n\u00a0\u00a0\u00a0\u00a0(field-map!\u00a0cur-field\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0write\u00a0ExH\u00a0to\u00a0cur-field\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(lambda\u00a0(e\u00a0h)\u00a0(vector3-cross\u00a0(vector3-conj\u00a0e)\u00a0h))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0e\u00a0cur-field)\n\u00a0\u00a0\u00a0\u00a0(cvector-field-nonbloch!\u00a0cur-field)))\u00a0\u00a0\u00a0\u00a0\u00a0;\u00a0see\u00a0below", 
            "title": "Storing and Combining Multiple Fields"
        }, 
        {
            "location": "/Scheme_User_Interface/#stored-fields-and-bloch-phases", 
            "text": "Complex vector fields like  E  and  H  as computed by MPB are physically of the Bloch form: exp(ikx) times a periodic function. What MPB actually stores, however, is just the periodic function, the Bloch envelope, and only multiplies by exp(ikx) when the fields are output or passed to the user (e.g. in integration functions). This is mostly transparent, with a few exceptions noted above for functions that do not include the exp(ikx) Bloch phase. It is somewhat faster to operate without including the phase.  On some occasions, however, when you create a field with  field-map! , the resulting field should  not  have any Bloch phase. For example, for the Poynting vector  E * x H , the exp(ikx) cancels because of the complex conjugation. After creating this sort of field, we must use the special function  cvector-field-nonbloch!  to tell MPB that the field is purely periodic:  (cvector-field-nonbloch! f)  \nSpecify that the field  f  is  not  of the Bloch form, but rather that it is purely periodic.  Currently, all fields must be either Bloch or non-Bloch (i.e. periodic), which covers most physically meaningful possibilities.  There is another wrinkle: even for fields in Bloch form, the exp(ikx) phase currently always uses the  current  k-point, even if the field was computed from another k-point. So, if you are performing computations combining fields from different k-points, you should take care to always use the periodic envelope of the field, putting the Bloch phase in manually if necessary.", 
            "title": "Stored Fields and Bloch Phases"
        }, 
        {
            "location": "/Scheme_User_Interface/#manipulating-the-raw-eigenvectors", 
            "text": "MPB also includes a few low-level routines to manipulate the raw eigenvectors that it computes in a transverse planewave basis.  The most basic operations involve copying, saving, and restoring the current set of eigenvectors or some subset thereof:  (get-eigenvectors first-band num-bands)  \nReturn an eigenvector object that is a copy of  num-bands  current eigenvectors starting at  first-band . e.g. to get a copy of all of the eigenvectors, use  (get-eigenvectors 1 num-bands) .  (set-eigenvectors ev first-band)  \nSet the current eigenvectors, starting at  first-band , to those in the  ev  eigenvector object (as returned by  get-eigenvectors ). Does not work if the grid sizes don't match.  (load-eigenvectors filename)  (save-eigenvectors filename)  \nRead/write the current eigenvectors (raw planewave amplitudes) to/from an HDF5 file named  filename . Instead of using  load-eigenvectors  directly, you can pass the  filename  as the  reset-fields  parameter of  run-parity , as  shown above . Loaded eigenvectors must be of the same size (same grid size and #bands) as the current settings.  Currently, there's only one other interesting thing you can do with the raw eigenvectors, and that is to compute the dot-product matrix between a set of saved eigenvectors and the current eigenvectors. This can be used, e.g., to detect band crossings or to set phases consistently at different k points. The dot product is returned as a \"sqmatrix\" object, whose elements can be read with the  sqmatrix-size  and  sqmatrix-ref  routines.  (dot-eigenvectors ev first-band)  \nReturns a sqmatrix object containing the dot product of the saved eigenvectors  ev  with the current eigenvectors, starting at  first-band . That is, the ( i,j )th output matrix element contains the dot product of the ( i+1 )th vector of  ev  conjugated with the ( first-band+j )th eigenvector. Note that the eigenvectors, when computed, are orthonormal, so the dot product of the eigenvectors with themselves is the identity matrix.  (sqmatrix-size sm)  \nReturn the size  n  of an  n x n  sqmatrix  sm .  (sqmatrix-ref sm i j)  \nReturn the ( i , j )th element of the  n x n  sqmatrix  sm , where { i , j } range from 0.. n -1.", 
            "title": "Manipulating the Raw Eigenvectors"
        }, 
        {
            "location": "/Scheme_User_Interface/#inversion-symmetry", 
            "text": "If you  configure  MPB with the  --with-inv-symmetry  flag, then the program is configured to assume inversion symmetry in the dielectric function. This allows it to run at least twice as fast and use half as much memory as the more general case. This version of MPB is by default installed as  mpbi , so that it can coexist with the usual  mpb  program.  Inversion symmetry means that if you transform (x,y,z) to (-x,-y,-z) in the coordinate system, the dielectric structure is not affected. Or, more technically, that (see  our online textbook , ch. 3):   \\varepsilon(\\mathbf{x}) = \\varepsilon(-\\mathbf{x})^*   where the conjugation is significant for complex-hermitian dielectric tensors. This symmetry is very common; all of the examples in this manual have inversion symmetry, for example.  Note that inversion symmetry is defined with respect to a specific origin, so that you may \"break\" the symmetry if you define a given structure in the wrong way\u2014this will prevent  mpbi  from working properly. For example, the  diamond structure  that we considered earlier would not have possessed inversion symmetry had we positioned one of the \"atoms\" to lie at the origin.  You might wonder what happens if you pass a structure lacking inversion symmetry to  mpbi . As it turns out,  mpbi  only looks at half of the structure, and infers the other half by the inversion symmetry, so the resulting structure  always  has inversion symmetry, even if its original description did not. So, you should be careful, and look at the  epsilon.h5  output to make sure it is what you expected.", 
            "title": "Inversion Symmetry"
        }, 
        {
            "location": "/Scheme_User_Interface/#parallel-mpb", 
            "text": "We provide two methods by which you can parallelize MPB. The first, using MPI, is the most sophisticated and potentially provides the greatest and most general benefits. The second, which involves a simple script to split e.g. the  k-points  list among several processes, is less general but may be useful in many cases.", 
            "title": "Parallel MPB"
        }, 
        {
            "location": "/Scheme_User_Interface/#mpb-with-mpi-parallelization", 
            "text": "If you  configure  MPB with the  --with-mpi  flag, then the program is compiled to take advantage of distributed-memory parallel machines with  MPI , and is installed as  mpb-mpi . See also the  installation guide . This means that computations will potentially run more quickly and take up less memory per processor than for the serial code. Normally, you should also install the serial version of MPB, if only to get the  mpb-data  program, which is not installed with  mpb-mpi .  Using the parallel MPB is almost identical to using the serial version(s), with a couple of minor exceptions. The same ctl files should work for both. Running a program that uses MPI requires slightly different invocations on different systems, but will typically be something like:  unix% mpirun -np 4 mpb-mpi foo.ctl  to run on e.g. 4 processors. A second difference is that 1D systems are currently not supported in the MPI code, but the serial code should be fast enough for those anyway. A third difference is that the output HDF5 files (epsilon, fields, etcetera) from  mpb-mpi  have their first two dimensions (x and y)  transposed ; i.e. they are output as YxXxZ arrays. This doesn't prevent you from visualizing them, but the coordinate system is left-handed; to un-transpose the data, you can process it with  mpb-data  and the  -T  option in addition to any other options.  In order to get optimal benefit (time and memory savings) from  mpb-mpi , the first two dimensions (n x  and n y ) of your grid should  both  be divisible by the number of processes. If you violate this constraint, MPB will still work, but the load balance between processors will be uneven. At worst, e.g. if either n x  or n y  is smaller than the number of processes, then some of the processors will be idle for part or all of the computation. When using  inversion symmetry  ( mpbi-mpi ) for 2D grids only, the optimal case is somewhat more complicated: n x  and (n y /2 + 1), not n y , should both be divisible by the number of processes.  mpb-mpi  divides each band at each k-point between the available processors. This means that, even if you have only a single k-point (e.g. in a defect calculation) and/or a single band, it can benefit from parallelization. Moreover, memory usage per processor is inversely proportional to the number of processors used. For sufficiently large problems, the speedup is also nearly linear.", 
            "title": "MPB with MPI Parallelization"
        }, 
        {
            "location": "/Scheme_User_Interface/#alternative-parallelization-mpb-split", 
            "text": "There is an alternative method of parallelization when you have multiple k points: do each k-point on a different processor. This does not provide any memory benefits, and does not allow one k-point to benefit by starting with the fields of the previous k-point, but is easy and may be the only effective way to parallelize calculations for small problems. This method also does not require MPI: it can utilize the unmodified serial  mpb  program. To make it even easier, we supply a simple script called  mpb-split  (or  mpbi-split ) to break the  k-points  list into chunks for you. Running:  unix% mpb-split num-split foo.ctl  will break the  k-points  list in  foo.ctl  into  num-split  more-or-less equal chunks, launch  num-split  processes of  mpb  in parallel to process each chunk, and output the results of each in order. Each process is an ordinary  mpb  execution, except that it numbers its  k-points  depending upon which chunk it is in, so that output files will not overwrite one another and you can still  grep  for frequencies as usual.  Of course, this will only benefit you on a system where different processes will run on different processors, such as an SMP or a cluster with automatic process migration (e.g.  MOSIX ).  mpb-split  is actually a trivial shell script, though, so you can easily modify it if you need to use a special command to launch processes on other processors/machines (e.g. via  GNU Parallel ).  The general syntax for  mpb-split  is:  unix% mpb-split num-split mpb-arguments...  where all of the arguments following  num-split  are passed along to  mpb . What  mpb-split  technically does is to set the MPB variable  k-split-num  to  num-split  and  k-split-index  to the index (starting with 0) of the chunk for each process.", 
            "title": "Alternative Parallelization: mpb-split"
        }, 
        {
            "location": "/Developer_Information/", 
            "text": "Developer Information\n\n\nHere, we begin with a brief overview of what the program is computing, and then describe how the program and computation are broken up into different portions of the code.\n\n\nA \nChinese version\n of this document is also available.\n\n\nTable of Contents\n\n\nDeveloper Information\n\n\nThe Mathematics of MPB\n\n\nDielectric Function Computation\n\n\nCode Organization\n\n\nsrc/matrices/\n\n\nsrc/util/\n\n\nsrc/matrixio\n\n\nsrc/maxwell/\n\n\nmpb-ctl/\n\n\n\n\n\n\n\n\n\n\nThe Mathematics of MPB\n\n\nThis section provides a whirlwind tour of the mathematics of photonic band structure calculations and the algorithms that we employ. For more detailed information, see:\n\n\n\n\nPhotonic Crystals: Molding the Flow of Light\n, by J. D. Joannopoulos, S. G. Johnson, R. D. Meade, and J. N. Winn (Princeton, 2008).\n\n\nSteven G. Johnson and J. D. Joannopoulos, \nBlock-iterative frequency-domain methods for Maxwell's equations in a planewave basis\n, \nOptics Express\n \n8\n, no. 3, 173-190 (2001).\n\n\n\n\nMPB takes a periodic dielectric structure and computes the \neigenmodes\n of that structure, which are the electromagnetic waves that can propagate through the structure with a definite frequency. This corresponds to solving an eigenvalue problem\n\n\n\n\n\\hat\\Theta \\mathbf{H} = \\frac{\\omega^2}{c^2} \\mathbf{H},\n where \n\\mathbf{H}\n is the magnetic field, \n\\omega\n is the frequency, and \n\\hat\\Theta\n is the Maxwell operator\n\n\n\n\n\\hat\\Theta = \\nabla\\times \\frac{1}{\\varepsilon} \\nabla\\times \\,.\n We also have an additional constraint, that \n\\nabla \\cdot \\mathbf{H}\n be zero (the magnetic field must be \"transverse\").\n\n\nSince the structure is periodic, we can also invoke Bloch's theorem to write the states in the form:\n\n\n\n\n\\mathbf{H} = \\mathbf{H}_\\mathbf{k}(\\mathbf{x}) e^{i \\mathbf{k} \\cdot \\mathbf{x}},\n where \n\\mathbf{H}_\\mathbf{k}\n is a periodic function (the Bloch envelope) and \n\\mathbf{k}\n is the Bloch wavevector. So, at each k-point (Bloch wavevector), we need to solve for a discrete set of eigenstates, the photonic bands of the structure.\n\n\nTo solve for the eigenstates on a computer, we must expand the magnetic field in some basis, where we truncate the basis to some finite number of points to discretize the problem. For example, we could use a traditional finite-element basis in which the field is taken on a finite number of mesh points and linearly interpolated in between. However, it is expensive to enforce the transversality constraint in this basis. Instead, we use a Fourier (spectral) basis, expanding the periodic part of the field as a sum of planewaves:\n\n\n\n\n\\mathbf{H}_\\mathbf{k} = \\sum_\\mathbf{G} \\mathbf{h}_\\mathbf{G} e^{i \\mathbf{G} \\cdot \\mathbf{x}} \\, .\n In this basis, the transversality constraint is easy to maintain, as it merely implies that the planewave amplitudes \n\\mathbf{h}_\\mathbf{G}\n must be orthogonal to \n\\mathbf{k}+\\mathbf{G}\n.\n\n\nIn order to find the eigenfunctions, we could compute the elements of \n\\hat\\Theta\n explicitly in our basis, and then call LAPACK or some similar code to find the eigenvectors and eigenvalues. For a three-dimensional calculation, this could mean finding the eigenvectors of a matrix with millions of elements on a side--daunting merely to store, much less compute. Fortunately, we only want to know a few eigenvectors, not hundreds of thousands, so we can use much less expensive \niterative\n methods that don't require us to store \n\\hat\\Theta\n explicitly.\n\n\nIterative eigensolvers require only that one supply a routine to operate \n\\hat\\Theta\n on a vector (function). Starting with an initial guess for the eigenvector, they then converge quickly to the actual eigenvector, stopping when the desired tolerance is achieved. There are many iterative eigensolver methods; we use a preconditioned block minimization of the Rayleigh quotient which is further described in the file \nsrc/matrices/eigensolver.c\n. In the Fourier basis, applying \n\\hat\\Theta\n to a function is relatively easy: the curls become cross products with \ni(\\mathbf{k}+\\mathbf{G})\n; the multiplication by \n1/\\varepsilon\n is performed by using an \nFFT\n to transform to the spatial domain, multiplying, and then transforming back with an inverse FFT. For more information and references on iterative eigensolvers, see the paper cited above.\n\n\nWe also support a \"targeted\" eigensolver. A typical iterative eigensolver finds the \np\n lowest eigenvalues and eigenvectors. Instead, we can find the \np\n eigenvalues closest to a given frequency \n\\omega_0\n by solving for the eigenvalues of \n(\\hat\\Theta-\\omega_0^2/c^2)^2\n instead of \n\\hat\\Theta\n. This new operator has the same eigenvectors as \n\\hat\\Theta\n, but its eigenvalues have been shifted to make those closest to \n\\omega_0\n the smallest. This is not really the best algorithm to find interior eigenvalues like this; a future version of MPB may use ARPACK-style shift-and-invert Arnoldi, or perhaps the Jacobi-Davidson algorithm.\n\n\nThe eigensolver we use is preconditioned, which means that convergence can be greatly improved by suppling a good preconditioner matrix. Finding a good preconditioner involves making an approximate inverse of \n\\hat\\Theta\n, and is something of a black art with lots of trial and error.\n\n\nDielectric Function Computation\n\n\nThe initialization of the dielectric function deserves some additional discussion, both because it is crucial for good convergence, and because we use somewhat complicated algorithms for performance reasons.\n\n\nTo ameliorate the convergence problems caused in a planewave basis by a discontinuous dielectric function, the dielectric function is smoothed (averaged) at the resolution of the grid. Another way of thinking about it is that this brings the average dielectric constant (over the grid) closer to its true value. Since different polarizations of the field prefer different averaging methods, one has to construct an effective dielectric tensor at the boundaries between dielectrics, as described by the paper referenced above.\n\n\nThis averaging has two components. First, at each grid point the dielectric constant (\n\\varepsilon\n) and its inverse are averaged over a uniform mesh extending halfway to the neighboring grid points. The mesh resolution is controlled by the \nmesh-size\n user input variable. Second, for grid points on the boundary between two dielectrics, we compute the vector normal to the dielectric interface; this is done by averaging the \"dipole moment\" of the dielectric function over a spherically-symmetric distribution of points. The normal vector and the two averages of epsilon are then combined into an effective dielectric tensor for the grid point.\n\n\nAll of this averaging is handled by a subroutine in \nsrc/maxwell/\n (see below) that takes as input a function \n\\varepsilon\n(\nr\n), which returns the dielectric constant for a given position \nr\n. This epsilon function must be as efficient as possible, because it is evaluated a large number of times: the size of the grid multiplied by \nmesh-size\n3\n (in three dimensions).\n\n\nTo specify the geometry, the user provides a list of geometric objects (blocks, spheres, cylinders and so on). These are parsed into an efficient data structure and are used to to provide the epsilon function described above. All of this is handled by the libctlgeom component of libctl, described below. At the heart of the epsilon function is a routine to return the geometric object enclosing a given point, taking into account the fact that the objects are periodic in the lattice vectors. Our first algorithm for doing this was a simple linear search through the list of objects and their translations by the lattice vectors, but this proved to be too slow, especially in supercell calculations where there are many objects. We addressed the performance problem in two ways. First, for each object we construct a bounding box, with which point inclusion can be tested rapidly. Second, we build a hierarchical tree of bounding boxes, recursively partitioning the set of objects in the cell. This allows us to search for the object containing a point in a time logarithmic in the number of objects instead of linear as before.\n\n\nCode Organization\n\n\nThe code is organized to keep the core computation independent of the user interface, and to keep the eigensolver routines independent of the operator they are computing the eigenvector of. The computational code is located in the \nsrc/\n directory, with a few major subdirectories, described below. The Guile-based user interface is completely contained within the \nmpb-ctl/\n directory.\n\n\nsrc/matrices/\n\n\nThis directory contains the eigensolver, in \neigensolver.c\n, to which you pass an operator and it returns the eigenvectors. Eigenvectors are stored using the \nevectmatrix\n data structure, which holds \np\n eigenvectors of length \nn\n, potentially distributed over \nn\n in MPI. See \nsrc/matrices/README\n for more information about the data structures. In particular, you should use the supplied functions (\ncreate_evectmatrix\n, etcetera) to create and manipulate the data structures, where possible.\n\n\nThe type of the eigenvector elements is determined by \nscalar.h\n, which sets whether they are real or complex and single or double precision. This is, in turn, controlled by the \n--disable-complex\n and \n--enable-single\n parameters to the \nconfigure\n script at install-time. \nscalar.h\n contains macros to make it easier to support both real and complex numbers elsewhere in the code.\n\n\nAlso in this directory is \nblasglue.c\n, a set of wrapper routines to make it convienient to call BLAS and LAPACK routines from C instead of Fortran.\n\n\nsrc/util/\n\n\nAs its name implies, this is simply a number of utility routines for use elsewhere in the code. Of particular note is \ncheck.h\n, which defines a \nCHECK(condition, error-message)\n macro that is used extensively in the code to improve robustness. There are also debugging versions of malloc/free (which perform lots of paranoia tests, enabled by \n--enable-debug-malloc\n in \nconfigure\n), and MPI glue routines that allow the program to operate without the MPI libraries.\n\n\nsrc/matrixio\n\n\nThis section contains code to abstract I/O for eigenvectors and similar matrices, providing a simpler layer on top of the HDF5 interface. This could be modified to support other I/O formats.\n\n\nsrc/maxwell/\n\n\nThe \nmaxwell/\n directory contains all knowledge of Maxwell's equations used by the program. It implements functions to apply the Maxwell operator to a vector (in \nmaxwell_op.c\n) and compute a good preconditioner (in \nmaxwell_pre.c\n). These functions operate upon a representation of the fields in a transverse Fourier basis.\n\n\nIn order to use these functions, one must first initialize a \nmaxwell_data\n structure with \ncreate_maxwell_data\n (defined in \nmaxwell.c\n) and specify a k point with \nupdate_maxwell_data_k\n. One must also initialize the dielectric function using \nset_maxwell_dielectric\n by supplying a function that returns the dielectric constant for any given coordinate. You can also restrict yourself to TE or TM polarizations in two dimensions by calling \nset_maxwell_data_polarization\n.\n\n\nThis directory also contains functions \nmaxwell_compute_dfield\n, etcetera, to compute the position-space fields from the Fourier-transform representation returned by the eigensolver.\n\n\nmpb-ctl/\n\n\nHere is the Guile-based user interface code for the eigensolver. Instead of using Guile directly, this code is built on top of the \nlibctl\n library as described in previous sections. This means that the user-interface code (in \nmpb.c\n) is fairly short, consisting of a number of small functions that are callable by the user from Guile.\n\n\nThe core of the user interface is the file \nmpb.scm\n, the \nspecifications file\n for libctl as described in the \nlibctl manual\n. Actually, \nmpb.scm\n is generated by \nconfigure\n from \nmpb.scm.in\n in order to substitute in parameters like the location of the libctl library. You should only edit \nmpb.scm.in\n directly. You can regenerate \nmpb.scm\n simply by running \n./config.status\n instead of re-running \nconfigure\n.\n\n\nThe specifications file defines the data structures and subroutines that are visible to the Guile user. It also defines a number of Scheme subroutines for the user to call directly, like \n(run)\n. It is often simpler and more flexible to define functions like this in Scheme rather than in C.\n\n\nAll of the code to handle the geometric objects resides in libctlgeom, a set of Scheme and C utility functions included with libctl (see the file \nutils/README\n in the libctl package). These functions could also be useful in other programs, such as a time-domain Maxwell's equation simulator.", 
            "title": "Developer Information"
        }, 
        {
            "location": "/Developer_Information/#the-mathematics-of-mpb", 
            "text": "This section provides a whirlwind tour of the mathematics of photonic band structure calculations and the algorithms that we employ. For more detailed information, see:   Photonic Crystals: Molding the Flow of Light , by J. D. Joannopoulos, S. G. Johnson, R. D. Meade, and J. N. Winn (Princeton, 2008).  Steven G. Johnson and J. D. Joannopoulos,  Block-iterative frequency-domain methods for Maxwell's equations in a planewave basis ,  Optics Express   8 , no. 3, 173-190 (2001).   MPB takes a periodic dielectric structure and computes the  eigenmodes  of that structure, which are the electromagnetic waves that can propagate through the structure with a definite frequency. This corresponds to solving an eigenvalue problem   \\hat\\Theta \\mathbf{H} = \\frac{\\omega^2}{c^2} \\mathbf{H},  where  \\mathbf{H}  is the magnetic field,  \\omega  is the frequency, and  \\hat\\Theta  is the Maxwell operator   \\hat\\Theta = \\nabla\\times \\frac{1}{\\varepsilon} \\nabla\\times \\,.  We also have an additional constraint, that  \\nabla \\cdot \\mathbf{H}  be zero (the magnetic field must be \"transverse\").  Since the structure is periodic, we can also invoke Bloch's theorem to write the states in the form:   \\mathbf{H} = \\mathbf{H}_\\mathbf{k}(\\mathbf{x}) e^{i \\mathbf{k} \\cdot \\mathbf{x}},  where  \\mathbf{H}_\\mathbf{k}  is a periodic function (the Bloch envelope) and  \\mathbf{k}  is the Bloch wavevector. So, at each k-point (Bloch wavevector), we need to solve for a discrete set of eigenstates, the photonic bands of the structure.  To solve for the eigenstates on a computer, we must expand the magnetic field in some basis, where we truncate the basis to some finite number of points to discretize the problem. For example, we could use a traditional finite-element basis in which the field is taken on a finite number of mesh points and linearly interpolated in between. However, it is expensive to enforce the transversality constraint in this basis. Instead, we use a Fourier (spectral) basis, expanding the periodic part of the field as a sum of planewaves:   \\mathbf{H}_\\mathbf{k} = \\sum_\\mathbf{G} \\mathbf{h}_\\mathbf{G} e^{i \\mathbf{G} \\cdot \\mathbf{x}} \\, .  In this basis, the transversality constraint is easy to maintain, as it merely implies that the planewave amplitudes  \\mathbf{h}_\\mathbf{G}  must be orthogonal to  \\mathbf{k}+\\mathbf{G} .  In order to find the eigenfunctions, we could compute the elements of  \\hat\\Theta  explicitly in our basis, and then call LAPACK or some similar code to find the eigenvectors and eigenvalues. For a three-dimensional calculation, this could mean finding the eigenvectors of a matrix with millions of elements on a side--daunting merely to store, much less compute. Fortunately, we only want to know a few eigenvectors, not hundreds of thousands, so we can use much less expensive  iterative  methods that don't require us to store  \\hat\\Theta  explicitly.  Iterative eigensolvers require only that one supply a routine to operate  \\hat\\Theta  on a vector (function). Starting with an initial guess for the eigenvector, they then converge quickly to the actual eigenvector, stopping when the desired tolerance is achieved. There are many iterative eigensolver methods; we use a preconditioned block minimization of the Rayleigh quotient which is further described in the file  src/matrices/eigensolver.c . In the Fourier basis, applying  \\hat\\Theta  to a function is relatively easy: the curls become cross products with  i(\\mathbf{k}+\\mathbf{G}) ; the multiplication by  1/\\varepsilon  is performed by using an  FFT  to transform to the spatial domain, multiplying, and then transforming back with an inverse FFT. For more information and references on iterative eigensolvers, see the paper cited above.  We also support a \"targeted\" eigensolver. A typical iterative eigensolver finds the  p  lowest eigenvalues and eigenvectors. Instead, we can find the  p  eigenvalues closest to a given frequency  \\omega_0  by solving for the eigenvalues of  (\\hat\\Theta-\\omega_0^2/c^2)^2  instead of  \\hat\\Theta . This new operator has the same eigenvectors as  \\hat\\Theta , but its eigenvalues have been shifted to make those closest to  \\omega_0  the smallest. This is not really the best algorithm to find interior eigenvalues like this; a future version of MPB may use ARPACK-style shift-and-invert Arnoldi, or perhaps the Jacobi-Davidson algorithm.  The eigensolver we use is preconditioned, which means that convergence can be greatly improved by suppling a good preconditioner matrix. Finding a good preconditioner involves making an approximate inverse of  \\hat\\Theta , and is something of a black art with lots of trial and error.", 
            "title": "The Mathematics of MPB"
        }, 
        {
            "location": "/Developer_Information/#dielectric-function-computation", 
            "text": "The initialization of the dielectric function deserves some additional discussion, both because it is crucial for good convergence, and because we use somewhat complicated algorithms for performance reasons.  To ameliorate the convergence problems caused in a planewave basis by a discontinuous dielectric function, the dielectric function is smoothed (averaged) at the resolution of the grid. Another way of thinking about it is that this brings the average dielectric constant (over the grid) closer to its true value. Since different polarizations of the field prefer different averaging methods, one has to construct an effective dielectric tensor at the boundaries between dielectrics, as described by the paper referenced above.  This averaging has two components. First, at each grid point the dielectric constant ( \\varepsilon ) and its inverse are averaged over a uniform mesh extending halfway to the neighboring grid points. The mesh resolution is controlled by the  mesh-size  user input variable. Second, for grid points on the boundary between two dielectrics, we compute the vector normal to the dielectric interface; this is done by averaging the \"dipole moment\" of the dielectric function over a spherically-symmetric distribution of points. The normal vector and the two averages of epsilon are then combined into an effective dielectric tensor for the grid point.  All of this averaging is handled by a subroutine in  src/maxwell/  (see below) that takes as input a function  \\varepsilon ( r ), which returns the dielectric constant for a given position  r . This epsilon function must be as efficient as possible, because it is evaluated a large number of times: the size of the grid multiplied by  mesh-size 3  (in three dimensions).  To specify the geometry, the user provides a list of geometric objects (blocks, spheres, cylinders and so on). These are parsed into an efficient data structure and are used to to provide the epsilon function described above. All of this is handled by the libctlgeom component of libctl, described below. At the heart of the epsilon function is a routine to return the geometric object enclosing a given point, taking into account the fact that the objects are periodic in the lattice vectors. Our first algorithm for doing this was a simple linear search through the list of objects and their translations by the lattice vectors, but this proved to be too slow, especially in supercell calculations where there are many objects. We addressed the performance problem in two ways. First, for each object we construct a bounding box, with which point inclusion can be tested rapidly. Second, we build a hierarchical tree of bounding boxes, recursively partitioning the set of objects in the cell. This allows us to search for the object containing a point in a time logarithmic in the number of objects instead of linear as before.", 
            "title": "Dielectric Function Computation"
        }, 
        {
            "location": "/Developer_Information/#code-organization", 
            "text": "The code is organized to keep the core computation independent of the user interface, and to keep the eigensolver routines independent of the operator they are computing the eigenvector of. The computational code is located in the  src/  directory, with a few major subdirectories, described below. The Guile-based user interface is completely contained within the  mpb-ctl/  directory.", 
            "title": "Code Organization"
        }, 
        {
            "location": "/Developer_Information/#srcmatrices", 
            "text": "This directory contains the eigensolver, in  eigensolver.c , to which you pass an operator and it returns the eigenvectors. Eigenvectors are stored using the  evectmatrix  data structure, which holds  p  eigenvectors of length  n , potentially distributed over  n  in MPI. See  src/matrices/README  for more information about the data structures. In particular, you should use the supplied functions ( create_evectmatrix , etcetera) to create and manipulate the data structures, where possible.  The type of the eigenvector elements is determined by  scalar.h , which sets whether they are real or complex and single or double precision. This is, in turn, controlled by the  --disable-complex  and  --enable-single  parameters to the  configure  script at install-time.  scalar.h  contains macros to make it easier to support both real and complex numbers elsewhere in the code.  Also in this directory is  blasglue.c , a set of wrapper routines to make it convienient to call BLAS and LAPACK routines from C instead of Fortran.", 
            "title": "src/matrices/"
        }, 
        {
            "location": "/Developer_Information/#srcutil", 
            "text": "As its name implies, this is simply a number of utility routines for use elsewhere in the code. Of particular note is  check.h , which defines a  CHECK(condition, error-message)  macro that is used extensively in the code to improve robustness. There are also debugging versions of malloc/free (which perform lots of paranoia tests, enabled by  --enable-debug-malloc  in  configure ), and MPI glue routines that allow the program to operate without the MPI libraries.", 
            "title": "src/util/"
        }, 
        {
            "location": "/Developer_Information/#srcmatrixio", 
            "text": "This section contains code to abstract I/O for eigenvectors and similar matrices, providing a simpler layer on top of the HDF5 interface. This could be modified to support other I/O formats.", 
            "title": "src/matrixio"
        }, 
        {
            "location": "/Developer_Information/#srcmaxwell", 
            "text": "The  maxwell/  directory contains all knowledge of Maxwell's equations used by the program. It implements functions to apply the Maxwell operator to a vector (in  maxwell_op.c ) and compute a good preconditioner (in  maxwell_pre.c ). These functions operate upon a representation of the fields in a transverse Fourier basis.  In order to use these functions, one must first initialize a  maxwell_data  structure with  create_maxwell_data  (defined in  maxwell.c ) and specify a k point with  update_maxwell_data_k . One must also initialize the dielectric function using  set_maxwell_dielectric  by supplying a function that returns the dielectric constant for any given coordinate. You can also restrict yourself to TE or TM polarizations in two dimensions by calling  set_maxwell_data_polarization .  This directory also contains functions  maxwell_compute_dfield , etcetera, to compute the position-space fields from the Fourier-transform representation returned by the eigensolver.", 
            "title": "src/maxwell/"
        }, 
        {
            "location": "/Developer_Information/#mpb-ctl", 
            "text": "Here is the Guile-based user interface code for the eigensolver. Instead of using Guile directly, this code is built on top of the  libctl  library as described in previous sections. This means that the user-interface code (in  mpb.c ) is fairly short, consisting of a number of small functions that are callable by the user from Guile.  The core of the user interface is the file  mpb.scm , the  specifications file  for libctl as described in the  libctl manual . Actually,  mpb.scm  is generated by  configure  from  mpb.scm.in  in order to substitute in parameters like the location of the libctl library. You should only edit  mpb.scm.in  directly. You can regenerate  mpb.scm  simply by running  ./config.status  instead of re-running  configure .  The specifications file defines the data structures and subroutines that are visible to the Guile user. It also defines a number of Scheme subroutines for the user to call directly, like  (run) . It is often simpler and more flexible to define functions like this in Scheme rather than in C.  All of the code to handle the geometric objects resides in libctlgeom, a set of Scheme and C utility functions included with libctl (see the file  utils/README  in the libctl package). These functions could also be useful in other programs, such as a time-domain Maxwell's equation simulator.", 
            "title": "mpb-ctl/"
        }, 
        {
            "location": "/Guile_and_Scheme_Information/", 
            "text": "Guile and Scheme Information\n\n\n\n\nThere are many places you can go to find out more regarding Guile and the Scheme programming language. We list a few of them here:\n\n\nTable of Contents\n\n\nGuile and Scheme Information\n\n\nScheme\n\n\nGuile\n\n\nHow to Write a Loop in Scheme\n\n\nHow to Read In Values from a Text File in Scheme\n\n\nTricks Specific to Libctl-Using Programs such as MPB or Meep\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScheme\n\n\nScheme is a simplified derivative of \nLisp\n, and is a small and beautiful dynamically typed, \nlexically scoped\n, \nfunctional\n language.\n\n\n\n\nA \nhistory and introduction to Scheme\n\n\nR5RS\n is the official Scheme language definition and reference.\n\n\nA classic \nintroduction\n to Scheme by Ken Dickey.\n\n\nStructure and Interpretation of Computer Programs\n by Abelson, Sussman, and Sussman (full text online).\n\n\nIntroduction to Scheme and its Implementation\n (the complete book on-line) by Prof. Paul R. Wilson (\nUniv. of Texas\n).\n\n\nTeach Yourself Scheme\n is a nice tutorial-style introduction to Scheme programming.\n\n\nThe \nMIT Scheme Home Page\n (where do you think Scheme was invented?)\n\n\nalso check out the MIT \nScheme Underground\n\n\n\n\n\n\nThere is the \ncomp.lang.scheme\n newsgroup, and its \nFAQ\n.\n\n\nThe \nInternet Scheme Repository\n has a lot of code and documentation.\n\n\nschemers.org\n is another Scheme site and collection of resources.\n\n\n\n\nGuile\n\n\nGuile is a free implementation of Scheme, designed to be plugged in to other programs as a scripting language.\n\n\n\n\nThe \nhomepage\n for the GNU Guile project.\n\n\nSee parts IV and V of the \nGuile Reference Manual\n for additional Scheme functions and types defined within the Guile environment.\n\n\n\n\nHow to Write a Loop in Scheme\n\n\nThe most frequently asked question seems to be: \nhow do I write a loop in Scheme?\n We give a few answers to that here, supposing that we want to vary a parameter \nx\n from \na\n to \nb\n in steps of \ndx\n, and do something for each value of \nx\n.\n\n\nThe classic way, in Scheme, is to write a \ntail-recursive\n function:\n\n\n(define\u00a0(doit\u00a0x\u00a0x-max\u00a0dx)\n\n\n(if\u00a0(\n=\u00a0x\u00a0x-max)\n\n\n(begin\n\n\n...perform\n \nloop\n \nbody\n \nwith\n \nx...\n\n\n(doit\u00a0(+\u00a0x\u00a0dx)\u00a0x-max\u00a0dx))))\n\n\n(doit\u00a0a\u00a0b\u00a0dx)\u00a0;\u00a0execute\u00a0loop\u00a0from\u00a0a\u00a0to\u00a0b\u00a0in\u00a0steps\u00a0of\u00a0dx\n\n\nThere is also a \ndo-loop construct\n in Scheme that you can use\n\n\n(do\u00a0((x\u00a0a\u00a0(+\u00a0x\u00a0dx)))\u00a0((\n\u00a0x\u00a0b))\n...perform\n \nloop\n \nbody\n \nwith\n \nx...\n)\n\n\nIf you have a list of values of \nx\n that you want to loop over, then you can use \nmap\n:\n\n\n(map\u00a0(lambda\u00a0(x)\n...do\n \nstuff\n \nwith\n \nx...\n)\nlist-of-x-values\n)\n\n\nHow to Read In Values from a Text File in Scheme\n\n\nA simple command to read a text file and store its values within a variable in Scheme is \nread\n. As an example, suppose a file \nfoo.dat\n contains the following text, including parentheses:\n\n\n(1 3 12.2 14.5 16 18)\n\n\nIn Scheme, we would then use\n\n\n(define\u00a0port\u00a0(open-input-file\u00a0\"foo.dat\"))\n\n\n(define\u00a0foo\u00a0(read\u00a0port))\n\n\n(close-input-port\u00a0port)\n\n\nThe variable \nfoo\n would then be a list of numbers '(1 3 12.2 14.5 16 18).\n\n\nTricks Specific to Libctl-Using Programs such as \nMPB\n or \nMeep\n\n\nlibctl\n has a couple of built-in functions \narith-sequence\n and \ninterpolate\n (see the \nuser reference\n) to construct lists of a regular sequence of values, which you can use in conjunction with \nmap\n as above:\n\n\n(map (lambda (x)\n...do\n \nstuff\n \nwith\n \nx...\n) (arith-sequence\u00a0x-min\u00a0dx\u00a0num-x))\n\n\nor\n\n\n(map (lambda (x)\n...do\n \nstuff\n \nwith\n \nx...\n) (interpolate\u00a0num-x\u00a0(list\u00a0a\u00a0b)))\n\n\nFinally, if you have an entire libctl input file \nmyfile.ctl\n that you want to loop, varying over some \nparameter\n \nx\n, you can do so by writing a loop on the Unix command-line. Using the \nbash\n shell, you could do:\n\n\nfor x in `seq a dx b`; do meep x=$x myfile.ctl; done", 
            "title": "Guile and Scheme Information"
        }, 
        {
            "location": "/Guile_and_Scheme_Information/#scheme", 
            "text": "Scheme is a simplified derivative of  Lisp , and is a small and beautiful dynamically typed,  lexically scoped ,  functional  language.   A  history and introduction to Scheme  R5RS  is the official Scheme language definition and reference.  A classic  introduction  to Scheme by Ken Dickey.  Structure and Interpretation of Computer Programs  by Abelson, Sussman, and Sussman (full text online).  Introduction to Scheme and its Implementation  (the complete book on-line) by Prof. Paul R. Wilson ( Univ. of Texas ).  Teach Yourself Scheme  is a nice tutorial-style introduction to Scheme programming.  The  MIT Scheme Home Page  (where do you think Scheme was invented?)  also check out the MIT  Scheme Underground    There is the  comp.lang.scheme  newsgroup, and its  FAQ .  The  Internet Scheme Repository  has a lot of code and documentation.  schemers.org  is another Scheme site and collection of resources.", 
            "title": "Scheme"
        }, 
        {
            "location": "/Guile_and_Scheme_Information/#guile", 
            "text": "Guile is a free implementation of Scheme, designed to be plugged in to other programs as a scripting language.   The  homepage  for the GNU Guile project.  See parts IV and V of the  Guile Reference Manual  for additional Scheme functions and types defined within the Guile environment.", 
            "title": "Guile"
        }, 
        {
            "location": "/Guile_and_Scheme_Information/#how-to-write-a-loop-in-scheme", 
            "text": "The most frequently asked question seems to be:  how do I write a loop in Scheme?  We give a few answers to that here, supposing that we want to vary a parameter  x  from  a  to  b  in steps of  dx , and do something for each value of  x .  The classic way, in Scheme, is to write a  tail-recursive  function:  (define\u00a0(doit\u00a0x\u00a0x-max\u00a0dx)  (if\u00a0( =\u00a0x\u00a0x-max)  (begin  ...perform   loop   body   with   x...  (doit\u00a0(+\u00a0x\u00a0dx)\u00a0x-max\u00a0dx))))  (doit\u00a0a\u00a0b\u00a0dx)\u00a0;\u00a0execute\u00a0loop\u00a0from\u00a0a\u00a0to\u00a0b\u00a0in\u00a0steps\u00a0of\u00a0dx  There is also a  do-loop construct  in Scheme that you can use  (do\u00a0((x\u00a0a\u00a0(+\u00a0x\u00a0dx)))\u00a0(( \u00a0x\u00a0b)) ...perform   loop   body   with   x... )  If you have a list of values of  x  that you want to loop over, then you can use  map :  (map\u00a0(lambda\u00a0(x) ...do   stuff   with   x... ) list-of-x-values )", 
            "title": "How to Write a Loop in Scheme"
        }, 
        {
            "location": "/Guile_and_Scheme_Information/#how-to-read-in-values-from-a-text-file-in-scheme", 
            "text": "A simple command to read a text file and store its values within a variable in Scheme is  read . As an example, suppose a file  foo.dat  contains the following text, including parentheses:  (1 3 12.2 14.5 16 18)  In Scheme, we would then use  (define\u00a0port\u00a0(open-input-file\u00a0\"foo.dat\"))  (define\u00a0foo\u00a0(read\u00a0port))  (close-input-port\u00a0port)  The variable  foo  would then be a list of numbers '(1 3 12.2 14.5 16 18).", 
            "title": "How to Read In Values from a Text File in Scheme"
        }, 
        {
            "location": "/Guile_and_Scheme_Information/#tricks-specific-to-libctl-using-programs-such-as-mpb-or-meep", 
            "text": "libctl  has a couple of built-in functions  arith-sequence  and  interpolate  (see the  user reference ) to construct lists of a regular sequence of values, which you can use in conjunction with  map  as above:  (map (lambda (x) ...do   stuff   with   x... ) (arith-sequence\u00a0x-min\u00a0dx\u00a0num-x))  or  (map (lambda (x) ...do   stuff   with   x... ) (interpolate\u00a0num-x\u00a0(list\u00a0a\u00a0b)))  Finally, if you have an entire libctl input file  myfile.ctl  that you want to loop, varying over some  parameter   x , you can do so by writing a loop on the Unix command-line. Using the  bash  shell, you could do:  for x in `seq a dx b`; do meep x=$x myfile.ctl; done", 
            "title": "Tricks Specific to Libctl-Using Programs such as MPB or Meep"
        }, 
        {
            "location": "/Acknowledgements/", 
            "text": "Acknowledgements\n\n\nMPB's continued development has been supported by a Small Business Innovation Research (SBIR) Phase 1 award from the National Science Foundation (NSF) under award number 1647206. Initial development was supported in part by the Materials Research Science and Engineering Center program of the National Science Foundation under Grant No. DMR-9400334, the U.S. Army Research Office under contract/grant DAAG55-97-1-0366, a National Defense Science and Engineering Fellowship, and an MIT Karl Taylor Compton Fellowship.\n\n\nClarendon Photonics, Inc., deserves special mention for funding development of the parallel version of MPB.", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/License_and_Copyright/", 
            "text": "License and Copyright\n\n\n\n\nOmnis enim res, quae dando non deficit, dum habetur et non datur, nondum habetur, quomodo habenda est.\n\n\n\"For if a thing is not diminished by being shared with others, it is not rightly owned if it is only owned and not shared.\"\n\n\n Saint Augustine, \nDe Doctrina Christiana\n, \nc.\n 396 AD.\n\n\nMIT Photonic-Bands is copyright \u00a9 1999\u20132017, Massachusetts Institute of Technology.\n\n\nMIT Photonic-Bands is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\n\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\n\nYou should have received a copy of the GNU General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. You can also find it on the GNU web site:\n\n\nhttp://www.gnu.org/copyleft/gpl.html\n\n\nThe file \nminpack2-linmin.c\n was derived from the \nMINPACK-2\n package. It is copyright \u00a9 1996 by \nJorge J. Mor\u00e9\n, who has graciously granted us permission to distribute it along with MPB under the GNU General Public License.\n\n\nAs a clarification, we should note that Scheme control (\nctl\n) files, written by the user (i.e. not containing code distributed with MIT Photonic-Bands) and loaded at runtime by the MIT Photonic-Bands software, are \nnot\n considered derived works of MIT Photonic-Bands and do \nnot\n fall thereby under the restrictions of the GNU General Public License.\n\n\nIn addition, all of the example Scheme code in this manual, as well as the example ctl files in the \nmpb-ctl/examples/\n directory, may be freely used, modified, and redistributed, without any restrictions. The warranty disclaimer still applies, of course.\n\n\nReferencing\n\n\nWe kindly ask you to reference MPB and its authors in any publication for which you used MPB. You are not legally \nrequired\n to do so; it is up to your common sense to decide whether you want to comply with this request or not.", 
            "title": "License and Copyright"
        }, 
        {
            "location": "/License_and_Copyright/#referencing", 
            "text": "We kindly ask you to reference MPB and its authors in any publication for which you used MPB. You are not legally  required  to do so; it is up to your common sense to decide whether you want to comply with this request or not.", 
            "title": "Referencing"
        }
    ]
}